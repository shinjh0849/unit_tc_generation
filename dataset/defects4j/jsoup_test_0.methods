 [LINE] protected Node(String baseUri, Attributes attributes) { [LINE] protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] Validate.notNull(baseUri); [LINE] protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] Validate.notNull(attributes); [LINE] protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] childNodes = new ArrayList<Node>(); [LINE] protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] this.baseUri = baseUri.trim(); [LINE] protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] this.attributes = attributes; [LINE] protected Node(String baseUri, Attributes attributes) { [EOL]     Validate.notNull(baseUri); [EOL]     Validate.notNull(attributes); [EOL]     childNodes = new ArrayList<Node>(); [EOL]     this.baseUri = baseUri.trim(); [EOL]     this.attributes = attributes; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] protected Node(String baseUri) { [LINE] protected Node(String baseUri) { [EOL]     this(baseUri, new Attributes()); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] this(baseUri, new Attributes()); [LINE] protected Node(String baseUri) { [EOL]     this(baseUri, new Attributes()); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] public Node attr(String attributeKey, String attributeValue) { [LINE] public Node attr(String attributeKey, String attributeValue) { [EOL]     attributes.put(attributeKey, attributeValue); [EOL]     return this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] attributes.put(attributeKey, attributeValue); [LINE] public Node attr(String attributeKey, String attributeValue) { [EOL]     attributes.put(attributeKey, attributeValue); [EOL]     return this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] return this; [LINE] public Node attr(String attributeKey, String attributeValue) { [EOL]     attributes.put(attributeKey, attributeValue); [EOL]     return this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] public Node childNode(int index) { [LINE] public Node childNode(int index) { [EOL]     return childNodes.get(index); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] return childNodes.get(index); [LINE] public Node childNode(int index) { [EOL]     return childNodes.get(index); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] public Node parent() { [LINE] public Node parent() { [EOL]     return parentNode; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] return parentNode; [LINE] public Node parent() { [EOL]     return parentNode; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] protected void setParentNode(Node parentNode) { [LINE] protected void setParentNode(Node parentNode) { [EOL]     if (this.parentNode != null) [EOL]         throw new NotImplementedException("Cannot (yet) move nodes in tree"); [EOL]     this.parentNode = parentNode; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] if (this.parentNode != null) [LINE] protected void setParentNode(Node parentNode) { [EOL]     if (this.parentNode != null) [EOL]         throw new NotImplementedException("Cannot (yet) move nodes in tree"); [EOL]     this.parentNode = parentNode; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] this.parentNode = parentNode; [LINE] protected void setParentNode(Node parentNode) { [EOL]     if (this.parentNode != null) [EOL]         throw new NotImplementedException("Cannot (yet) move nodes in tree"); [EOL]     this.parentNode = parentNode; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] in.parentNode.removeChild(in); [LINE] protected void replaceChild(Node out, Node in) { [EOL]     Validate.isTrue(out.parentNode == this); [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     Integer index = indexInList(out, childNodes); [EOL]     childNodes.set(index, in); [EOL]     in.parentNode = this; [EOL]     out.parentNode = null; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] protected void addChild(Node in) { [LINE] protected void addChild(Node in) { [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     childNodes.add(in); [EOL]     in.parentNode = this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] Validate.notNull(in); [LINE] protected void addChild(Node in) { [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     childNodes.add(in); [EOL]     in.parentNode = this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] if (in.parentNode != null) [LINE] protected void addChild(Node in) { [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     childNodes.add(in); [EOL]     in.parentNode = this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] childNodes.add(in); [LINE] protected void addChild(Node in) { [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     childNodes.add(in); [EOL]     in.parentNode = this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] in.parentNode = this; [LINE] protected void addChild(Node in) { [EOL]     Validate.notNull(in); [EOL]     if (in.parentNode != null) [EOL]         in.parentNode.removeChild(in); [EOL]     childNodes.add(in); [EOL]     in.parentNode = this; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] public String outerHtml() { [LINE] public String outerHtml() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     outerHtml(accum); [EOL]     return accum.toString(); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] StringBuilder accum = new StringBuilder(); [LINE] public String outerHtml() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     outerHtml(accum); [EOL]     return accum.toString(); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] outerHtml(accum); [LINE] public String outerHtml() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     outerHtml(accum); [EOL]     return accum.toString(); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] return accum.toString(); [LINE] public String outerHtml() { [EOL]     StringBuilder accum = new StringBuilder(); [EOL]     outerHtml(accum); [EOL]     return accum.toString(); [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] int result = parentNode != null ? parentNode.hashCode() : 0; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] return result; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = parentNode != null ? parentNode.hashCode() : 0; [EOL]     result = 31 * result + (attributes != null ? attributes.hashCode() : 0); [EOL]     return result; [EOL] } protected Node(String baseUri, Attributes attributes); protected Node(String baseUri); public abstract String nodeName(); public String attr(String attributeKey); public Attributes attributes(); public Node attr(String attributeKey, String attributeValue); public boolean hasAttr(String attributeKey); public Node removeAttr(String attributeKey); public String baseUri(); public void setBaseUri(String baseUri); public String absUrl(String attributeKey); public Node childNode(int index); public List<Node> childNodes(); public Node parent(); public void remove(); public void replaceWith(Node in); protected void setParentNode(Node parentNode); protected void replaceChild(Node out, Node in); protected void removeChild(Node out); protected void addChild(Node in); protected int nodeDepth(); public List<Node> siblingNodes(); public Node nextSibling(); public Node previousSibling(); public Integer siblingIndex(); protected static Integer indexInList(N search, List<N> nodes); public String outerHtml();  abstract void outerHtml(StringBuilder accum); public String toString(); protected void indent(StringBuilder accum); public boolean equals(Object o); public int hashCode(); Node parentNode; List<Node> childNodes; Attributes attributes; String baseUri
 [LINE] public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [LINE] public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [EOL]     super(baseUri); [EOL]     attributes.put(DECL_KEY, data); [EOL]     this.isProcessingInstruction = isProcessingInstruction; [EOL] } public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction); public String nodeName(); public String getWholeDeclaration();  void outerHtml(StringBuilder accum); public String toString(); String DECL_KEY=Optional["declaration"]; boolean isProcessingInstruction
 [LINE] super(baseUri); [LINE] public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [EOL]     super(baseUri); [EOL]     attributes.put(DECL_KEY, data); [EOL]     this.isProcessingInstruction = isProcessingInstruction; [EOL] } public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction); public String nodeName(); public String getWholeDeclaration();  void outerHtml(StringBuilder accum); public String toString(); String DECL_KEY=Optional["declaration"]; boolean isProcessingInstruction
 [LINE] attributes.put(DECL_KEY, data); [LINE] public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [EOL]     super(baseUri); [EOL]     attributes.put(DECL_KEY, data); [EOL]     this.isProcessingInstruction = isProcessingInstruction; [EOL] } public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction); public String nodeName(); public String getWholeDeclaration();  void outerHtml(StringBuilder accum); public String toString(); String DECL_KEY=Optional["declaration"]; boolean isProcessingInstruction
 [LINE] this.isProcessingInstruction = isProcessingInstruction; [LINE] public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) { [EOL]     super(baseUri); [EOL]     attributes.put(DECL_KEY, data); [EOL]     this.isProcessingInstruction = isProcessingInstruction; [EOL] } public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction); public String nodeName(); public String getWholeDeclaration();  void outerHtml(StringBuilder accum); public String toString(); String DECL_KEY=Optional["declaration"]; boolean isProcessingInstruction
 [LINE] public String val() { [LINE] public String val() { [EOL]     if (size() > 0) [EOL]         return first().val(); [EOL]     else [EOL]         return ""; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] if (size() > 0) [LINE] public String val() { [EOL]     if (size() > 0) [EOL]         return first().val(); [EOL]     else [EOL]         return ""; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return first().val(); [LINE] public String val() { [EOL]     if (size() > 0) [EOL]         return first().val(); [EOL]     else [EOL]         return ""; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] public Elements val(String value) { [LINE] public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] for (Element element : contents) [LINE] public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] element.val(value); [LINE] public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return this; [LINE] public Elements val(String value) { [EOL]     for (Element element : contents) element.val(value); [EOL]     return this; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] public boolean hasText() { [LINE] public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] for (Element element: contents) { [LINE] public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] if (element.hasText()) [LINE] public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return true; [LINE] public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return false; [LINE] public boolean hasText() { [EOL]     for (Element element : contents) { [EOL]         if (element.hasText()) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] public Elements select(String query) { [LINE] public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return Selector.select(query, this); [LINE] public Elements select(String query) { [EOL]     return Selector.select(query, this); [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] public boolean is(String query) { [LINE] public boolean is(String query) { [EOL]     Elements children = this.select(query); [EOL]     return !children.isEmpty(); [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] Elements children = this.select(query); [LINE] public boolean is(String query) { [EOL]     Elements children = this.select(query); [EOL]     return !children.isEmpty(); [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return !children.isEmpty(); [LINE] public boolean is(String query) { [EOL]     Elements children = this.select(query); [EOL]     return !children.isEmpty(); [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] public Element last() { [LINE] public Element last() { [EOL]     return !contents.isEmpty() ? contents.get(contents.size() - 1) : null; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] return !contents.isEmpty() ? contents.get(contents.size() - 1) : null; [LINE] public Element last() { [EOL]     return !contents.isEmpty() ? contents.get(contents.size() - 1) : null; [EOL] } public Elements(); public Elements(Collection<Element> elements); public Elements(List<Element> elements); public Elements(Element... elements); public String attr(String attributeKey); public boolean hasAttr(String attributeKey); public Elements attr(String attributeKey, String attributeValue); public Elements removeAttr(String attributeKey); public Elements addClass(String className); public Elements removeClass(String className); public Elements toggleClass(String className); public boolean hasClass(String className); public String val(); public Elements val(String value); public String text(); public boolean hasText(); public String html(); public String outerHtml(); public Elements html(String html); public Elements prepend(String html); public Elements append(String html); public Elements wrap(String html); public Elements select(String query); public Elements eq(int index); public boolean is(String query); public Element first(); public Element last(); public int size(); public boolean isEmpty(); public boolean contains(Object o); public Iterator<Element> iterator(); public Object[] toArray(); public T[] toArray(T[] a); public boolean add(Element element); public boolean remove(Object o); public boolean containsAll(Collection<?> c); public boolean addAll(Collection<? extends Element> c); public boolean addAll(int index, Collection<? extends Element> c); public boolean removeAll(Collection<?> c); public boolean retainAll(Collection<?> c); public void clear(); public boolean equals(Object o); public int hashCode(); public Element get(int index); public Element set(int index, Element element); public void add(int index, Element element); public Element remove(int index); public int indexOf(Object o); public int lastIndexOf(Object o); public ListIterator<Element> listIterator(); public ListIterator<Element> listIterator(int index); public List<Element> subList(int fromIndex, int toIndex); List<Element> contents
 [LINE] AttributeWithValueNot(String key, String value) { [LINE] AttributeWithValueNot(String key, String value) { [EOL]     super(key, value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] super(key, value); [LINE] AttributeWithValueNot(String key, String value) { [EOL]     super(key, value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] public boolean matches(Element element) { [LINE] public boolean matches(Element element) { [EOL]     return (!value.equalsIgnoreCase(element.attr(key))); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] return (!value.equalsIgnoreCase(element.attr(key))); [LINE] public boolean matches(Element element) { [EOL]     return (!value.equalsIgnoreCase(element.attr(key))); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] AttributeWithValueStarting(String key, String value) { [LINE] AttributeWithValueStarting(String key, String value) { [EOL]     super(key, value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] super(key, value); [LINE] AttributeWithValueStarting(String key, String value) { [EOL]     super(key, value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] public boolean matches(Element element) { [LINE] public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().startsWith(value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] return element.attr(key).toLowerCase().startsWith(value); // value is lower case already [LINE] public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().startsWith(value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] AttributeWithValueEnding(String key, String value) { [LINE] AttributeWithValueEnding(String key, String value) { [EOL]     super(key, value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] super(key, value); [LINE] AttributeWithValueEnding(String key, String value) { [EOL]     super(key, value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] public boolean matches(Element element) { [LINE] public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] return element.attr(key).toLowerCase().endsWith(value); // value is lower case [LINE] public boolean matches(Element element) { [EOL]     return element.attr(key).toLowerCase().endsWith(value); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] IndexLessThan(int index) { [LINE] IndexLessThan(int index) { [EOL]     super(index); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] super(index); [LINE] IndexLessThan(int index) { [EOL]     super(index); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] public boolean matches(Element element) { [LINE] public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() < index; [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] return element.elementSiblingIndex() < index; [LINE] public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() < index; [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] IndexGreaterThan(int index) { [LINE] IndexGreaterThan(int index) { [EOL]     super(index); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] super(index); [LINE] IndexGreaterThan(int index) { [EOL]     super(index); [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] public boolean matches(Element element) { [LINE] public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() > index; [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] return element.elementSiblingIndex() > index; [LINE] public boolean matches(Element element) { [EOL]     return element.elementSiblingIndex() > index; [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] IndexEvaluator(int index) { [LINE] IndexEvaluator(int index) { [EOL]     this.index = index; [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] this.index = index; [LINE] IndexEvaluator(int index) { [EOL]     this.index = index; [EOL] } private Evaluator();  Tag(String tagName);  Id(String id);  Class(String className);  Attribute(String key);  AttributeWithValue(String key, String value);  AttributeWithValueNot(String key, String value);  AttributeWithValueStarting(String key, String value);  AttributeWithValueEnding(String key, String value);  AttributeWithValueContaining(String key, String value);  AttributeKeyPair(String key, String value);  IndexLessThan(int index);  IndexGreaterThan(int index);  IndexEquals(int index);  IndexEvaluator(int index); public abstract boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element); public boolean matches(Element element)
 [LINE] public Cleaner(Whitelist whitelist) { [LINE] public Cleaner(Whitelist whitelist) { [EOL]     Validate.notNull(whitelist); [EOL]     this.whitelist = whitelist; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Validate.notNull(whitelist); [LINE] public Cleaner(Whitelist whitelist) { [EOL]     Validate.notNull(whitelist); [EOL]     this.whitelist = whitelist; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] this.whitelist = whitelist; [LINE] public Cleaner(Whitelist whitelist) { [EOL]     Validate.notNull(whitelist); [EOL]     this.whitelist = whitelist; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] public Document clean(Document dirtyDocument) { [LINE] public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Validate.notNull(dirtyDocument); [LINE] public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Document clean = Document.createShell(dirtyDocument.baseUri()); [LINE] public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] copySafeNodes(dirtyDocument.body(), clean.body()); [LINE] public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] return clean; [LINE] public Document clean(Document dirtyDocument) { [EOL]     Validate.notNull(dirtyDocument); [EOL]     Document clean = Document.createShell(dirtyDocument.baseUri()); [EOL]     copySafeNodes(dirtyDocument.body(), clean.body()); [EOL]     return clean; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] private int copySafeNodes(Element source, Element dest) { [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] List<Node> sourceChildren = source.childNodes(); [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] int numDiscarded = 0; [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] for (Node sourceChild : sourceChildren) { [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] if (sourceChild instanceof Element) { [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Element sourceEl = (Element) sourceChild; [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] ElementMeta meta = createSafeElement(sourceEl); [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Element destChild = meta.el; [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] dest.appendChild(destChild); [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] numDiscarded += meta.numAttribsDiscarded; [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] numDiscarded += copySafeNodes(sourceEl, destChild); // recurs [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] } else if (sourceChild instanceof TextNode) { [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] TextNode sourceText = (TextNode) sourceChild; [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] dest.appendChild(destText); [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] return numDiscarded; [LINE] private int copySafeNodes(Element source, Element dest) { [EOL]     List<Node> sourceChildren = source.childNodes(); [EOL]     int numDiscarded = 0; [EOL]     for (Node sourceChild : sourceChildren) { [EOL]         if (sourceChild instanceof Element) { [EOL]             Element sourceEl = (Element) sourceChild; [EOL]             if (whitelist.isSafeTag(sourceEl.tagName())) { [EOL]                 ElementMeta meta = createSafeElement(sourceEl); [EOL]                 Element destChild = meta.el; [EOL]                 dest.appendChild(destChild); [EOL]                 numDiscarded += meta.numAttribsDiscarded; [EOL]                 numDiscarded += copySafeNodes(sourceEl, destChild); [EOL]             } else { [EOL]                 numDiscarded++; [EOL]                 numDiscarded += copySafeNodes(sourceEl, dest); [EOL]             } [EOL]         } else if (sourceChild instanceof TextNode) { [EOL]             TextNode sourceText = (TextNode) sourceChild; [EOL]             TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri()); [EOL]             dest.appendChild(destText); [EOL]         } [EOL]     } [EOL]     return numDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] private ElementMeta createSafeElement(Element sourceEl) { [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] String sourceTag = sourceEl.tagName(); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Attributes destAttrs = new Attributes(); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] int numDiscarded = 0; [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Attributes sourceAttrs = sourceEl.attributes(); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] for (Attribute sourceAttr : sourceAttrs) { [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] numDiscarded++; [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] destAttrs.addAll(enforcedAttrs); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] return new ElementMeta(dest, numDiscarded); [LINE] private ElementMeta createSafeElement(Element sourceEl) { [EOL]     String sourceTag = sourceEl.tagName(); [EOL]     Attributes destAttrs = new Attributes(); [EOL]     Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); [EOL]     int numDiscarded = 0; [EOL]     Attributes sourceAttrs = sourceEl.attributes(); [EOL]     for (Attribute sourceAttr : sourceAttrs) { [EOL]         if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) [EOL]             destAttrs.put(sourceAttr); [EOL]         else [EOL]             numDiscarded++; [EOL]     } [EOL]     Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); [EOL]     destAttrs.addAll(enforcedAttrs); [EOL]     return new ElementMeta(dest, numDiscarded); [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] ElementMeta(Element el, int numAttribsDiscarded) { [LINE] ElementMeta(Element el, int numAttribsDiscarded) { [EOL]     this.el = el; [EOL]     this.numAttribsDiscarded = numAttribsDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] this.el = el; [LINE] ElementMeta(Element el, int numAttribsDiscarded) { [EOL]     this.el = el; [EOL]     this.numAttribsDiscarded = numAttribsDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] this.numAttribsDiscarded = numAttribsDiscarded; [LINE] ElementMeta(Element el, int numAttribsDiscarded) { [EOL]     this.el = el; [EOL]     this.numAttribsDiscarded = numAttribsDiscarded; [EOL] } public Cleaner(Whitelist whitelist);  ElementMeta(Element el, int numAttribsDiscarded); public Document clean(Document dirtyDocument); public boolean isValid(Document dirtyDocument); private int copySafeNodes(Element source, Element dest); private ElementMeta createSafeElement(Element sourceEl); Whitelist whitelist
 [LINE] public void addFirst(Character c) { [LINE] public void addFirst(Character c) { [EOL]     queue.addFirst(c); [EOL] } public TokenQueue(String data); public boolean isEmpty(); public Character peek(); public void addFirst(Character c); public void addFirst(String seq); public boolean matches(String seq); public boolean matchesAny(String... seq); public boolean matchChomp(String seq); public boolean matchesWhitespace(); public boolean matchesWord(); public Character consume(); public void consume(String seq); public String consumeTo(String seq); public String consumeToAny(String... seq); public String chompTo(String seq); public boolean consumeWhitespace(); public String consumeWord(); public String consumeCssIdentifier(); public String consumeAttributeKey(); public String remainder(); public String toString(); LinkedList<Character> queue
 [LINE] queue.addFirst(c); [LINE] public void addFirst(Character c) { [EOL]     queue.addFirst(c); [EOL] } public TokenQueue(String data); public boolean isEmpty(); public Character peek(); public void addFirst(Character c); public void addFirst(String seq); public boolean matches(String seq); public boolean matchesAny(String... seq); public boolean matchChomp(String seq); public boolean matchesWhitespace(); public boolean matchesWord(); public Character consume(); public void consume(String seq); public String consumeTo(String seq); public String consumeToAny(String... seq); public String chompTo(String seq); public boolean consumeWhitespace(); public String consumeWord(); public String consumeCssIdentifier(); public String consumeAttributeKey(); public String remainder(); public String toString(); LinkedList<Character> queue
 [LINE] public void addFirst(String seq) { [LINE] public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] } public TokenQueue(String data); public boolean isEmpty(); public Character peek(); public void addFirst(Character c); public void addFirst(String seq); public boolean matches(String seq); public boolean matchesAny(String... seq); public boolean matchChomp(String seq); public boolean matchesWhitespace(); public boolean matchesWord(); public Character consume(); public void consume(String seq); public String consumeTo(String seq); public String consumeToAny(String... seq); public String chompTo(String seq); public boolean consumeWhitespace(); public String consumeWord(); public String consumeCssIdentifier(); public String consumeAttributeKey(); public String remainder(); public String toString(); LinkedList<Character> queue
 [LINE] char[] chars = seq.toCharArray(); [LINE] public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] } public TokenQueue(String data); public boolean isEmpty(); public Character peek(); public void addFirst(Character c); public void addFirst(String seq); public boolean matches(String seq); public boolean matchesAny(String... seq); public boolean matchChomp(String seq); public boolean matchesWhitespace(); public boolean matchesWord(); public Character consume(); public void consume(String seq); public String consumeTo(String seq); public String consumeToAny(String... seq); public String chompTo(String seq); public boolean consumeWhitespace(); public String consumeWord(); public String consumeCssIdentifier(); public String consumeAttributeKey(); public String remainder(); public String toString(); LinkedList<Character> queue
 [LINE] for (int i = chars.length - 1; i >= 0; i--) { [LINE] public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] } public TokenQueue(String data); public boolean isEmpty(); public Character peek(); public void addFirst(Character c); public void addFirst(String seq); public boolean matches(String seq); public boolean matchesAny(String... seq); public boolean matchChomp(String seq); public boolean matchesWhitespace(); public boolean matchesWord(); public Character consume(); public void consume(String seq); public String consumeTo(String seq); public String consumeToAny(String... seq); public String chompTo(String seq); public boolean consumeWhitespace(); public String consumeWord(); public String consumeCssIdentifier(); public String consumeAttributeKey(); public String remainder(); public String toString(); LinkedList<Character> queue
 [LINE] addFirst(chars[i]); [LINE] public void addFirst(String seq) { [EOL]     char[] chars = seq.toCharArray(); [EOL]     for (int i = chars.length - 1; i >= 0; i--) { [EOL]         addFirst(chars[i]); [EOL]     } [EOL] } public TokenQueue(String data); public boolean isEmpty(); public Character peek(); public void addFirst(Character c); public void addFirst(String seq); public boolean matches(String seq); public boolean matchesAny(String... seq); public boolean matchChomp(String seq); public boolean matchesWhitespace(); public boolean matchesWord(); public Character consume(); public void consume(String seq); public String consumeTo(String seq); public String consumeToAny(String... seq); public String chompTo(String seq); public boolean consumeWhitespace(); public String consumeWord(); public String consumeCssIdentifier(); public String consumeAttributeKey(); public String remainder(); public String toString(); LinkedList<Character> queue
 [LINE] else if (combinator.equals(" ")) [LINE] private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] else if (combinator.equals("+")) [LINE] private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] output = filterForAdjacentSiblings(elements, select(subQuery, root)); [LINE] private void combinator(String combinator) { [EOL]     tq.consumeWhitespace(); [EOL]     String subQuery = tq.consumeToAny(combinators); [EOL]     Elements output; [EOL]     if (combinator.equals(">")) [EOL]         output = filterForChildren(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals(" ")) [EOL]         output = filterForDescendants(elements, select(subQuery, elements)); [EOL]     else if (combinator.equals("+")) [EOL]         output = filterForAdjacentSiblings(elements, select(subQuery, root)); [EOL]     else if (combinator.equals("~")) [EOL]         output = filterForGeneralSiblings(elements, select(subQuery, root)); [EOL]     else [EOL]         throw new IllegalStateException("Unknown combinator: " + combinator); [EOL]     elements.clear(); [EOL]     elements.addAll(output); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] } else if (tq.matchChomp(":lt(")) { [LINE] private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return indexLessThan(); [LINE] private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] } else if (tq.matchChomp(":gt(")) { [LINE] private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return indexGreaterThan(); [LINE] private Elements findElements() { [EOL]     if (tq.matchChomp("#")) { [EOL]         return byId(); [EOL]     } else if (tq.matchChomp(".")) { [EOL]         return byClass(); [EOL]     } else if (tq.matchesWord()) { [EOL]         return byTag(); [EOL]     } else if (tq.matchChomp("[")) { [EOL]         return byAttribute(); [EOL]     } else if (tq.matchChomp("*")) { [EOL]         return allElements(); [EOL]     } else if (tq.matchChomp(":lt(")) { [EOL]         return indexLessThan(); [EOL]     } else if (tq.matchChomp(":gt(")) { [EOL]         return indexGreaterThan(); [EOL]     } else if (tq.matchChomp(":eq(")) { [EOL]         return indexEquals(); [EOL]     } else { [EOL]         throw new SelectorParseException("Could not parse query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] else if (tq.matchChomp("!=")) [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] else if (tq.matchChomp("^=")) [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] else if (tq.matchChomp("$=")) [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] else if (tq.matchChomp("*=")) [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [LINE] private Elements byAttribute() { [EOL]     String key = tq.consumeToAny("=", "!=", "^=", "$=", "*=", "]"); [EOL]     Validate.notEmpty(key); [EOL]     if (tq.matchChomp("]")) { [EOL]         return root.getElementsByAttribute(key); [EOL]     } else { [EOL]         if (tq.matchChomp("=")) [EOL]             return root.getElementsByAttributeValue(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("!=")) [EOL]             return root.getElementsByAttributeValueNot(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("^=")) [EOL]             return root.getElementsByAttributeValueStarting(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("$=")) [EOL]             return root.getElementsByAttributeValueEnding(key, tq.chompTo("]")); [EOL]         else if (tq.matchChomp("*=")) [EOL]             return root.getElementsByAttributeValueContaining(key, tq.chompTo("]")); [EOL]         else [EOL]             throw new SelectorParseException("Could not parse attribute query " + query); [EOL]     } [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] private Elements indexLessThan() { [LINE] private Elements indexLessThan() { [EOL]     return root.getElementsByIndexLessThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return root.getElementsByIndexLessThan(consumeIndex()); [LINE] private Elements indexLessThan() { [EOL]     return root.getElementsByIndexLessThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] private Elements indexGreaterThan() { [LINE] private Elements indexGreaterThan() { [EOL]     return root.getElementsByIndexGreaterThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return root.getElementsByIndexGreaterThan(consumeIndex()); [LINE] private Elements indexGreaterThan() { [EOL]     return root.getElementsByIndexGreaterThan(consumeIndex()); [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] private int consumeIndex() { [LINE] private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] String indexS = tq.chompTo(")").trim(); [LINE] private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [LINE] private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] int index = Integer.parseInt(indexS); [LINE] private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return index; [LINE] private int consumeIndex() { [EOL]     String indexS = tq.chompTo(")").trim(); [EOL]     Validate.isTrue(StringUtils.isNumeric(indexS), "Index must be numeric"); [EOL]     int index = Integer.parseInt(indexS); [EOL]     return index; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] Elements siblings = new Elements(); [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] SIBLING: for (Element c: candidates) { [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] for (Element e: elements) { [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] if (!e.parent().equals(c.parent())) [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] Element previousSib = c.previousElementSibling(); [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] if (previousSib != null && previousSib.equals(e)) { [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] siblings.add(c); [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] continue SIBLING; [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] return siblings; [LINE] private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) { [EOL]     Elements siblings = new Elements(); [EOL]     SIBLING: for (Element c : candidates) { [EOL]         for (Element e : elements) { [EOL]             if (!e.parent().equals(c.parent())) [EOL]                 continue; [EOL]             Element previousSib = c.previousElementSibling(); [EOL]             if (previousSib != null && previousSib.equals(e)) { [EOL]                 siblings.add(c); [EOL]                 continue SIBLING; [EOL]             } [EOL]         } [EOL]     } [EOL]     return siblings; [EOL] } private Selector(String query, Element root); public SelectorParseException(String s); public static Elements select(String query, Element root); public static Elements select(String query, Iterable<Element> roots); private Elements select(); private void combinator(String combinator); private Elements findElements(); private void addElements(Collection<Element> add); private void intersectElements(Collection<Element> intersect); private Elements byId(); private Elements byClass(); private Elements byTag(); private Elements byAttribute(); private Elements allElements(); private Elements indexLessThan(); private Elements indexGreaterThan(); private Elements indexEquals(); private int consumeIndex(); private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates); private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates); private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates); String[] combinators=Optional[{ ",", ">", "+", "~", " " }]; Element root; LinkedHashSet<Element> elements; String query; TokenQueue tq
 [LINE] public TextNode(String text, String baseUri) { [LINE] public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] super(baseUri); [LINE] public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] attributes.put(TEXT_KEY, text); [LINE] public TextNode(String text, String baseUri) { [EOL]     super(baseUri); [EOL]     attributes.put(TEXT_KEY, text); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] public String text() { [LINE] public String text() { [EOL]     return outerHtml(); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] return outerHtml(); [LINE] public String text() { [EOL]     return outerHtml(); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] public TextNode text(String text) { [LINE] public TextNode text(String text) { [EOL]     attributes.put(TEXT_KEY, text); [EOL]     return this; [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] attributes.put(TEXT_KEY, text); [LINE] public TextNode text(String text) { [EOL]     attributes.put(TEXT_KEY, text); [EOL]     return this; [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] return this; [LINE] public TextNode text(String text) { [EOL]     attributes.put(TEXT_KEY, text); [EOL]     return this; [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] public String getWholeText() { [LINE] public String getWholeText() { [EOL]     return attributes.get(TEXT_KEY); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] return attributes.get(TEXT_KEY); [LINE] public String getWholeText() { [EOL]     return attributes.get(TEXT_KEY); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] public boolean isBlank() { [LINE] public boolean isBlank() { [EOL]     return StringUtils.isBlank(normaliseWhitespace(getWholeText())); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] return StringUtils.isBlank(normaliseWhitespace(getWholeText())); [LINE] public boolean isBlank() { [EOL]     return StringUtils.isBlank(normaliseWhitespace(getWholeText())); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] void outerHtml(StringBuilder accum) { [LINE] void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] String html = StringEscapeUtils.escapeHtml(getWholeText()); [LINE] void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [LINE] void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] html = normaliseWhitespace(html); [LINE] void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock()  && siblingIndex() == 0) [LINE] void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] accum.append(html); [LINE] void outerHtml(StringBuilder accum) { [EOL]     String html = StringEscapeUtils.escapeHtml(getWholeText()); [EOL]     if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) { [EOL]         html = normaliseWhitespace(html); [EOL]     } [EOL]     if (!isBlank() && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && siblingIndex() == 0) [EOL]         indent(accum); [EOL]     accum.append(html); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] public static TextNode createFromEncoded(String encodedText, String baseUri) { [LINE] public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] String text = StringEscapeUtils.unescapeHtml(encodedText); [LINE] public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] return new TextNode(text, baseUri); [LINE] public static TextNode createFromEncoded(String encodedText, String baseUri) { [EOL]     String text = StringEscapeUtils.unescapeHtml(encodedText); [EOL]     return new TextNode(text, baseUri); [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] static String normaliseWhitespace(String text) { [LINE] static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); // more than one space, and newlines to " " [LINE] static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] return text; [LINE] static String normaliseWhitespace(String text) { [EOL]     text = text.replaceAll("\\s{2,}|(\\r\\n|\\r|\\n)", " "); [EOL]     return text; [EOL] } public TextNode(String text, String baseUri); public String nodeName(); public String text(); public TextNode text(String text); public String getWholeText(); public boolean isBlank();  void outerHtml(StringBuilder accum); public String toString(); public static TextNode createFromEncoded(String encodedText, String baseUri);  static String normaliseWhitespace(String text);  static String stripLeadingWhitespace(String text);  static boolean lastCharIsWhitespace(StringBuilder sb); String TEXT_KEY=Optional["text"]
 [LINE] public Element attr(String attributeKey, String attributeValue) { [LINE] public Element attr(String attributeKey, String attributeValue) { [EOL]     super.attr(attributeKey, attributeValue); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] super.attr(attributeKey, attributeValue); [LINE] public Element attr(String attributeKey, String attributeValue) { [EOL]     super.attr(attributeKey, attributeValue); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return this; [LINE] public Element attr(String attributeKey, String attributeValue) { [EOL]     super.attr(attributeKey, attributeValue); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Element child(int index) { [LINE] public Element child(int index) { [EOL]     return children().get(index); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return children().get(index); [LINE] public Element child(int index) { [EOL]     return children().get(index); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Element prependElement(String tagName) { [LINE] public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Element child = new Element(Tag.valueOf(tagName), baseUri()); [LINE] public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] prependChild(child); [LINE] public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return child; [LINE] public Element prependElement(String tagName) { [EOL]     Element child = new Element(Tag.valueOf(tagName), baseUri()); [EOL]     prependChild(child); [EOL]     return child; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Element wrap(String html) { [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Validate.notEmpty(html); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Elements wrapChildren = wrapBody.children(); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Element wrap = wrapChildren.first(); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] if (wrap == null) // nothing to wrap with; noop [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Element deepest = getDeepChild(wrap); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] parentNode.replaceChild(this, wrap); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] deepest.addChild(this); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] if (wrapChildren.size() > 1) { [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] for (int i = 1; i < wrapChildren.size(); i++) { // skip first [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Element remainder = wrapChildren.get(i); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] remainder.parentNode.removeChild(remainder); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] wrap.appendChild(remainder); [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return this; [LINE] public Element wrap(String html) { [EOL]     Validate.notEmpty(html); [EOL]     Element wrapBody = Parser.parseBodyFragment(html, baseUri).body(); [EOL]     Elements wrapChildren = wrapBody.children(); [EOL]     Element wrap = wrapChildren.first(); [EOL]     if (wrap == null) [EOL]         return null; [EOL]     Element deepest = getDeepChild(wrap); [EOL]     parentNode.replaceChild(this, wrap); [EOL]     deepest.addChild(this); [EOL]     if (wrapChildren.size() > 1) { [EOL]         for (int i = 1; i < wrapChildren.size(); i++) { [EOL]             Element remainder = wrapChildren.get(i); [EOL]             remainder.parentNode.removeChild(remainder); [EOL]             wrap.appendChild(remainder); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] private Element getDeepChild(Element el) { [LINE] private Element getDeepChild(Element el) { [EOL]     List<Element> children = el.children(); [EOL]     if (children.size() > 0) [EOL]         return getDeepChild(children.get(0)); [EOL]     else [EOL]         return el; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] List<Element> children = el.children(); [LINE] private Element getDeepChild(Element el) { [EOL]     List<Element> children = el.children(); [EOL]     if (children.size() > 0) [EOL]         return getDeepChild(children.get(0)); [EOL]     else [EOL]         return el; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] if (children.size() > 0) [LINE] private Element getDeepChild(Element el) { [EOL]     List<Element> children = el.children(); [EOL]     if (children.size() > 0) [EOL]         return getDeepChild(children.get(0)); [EOL]     else [EOL]         return el; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return el; [LINE] private Element getDeepChild(Element el) { [EOL]     List<Element> children = el.children(); [EOL]     if (children.size() > 0) [EOL]         return getDeepChild(children.get(0)); [EOL]     else [EOL]         return el; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Element previousElementSibling() { [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] List<Element> siblings = parent().children(); [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Integer index = indexInList(this, siblings); [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] Validate.notNull(index); [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] if (index > 0) [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return siblings.get(index-1); [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return null; [LINE] public Element previousElementSibling() { [EOL]     List<Element> siblings = parent().children(); [EOL]     Integer index = indexInList(this, siblings); [EOL]     Validate.notNull(index); [EOL]     if (index > 0) [EOL]         return siblings.get(index - 1); [EOL]     else [EOL]         return null; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getElementsByAttributeValue(String key, String value) { [LINE] public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [LINE] public Elements getElementsByAttributeValue(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getElementsByAttributeValueNot(String key, String value) { [LINE] public Elements getElementsByAttributeValueNot(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [LINE] public Elements getElementsByAttributeValueNot(String key, String value) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [LINE] public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [LINE] public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { [LINE] public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); [LINE] public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { [EOL]     return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getElementsByIndexLessThan(int index) { [LINE] public Elements getElementsByIndexLessThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexLessThan(index), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.IndexLessThan(index), this); [LINE] public Elements getElementsByIndexLessThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexLessThan(index), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getElementsByIndexGreaterThan(int index) { [LINE] public Elements getElementsByIndexGreaterThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [LINE] public Elements getElementsByIndexGreaterThan(int index) { [EOL]     return Collector.collect(new Evaluator.IndexGreaterThan(index), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Elements getAllElements() { [LINE] public Elements getAllElements() { [EOL]     return Collector.collect(new Evaluator.AllElements(), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return Collector.collect(new Evaluator.AllElements(), this); [LINE] public Elements getAllElements() { [EOL]     return Collector.collect(new Evaluator.AllElements(), this); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public String val() { [LINE] public String val() { [EOL]     if (tagName().equals("textarea")) [EOL]         return text(); [EOL]     else [EOL]         return attr("value"); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] if (tagName().equals("textarea")) [LINE] public String val() { [EOL]     if (tagName().equals("textarea")) [EOL]         return text(); [EOL]     else [EOL]         return attr("value"); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return text(); [LINE] public String val() { [EOL]     if (tagName().equals("textarea")) [EOL]         return text(); [EOL]     else [EOL]         return attr("value"); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return attr("value"); [LINE] public String val() { [EOL]     if (tagName().equals("textarea")) [EOL]         return text(); [EOL]     else [EOL]         return attr("value"); [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] public Element val(String value) { [LINE] public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] if (tagName().equals("textarea")) [LINE] public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] text(value); [LINE] public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] attr("value", value); [LINE] public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] return this; [LINE] public Element val(String value) { [EOL]     if (tagName().equals("textarea")) [EOL]         text(value); [EOL]     else [EOL]         attr("value", value); [EOL]     return this; [EOL] } public Element(Tag tag, String baseUri, Attributes attributes); public Element(Tag tag, String baseUri); public String nodeName(); public String tagName(); public Tag tag(); public boolean isBlock(); public String id(); public Element attr(String attributeKey, String attributeValue); public Element parent(); public Element child(int index); public Elements children(); public Elements select(String query); public Element appendChild(Node child); public Element prependChild(Node child); public Element appendElement(String tagName); public Element prependElement(String tagName); public Element appendText(String text); public Element prependText(String text); public Element append(String html); public Element prepend(String html); public Element empty(); public Element wrap(String html); private Element getDeepChild(Element el); public Elements siblingElements(); public Element nextElementSibling(); public Element previousElementSibling(); public Element firstElementSibling(); public Integer elementSiblingIndex(); public Element lastElementSibling(); public Elements getElementsByTag(String tagName); public Element getElementById(String id); public Elements getElementsByClass(String className); public Elements getElementsByAttribute(String key); public Elements getElementsByAttributeValue(String key, String value); public Elements getElementsByAttributeValueNot(String key, String value); public Elements getElementsByAttributeValueStarting(String key, String valuePrefix); public Elements getElementsByAttributeValueEnding(String key, String valueSuffix); public Elements getElementsByAttributeValueContaining(String key, String match); public Elements getElementsByIndexLessThan(int index); public Elements getElementsByIndexGreaterThan(int index); public Elements getElementsByIndexEquals(int index); public Elements getAllElements(); public String text(); private void text(StringBuilder accum);  boolean preserveWhitespace(); public Element text(String text); public boolean hasText(); public String data(); public String className(); public Set<String> classNames(); public Element classNames(Set<String> classNames); public boolean hasClass(String className); public Element addClass(String className); public Element removeClass(String className); public Element toggleClass(String className); public String val(); public Element val(String value);  void outerHtml(StringBuilder accum); public String html(); private void html(StringBuilder accum); public Element html(String html); public String toString(); public boolean equals(Object o); public int hashCode(); Tag tag; Set<String> classNames
 [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Validate.notNull(html); [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Validate.notNull(baseUri); [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] stack = new LinkedList<Element>(); [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] tq = new TokenQueue(html); [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] this.baseUri = baseUri; [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (isBodyFragment) { [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] doc = new Document(baseUri); [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] stack.add(doc); [LINE] private Parser(String html, String baseUri, boolean isBodyFragment) { [EOL]     Validate.notNull(html); [EOL]     Validate.notNull(baseUri); [EOL]     stack = new LinkedList<Element>(); [EOL]     tq = new TokenQueue(html); [EOL]     this.baseUri = baseUri; [EOL]     if (isBodyFragment) { [EOL]         doc = Document.createShell(baseUri); [EOL]         stack.add(doc.body()); [EOL]     } else { [EOL]         doc = new Document(baseUri); [EOL]         stack.add(doc); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] public static Document parse(String html, String baseUri) { [LINE] public static Document parse(String html, String baseUri) { [EOL]     Parser parser = new Parser(html, baseUri, false); [EOL]     return parser.parse(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Parser parser = new Parser(html, baseUri, false); [LINE] public static Document parse(String html, String baseUri) { [EOL]     Parser parser = new Parser(html, baseUri, false); [EOL]     return parser.parse(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return parser.parse(); [LINE] public static Document parse(String html, String baseUri) { [EOL]     Parser parser = new Parser(html, baseUri, false); [EOL]     return parser.parse(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private Document parse() { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] while (!tq.isEmpty()) { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (tq.matches("<!--")) { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] } else if (tq.matches("<![CDATA[")) { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] } else if (tq.matches("<?") || tq.matches("<!")) { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] } else if (tq.matches("</")) { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] parseEndTag(); [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] } else if (tq.matches("<")) { [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] parseStartTag(); [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] parseTextNode(); [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return doc.normalise(); [LINE] private Document parse() { [EOL]     while (!tq.isEmpty()) { [EOL]         if (tq.matches("<!--")) { [EOL]             parseComment(); [EOL]         } else if (tq.matches("<![CDATA[")) { [EOL]             parseCdata(); [EOL]         } else if (tq.matches("<?") || tq.matches("<!")) { [EOL]             parseXmlDecl(); [EOL]         } else if (tq.matches("</")) { [EOL]             parseEndTag(); [EOL]         } else if (tq.matches("<")) { [EOL]             parseStartTag(); [EOL]         } else { [EOL]             parseTextNode(); [EOL]         } [EOL]     } [EOL]     return doc.normalise(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private void parseEndTag() { [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] tq.consume("</"); [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] String tagName = tq.consumeWord(); [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] tq.chompTo(">"); [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (tagName.length() != 0) { [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Tag tag = Tag.valueOf(tagName); [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] popStackToClose(tag); [LINE] private void parseEndTag() { [EOL]     tq.consume("</"); [EOL]     String tagName = tq.consumeWord(); [EOL]     tq.chompTo(">"); [EOL]     if (tagName.length() != 0) { [EOL]         Tag tag = Tag.valueOf(tagName); [EOL]         popStackToClose(tag); [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private void parseStartTag() { [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] tq.consume("<"); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] String tagName = tq.consumeWord(); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] tq.addFirst("&lt;"); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] parseTextNode(); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return; [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Attributes attributes = new Attributes(); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Tag tag = Tag.valueOf(tagName); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element child = new Element(tag, baseUri, attributes); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/> [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (tq.matchChomp("/>")) { // close empty element or tag [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] tq.matchChomp(">"); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (tag.isData()) { [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] dataNode = new DataNode(data, baseUri); // data not encoded but raw (for " in script) [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (child.tagName().equals("base")) { [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] String href = child.absUrl("href"); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (href.length() != 0) { // ignore <base target> etc [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] addChildToParent(child, isEmptyElement); [LINE] private void parseStartTag() { [EOL]     tq.consume("<"); [EOL]     String tagName = tq.consumeWord(); [EOL]     if (tagName.length() == 0) { [EOL]         tq.addFirst("&lt;"); [EOL]         parseTextNode(); [EOL]         return; [EOL]     } [EOL]     Attributes attributes = new Attributes(); [EOL]     while (!tq.matchesAny("<", "/>", ">") && !tq.isEmpty()) { [EOL]         Attribute attribute = parseAttribute(); [EOL]         if (attribute != null) [EOL]             attributes.put(attribute); [EOL]     } [EOL]     Tag tag = Tag.valueOf(tagName); [EOL]     Element child = new Element(tag, baseUri, attributes); [EOL]     boolean isEmptyElement = tag.isEmpty(); [EOL]     if (tq.matchChomp("/>")) { [EOL]         isEmptyElement = true; [EOL]     } else { [EOL]         tq.matchChomp(">"); [EOL]     } [EOL]     if (tag.isData()) { [EOL]         String data = tq.chompTo("</" + tagName); [EOL]         tq.chompTo(">"); [EOL]         Node dataNode; [EOL]         if (tag.equals(titleTag) || tag.equals(textareaTag)) [EOL]             dataNode = TextNode.createFromEncoded(data, baseUri); [EOL]         else [EOL]             dataNode = new DataNode(data, baseUri); [EOL]         child.appendChild(dataNode); [EOL]     } [EOL]     if (child.tagName().equals("base")) { [EOL]         String href = child.absUrl("href"); [EOL]         if (href.length() != 0) { [EOL]             baseUri = href; [EOL]             doc.setBaseUri(href); [EOL]         } [EOL]     } [EOL]     addChildToParent(child, isEmptyElement); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] value = tq.chompTo(SQ); [LINE] private Attribute parseAttribute() { [EOL]     tq.consumeWhitespace(); [EOL]     String key = tq.consumeAttributeKey(); [EOL]     String value = ""; [EOL]     tq.consumeWhitespace(); [EOL]     if (tq.matchChomp("=")) { [EOL]         tq.consumeWhitespace(); [EOL]         if (tq.matchChomp(SQ)) { [EOL]             value = tq.chompTo(SQ); [EOL]         } else if (tq.matchChomp(DQ)) { [EOL]             value = tq.chompTo(DQ); [EOL]         } else { [EOL]             StringBuilder valueAccum = new StringBuilder(); [EOL]             while (!tq.matchesAny("<", "/>", ">") && !tq.matchesWhitespace() && !tq.isEmpty()) { [EOL]                 valueAccum.append(tq.consume()); [EOL]             } [EOL]             value = valueAccum.toString(); [EOL]         } [EOL]         tq.consumeWhitespace(); [EOL]     } [EOL]     if (key.length() != 0) [EOL]         return Attribute.createFromEncoded(key, value); [EOL]     else { [EOL]         tq.consume(); [EOL]         return null; [EOL]     } [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private void parseTextNode() { [LINE] private void parseTextNode() { [EOL]     String text = tq.consumeTo("<"); [EOL]     TextNode textNode = TextNode.createFromEncoded(text, baseUri); [EOL]     last().appendChild(textNode); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] String text = tq.consumeTo("<"); [LINE] private void parseTextNode() { [EOL]     String text = tq.consumeTo("<"); [EOL]     TextNode textNode = TextNode.createFromEncoded(text, baseUri); [EOL]     last().appendChild(textNode); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] TextNode textNode = TextNode.createFromEncoded(text, baseUri); [LINE] private void parseTextNode() { [EOL]     String text = tq.consumeTo("<"); [EOL]     TextNode textNode = TextNode.createFromEncoded(text, baseUri); [EOL]     last().appendChild(textNode); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] last().appendChild(textNode); [LINE] private void parseTextNode() { [EOL]     String text = tq.consumeTo("<"); [EOL]     TextNode textNode = TextNode.createFromEncoded(text, baseUri); [EOL]     last().appendChild(textNode); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element parent = popStackToSuitableContainer(child.tag()); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Tag childTag = child.tag(); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] boolean validAncestor = stackHasValidParent(childTag); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (!validAncestor) { [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Tag parentTag = childTag.getImplicitParent(); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element implicit = new Element(parentTag, baseUri); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (child.tag().equals(bodyTag)) { [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element head = new Element(headTag, baseUri); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] implicit.appendChild(head); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] implicit.appendChild(child); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element root = addChildToParent(implicit, false); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (!isEmptyElement) [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] stack.addLast(child); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return root; [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] parent.appendChild(child); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (!isEmptyElement) [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] stack.addLast(child); [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return parent; [LINE] private Element addChildToParent(Element child, boolean isEmptyElement) { [EOL]     Element parent = popStackToSuitableContainer(child.tag()); [EOL]     Tag childTag = child.tag(); [EOL]     boolean validAncestor = stackHasValidParent(childTag); [EOL]     if (!validAncestor) { [EOL]         Tag parentTag = childTag.getImplicitParent(); [EOL]         Element implicit = new Element(parentTag, baseUri); [EOL]         if (child.tag().equals(bodyTag)) { [EOL]             Element head = new Element(headTag, baseUri); [EOL]             implicit.appendChild(head); [EOL]         } [EOL]         implicit.appendChild(child); [EOL]         Element root = addChildToParent(implicit, false); [EOL]         if (!isEmptyElement) [EOL]             stack.addLast(child); [EOL]         return root; [EOL]     } [EOL]     parent.appendChild(child); [EOL]     if (!isEmptyElement) [EOL]         stack.addLast(child); [EOL]     return parent; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private boolean stackHasValidParent(Tag childTag) { [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (stack.size() == 1 && childTag.equals(htmlTag)) [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return true; // root is valid for html node [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] for (int i = stack.size() -1; i >= 0; i--) { [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element el = stack.get(i); [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Tag parent2 = el.tag(); [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (parent2.isValidParent(childTag)) { [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return false; [LINE] private boolean stackHasValidParent(Tag childTag) { [EOL]     if (stack.size() == 1 && childTag.equals(htmlTag)) [EOL]         return true; [EOL]     for (int i = stack.size() - 1; i >= 0; i--) { [EOL]         Element el = stack.get(i); [EOL]         Tag parent2 = el.tag(); [EOL]         if (parent2.isValidParent(childTag)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private Element popStackToSuitableContainer(Tag tag) { [LINE] private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] while (!stack.isEmpty()) { [LINE] private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (last().tag().canContain(tag)) [LINE] private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return last(); [LINE] private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] stack.removeLast(); [LINE] private Element popStackToSuitableContainer(Tag tag) { [EOL]     while (!stack.isEmpty()) { [EOL]         if (last().tag().canContain(tag)) [EOL]             return last(); [EOL]         else [EOL]             stack.removeLast(); [EOL]     } [EOL]     return null; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private Element popStackToClose(Tag tag) { [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] int counter = 0; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element elToClose = null; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] for (int i = stack.size() -1; i > 0; i--) { [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] counter++; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Element el = stack.get(i); [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] Tag elTag = el.tag(); [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] break; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] } else if (elTag.equals(tag)) { [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] elToClose = el; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] break; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] if (elToClose != null) { [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] for (int i = 0; i < counter; i++) { [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] stack.removeLast(); [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return elToClose; [LINE] private Element popStackToClose(Tag tag) { [EOL]     int counter = 0; [EOL]     Element elToClose = null; [EOL]     for (int i = stack.size() - 1; i > 0; i--) { [EOL]         counter++; [EOL]         Element el = stack.get(i); [EOL]         Tag elTag = el.tag(); [EOL]         if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { [EOL]             break; [EOL]         } else if (elTag.equals(tag)) { [EOL]             elToClose = el; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (elToClose != null) { [EOL]         for (int i = 0; i < counter; i++) { [EOL]             stack.removeLast(); [EOL]         } [EOL]     } [EOL]     return elToClose; [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] private Element last() { [LINE] private Element last() { [EOL]     return stack.getLast(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] return stack.getLast(); [LINE] private Element last() { [EOL]     return stack.getLast(); [EOL] } private Parser(String html, String baseUri, boolean isBodyFragment); public static Document parse(String html, String baseUri); public static Document parseBodyFragment(String bodyHtml, String baseUri); private Document parse(); private void parseComment(); private void parseXmlDecl(); private void parseEndTag(); private void parseStartTag(); private Attribute parseAttribute(); private void parseTextNode(); private void parseCdata(); private Element addChildToParent(Element child, boolean isEmptyElement); private boolean stackHasValidParent(Tag childTag); private Element popStackToSuitableContainer(Tag tag); private Element popStackToClose(Tag tag); private Element last(); String SQ=Optional["'"]; String DQ=Optional["\""]; Tag htmlTag=Optional[Tag.valueOf("html")]; Tag headTag=Optional[Tag.valueOf("head")]; Tag bodyTag=Optional[Tag.valueOf("body")]; Tag titleTag=Optional[Tag.valueOf("title")]; Tag textareaTag=Optional[Tag.valueOf("textarea")]; LinkedList<Element> stack; TokenQueue tq; Document doc; String baseUri
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] } public Attribute(String key, String value); public String getKey(); public void setKey(String key); public String getValue(); public void setValue(String value); public String html(); public String toString(); public static Attribute createFromEncoded(String unencodedKey, String encodedValue); public boolean equals(Object o); public int hashCode(); String key; String value
 [LINE] int result = key != null ? key.hashCode() : 0; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] } public Attribute(String key, String value); public String getKey(); public void setKey(String key); public String getValue(); public void setValue(String value); public String html(); public String toString(); public static Attribute createFromEncoded(String unencodedKey, String encodedValue); public boolean equals(Object o); public int hashCode(); String key; String value
 [LINE] result = 31 * result + (value != null ? value.hashCode() : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] } public Attribute(String key, String value); public String getKey(); public void setKey(String key); public String getValue(); public void setValue(String value); public String html(); public String toString(); public static Attribute createFromEncoded(String unencodedKey, String encodedValue); public boolean equals(Object o); public int hashCode(); String key; String value
 [LINE] return result; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = key != null ? key.hashCode() : 0; [EOL]     result = 31 * result + (value != null ? value.hashCode() : 0); [EOL]     return result; [EOL] } public Attribute(String key, String value); public String getKey(); public void setKey(String key); public String getValue(); public void setValue(String value); public String html(); public String toString(); public static Attribute createFromEncoded(String unencodedKey, String encodedValue); public boolean equals(Object o); public int hashCode(); String key; String value
 [LINE] public static Whitelist simpleText() { [LINE] public static Whitelist simpleText() { [EOL]     return new Whitelist().addTags("b", "em", "i", "strong", "u"); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return new Whitelist() [LINE] public static Whitelist simpleText() { [EOL]     return new Whitelist().addTags("b", "em", "i", "strong", "u"); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] public static Whitelist relaxed() { [LINE] public static Whitelist relaxed() { [EOL]     return new Whitelist().addTags("a", "b", "blockquote", "br", "caption", "cite", "code", "col", "colgroup", "dd", "div", "dl", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "i", "img", "li", "ol", "p", "pre", "q", "small", "strike", "strong", "sub", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "u", "ul").addAttributes("a", "href", "title").addAttributes("blockquote", "cite").addAttributes("col", "span", "width").addAttributes("colgroup", "span", "width").addAttributes("img", "align", "alt", "height", "src", "title", "width").addAttributes("ol", "start", "type").addAttributes("q", "cite").addAttributes("table", "summary", "width").addAttributes("td", "abbr", "axis", "colspan", "rowspan", "width").addAttributes("th", "abbr", "axis", "colspan", "rowspan", "scope", "width").addAttributes("ul", "type").addProtocols("a", "href", "ftp", "http", "https", "mailto").addProtocols("blockquote", "cite", "http", "https").addProtocols("img", "src", "http", "https").addProtocols("q", "cite", "http", "https"); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return new Whitelist() [LINE] public static Whitelist relaxed() { [EOL]     return new Whitelist().addTags("a", "b", "blockquote", "br", "caption", "cite", "code", "col", "colgroup", "dd", "div", "dl", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "i", "img", "li", "ol", "p", "pre", "q", "small", "strike", "strong", "sub", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "u", "ul").addAttributes("a", "href", "title").addAttributes("blockquote", "cite").addAttributes("col", "span", "width").addAttributes("colgroup", "span", "width").addAttributes("img", "align", "alt", "height", "src", "title", "width").addAttributes("ol", "start", "type").addAttributes("q", "cite").addAttributes("table", "summary", "width").addAttributes("td", "abbr", "axis", "colspan", "rowspan", "width").addAttributes("th", "abbr", "axis", "colspan", "rowspan", "scope", "width").addAttributes("ul", "type").addProtocols("a", "href", "ftp", "http", "https", "mailto").addProtocols("blockquote", "cite", "http", "https").addProtocols("img", "src", "http", "https").addProtocols("q", "cite", "http", "https"); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] public Whitelist() { [LINE] public Whitelist() { [EOL]     tagNames = new HashSet<TagName>(); [EOL]     attributes = new HashMap<TagName, Set<AttributeKey>>(); [EOL]     enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [EOL]     protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] tagNames = new HashSet<TagName>(); [LINE] public Whitelist() { [EOL]     tagNames = new HashSet<TagName>(); [EOL]     attributes = new HashMap<TagName, Set<AttributeKey>>(); [EOL]     enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [EOL]     protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] attributes = new HashMap<TagName, Set<AttributeKey>>(); [LINE] public Whitelist() { [EOL]     tagNames = new HashSet<TagName>(); [EOL]     attributes = new HashMap<TagName, Set<AttributeKey>>(); [EOL]     enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [EOL]     protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [LINE] public Whitelist() { [EOL]     tagNames = new HashSet<TagName>(); [EOL]     attributes = new HashMap<TagName, Set<AttributeKey>>(); [EOL]     enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [EOL]     protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [LINE] public Whitelist() { [EOL]     tagNames = new HashSet<TagName>(); [EOL]     attributes = new HashMap<TagName, Set<AttributeKey>>(); [EOL]     enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>(); [EOL]     protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>(); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] public Whitelist addTags(String... tags) { [LINE] public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notNull(tags); [LINE] public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] for (String tagName : tags) { [LINE] public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notEmpty(tagName); [LINE] public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] tagNames.add(TagName.valueOf(tagName)); [LINE] public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return this; [LINE] public Whitelist addTags(String... tags) { [EOL]     Validate.notNull(tags); [EOL]     for (String tagName : tags) { [EOL]         Validate.notEmpty(tagName); [EOL]         tagNames.add(TagName.valueOf(tagName)); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] public Whitelist addAttributes(String tag, String... keys) { [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notEmpty(tag); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notNull(keys); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TagName tagName = TagName.valueOf(tag); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] for (String key : keys) { [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notEmpty(key); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] attributeSet.add(AttributeKey.valueOf(key)); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (attributes.containsKey(tagName)) { [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] attributes.put(tagName, attributeSet); [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return this; [LINE] public Whitelist addAttributes(String tag, String... keys) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notNull(keys); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     Set<AttributeKey> attributeSet = new HashSet<AttributeKey>(); [EOL]     for (String key : keys) { [EOL]         Validate.notEmpty(key); [EOL]         attributeSet.add(AttributeKey.valueOf(key)); [EOL]     } [EOL]     if (attributes.containsKey(tagName)) { [EOL]         Set<AttributeKey> currentSet = attributes.get(tagName); [EOL]         currentSet.addAll(attributeSet); [EOL]     } else { [EOL]         attributes.put(tagName, attributeSet); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notEmpty(tag); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notEmpty(key); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notNull(protocols); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TagName tagName = TagName.valueOf(tag); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] AttributeKey attrKey = AttributeKey.valueOf(key); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Map<AttributeKey, Set<Protocol>> attrMap; [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Set<Protocol> protSet; [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (this.protocols.containsKey(tagName)) { [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] this.protocols.put(tagName, attrMap); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (attrMap.containsKey(attrKey)) { [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] protSet = new HashSet<Protocol>(); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] attrMap.put(attrKey, protSet); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] for (String protocol : protocols) { [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notEmpty(protocol); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Protocol prot = Protocol.valueOf(protocol); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] protSet.add(prot); [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return this; [LINE] public Whitelist addProtocols(String tag, String key, String... protocols) { [EOL]     Validate.notEmpty(tag); [EOL]     Validate.notEmpty(key); [EOL]     Validate.notNull(protocols); [EOL]     TagName tagName = TagName.valueOf(tag); [EOL]     AttributeKey attrKey = AttributeKey.valueOf(key); [EOL]     Map<AttributeKey, Set<Protocol>> attrMap; [EOL]     Set<Protocol> protSet; [EOL]     if (this.protocols.containsKey(tagName)) { [EOL]         attrMap = this.protocols.get(tagName); [EOL]     } else { [EOL]         attrMap = new HashMap<AttributeKey, Set<Protocol>>(); [EOL]         this.protocols.put(tagName, attrMap); [EOL]     } [EOL]     if (attrMap.containsKey(attrKey)) { [EOL]         protSet = attrMap.get(attrKey); [EOL]     } else { [EOL]         protSet = new HashSet<Protocol>(); [EOL]         attrMap.put(attrKey, protSet); [EOL]     } [EOL]     for (String protocol : protocols) { [EOL]         Validate.notEmpty(protocol); [EOL]         Protocol prot = Protocol.valueOf(protocol); [EOL]         protSet.add(prot); [EOL]     } [EOL]     return this; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] boolean isSafeTag(String tag) { [LINE] boolean isSafeTag(String tag) { [EOL]     return tagNames.contains(TagName.valueOf(tag)); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return tagNames.contains(TagName.valueOf(tag)); [LINE] boolean isSafeTag(String tag) { [EOL]     return tagNames.contains(TagName.valueOf(tag)); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TagName tag = TagName.valueOf(tagName); [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] AttributeKey key = AttributeKey.valueOf(attr.getKey()); [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (attributes.containsKey(tag)) { [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (attributes.get(tag).contains(key)) { [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (protocols.containsKey(tag)) { [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [LINE] boolean isSafeAttribute(String tagName, Element el, Attribute attr) { [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     AttributeKey key = AttributeKey.valueOf(attr.getKey()); [EOL]     if (attributes.containsKey(tag)) { [EOL]         if (attributes.get(tag).contains(key)) { [EOL]             if (protocols.containsKey(tag)) { [EOL]                 Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag); [EOL]                 return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key)); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return !tagName.equals(":all") && isSafeAttribute(":all", el, attr); [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] String value = el.absUrl(attr.getKey()); [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] attr.setValue(value); [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] for (Protocol protocol : protocols) { [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] String prot = protocol.toString() + ":"; [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (value.toString().toLowerCase().startsWith(prot)) { [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return false; [LINE] private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) { [EOL]     String value = el.absUrl(attr.getKey()); [EOL]     attr.setValue(value); [EOL]     for (Protocol protocol : protocols) { [EOL]         String prot = protocol.toString() + ":"; [EOL]         if (value.toString().toLowerCase().startsWith(prot)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Attributes getEnforcedAttributes(String tagName) { [LINE] Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Attributes attrs = new Attributes(); [LINE] Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TagName tag = TagName.valueOf(tagName); [LINE] Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (enforcedAttributes.containsKey(tag)) { [LINE] Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return attrs; [LINE] Attributes getEnforcedAttributes(String tagName) { [EOL]     Attributes attrs = new Attributes(); [EOL]     TagName tag = TagName.valueOf(tagName); [EOL]     if (enforcedAttributes.containsKey(tag)) { [EOL]         Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag); [EOL]         for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) { [EOL]             attrs.put(entry.getKey().toString(), entry.getValue().toString()); [EOL]         } [EOL]     } [EOL]     return attrs; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TagName(String value) { [LINE] TagName(String value) { [EOL]     super(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] super(value); [LINE] TagName(String value) { [EOL]     super(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] static TagName valueOf(String value) { [LINE] static TagName valueOf(String value) { [EOL]     return new TagName(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return new TagName(value); [LINE] static TagName valueOf(String value) { [EOL]     return new TagName(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] AttributeKey(String value) { [LINE] AttributeKey(String value) { [EOL]     super(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] super(value); [LINE] AttributeKey(String value) { [EOL]     super(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] static AttributeKey valueOf(String value) { [LINE] static AttributeKey valueOf(String value) { [EOL]     return new AttributeKey(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return new AttributeKey(value); [LINE] static AttributeKey valueOf(String value) { [EOL]     return new AttributeKey(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Protocol(String value) { [LINE] Protocol(String value) { [EOL]     super(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] super(value); [LINE] Protocol(String value) { [EOL]     super(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] static Protocol valueOf(String value) { [LINE] static Protocol valueOf(String value) { [EOL]     return new Protocol(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return new Protocol(value); [LINE] static Protocol valueOf(String value) { [EOL]     return new Protocol(value); [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TypedValue(String value) { [LINE] TypedValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] Validate.notNull(value); [LINE] TypedValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] this.value = value; [LINE] TypedValue(String value) { [EOL]     Validate.notNull(value); [EOL]     this.value = value; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] final int prime = 31; [LINE] @Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] int result = 1; [LINE] @Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] result = prime * result + ((value == null) ? 0 : value.hashCode()); [LINE] @Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return result; [LINE] @Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((value == null) ? 0 : value.hashCode()); [EOL]     return result; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (this == obj) return true; [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (obj == null) return false; [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (getClass() != obj.getClass()) return false; [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] TypedValue other = (TypedValue) obj; [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] if (value == null) { [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] } else if (!value.equals(other.value)) return false; [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return true; [LINE] @Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) [EOL]         return true; [EOL]     if (obj == null) [EOL]         return false; [EOL]     if (getClass() != obj.getClass()) [EOL]         return false; [EOL]     TypedValue other = (TypedValue) obj; [EOL]     if (value == null) { [EOL]         if (other.value != null) [EOL]             return false; [EOL]     } else if (!value.equals(other.value)) [EOL]         return false; [EOL]     return true; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] @Override [LINE] @Override [EOL] public String toString() { [EOL]     return value; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] return value; [LINE] @Override [EOL] public String toString() { [EOL]     return value; [EOL] } public Whitelist();  TagName(String value);  AttributeKey(String value);  AttributeValue(String value);  Protocol(String value);  TypedValue(String value); public static Whitelist none(); public static Whitelist simpleText(); public static Whitelist basic(); public static Whitelist basicWithImages(); public static Whitelist relaxed(); public Whitelist addTags(String... tags); public Whitelist addAttributes(String tag, String... keys); public Whitelist addEnforcedAttribute(String tag, String key, String value); public Whitelist addProtocols(String tag, String key, String... protocols);  boolean isSafeTag(String tag);  boolean isSafeAttribute(String tagName, Element el, Attribute attr); private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols);  Attributes getEnforcedAttributes(String tagName);  static TagName valueOf(String value);  static AttributeKey valueOf(String value);  static AttributeValue valueOf(String value);  static Protocol valueOf(String value); public int hashCode(); public boolean equals(Object obj); public String toString(); Set<TagName> tagNames; Map<TagName, Set<AttributeKey>> attributes; Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols
 [LINE] public String getWholeData() { [LINE] public String getWholeData() { [EOL]     return attributes.get(DATA_KEY); [EOL] } public DataNode(String data, String baseUri); public String nodeName(); public String getWholeData();  void outerHtml(StringBuilder accum); public String toString(); public static DataNode createFromEncoded(String encodedData, String baseUri); String DATA_KEY=Optional["data"]
 [LINE] return attributes.get(DATA_KEY); [LINE] public String getWholeData() { [EOL]     return attributes.get(DATA_KEY); [EOL] } public DataNode(String data, String baseUri); public String nodeName(); public String getWholeData();  void outerHtml(StringBuilder accum); public String toString(); public static DataNode createFromEncoded(String encodedData, String baseUri); String DATA_KEY=Optional["data"]
 [LINE] void outerHtml(StringBuilder accum) { [LINE] void outerHtml(StringBuilder accum) { [EOL]     accum.append(getWholeData()); [EOL] } public DataNode(String data, String baseUri); public String nodeName(); public String getWholeData();  void outerHtml(StringBuilder accum); public String toString(); public static DataNode createFromEncoded(String encodedData, String baseUri); String DATA_KEY=Optional["data"]
 [LINE] accum.append(getWholeData()); // data is not escaped in return from data nodes, so " in script, style is plain [LINE] void outerHtml(StringBuilder accum) { [EOL]     accum.append(getWholeData()); [EOL] } public DataNode(String data, String baseUri); public String nodeName(); public String getWholeData();  void outerHtml(StringBuilder accum); public String toString(); public static DataNode createFromEncoded(String encodedData, String baseUri); String DATA_KEY=Optional["data"]
 [LINE] public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [LINE] public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] Document dirty = parseBodyFragment(bodyHtml, baseUri); [LINE] public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] Cleaner cleaner = new Cleaner(whitelist); [LINE] public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] Document clean = cleaner.clean(dirty); [LINE] public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] return clean.body().html(); [LINE] public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) { [EOL]     Document dirty = parseBodyFragment(bodyHtml, baseUri); [EOL]     Cleaner cleaner = new Cleaner(whitelist); [EOL]     Document clean = cleaner.clean(dirty); [EOL]     return clean.body().html(); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] public static String clean(String bodyHtml, Whitelist whitelist) { [LINE] public static String clean(String bodyHtml, Whitelist whitelist) { [EOL]     return clean(bodyHtml, "", whitelist); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] return clean(bodyHtml, "", whitelist); [LINE] public static String clean(String bodyHtml, Whitelist whitelist) { [EOL]     return clean(bodyHtml, "", whitelist); [EOL] } private Jsoup(); public static Document parse(String html, String baseUri); public static Document parse(String html); public static Document parse(URL url, int timeoutMillis) throws IOException; public static Document parse(File in, String charsetName, String baseUri) throws IOException; public static Document parse(File in, String charsetName) throws IOException; public static Document parseBodyFragment(String bodyHtml, String baseUri); public static Document parseBodyFragment(String bodyHtml); public static String clean(String bodyHtml, String baseUri, Whitelist whitelist); public static String clean(String bodyHtml, Whitelist whitelist); public static boolean isValid(String bodyHtml, Whitelist whitelist)
 [LINE] private Tag(String tagName) { [LINE] private Tag(String tagName) { [EOL]     this.tagName = tagName.toLowerCase(); [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] this.tagName = tagName.toLowerCase(); [LINE] private Tag(String tagName) { [EOL]     this.tagName = tagName.toLowerCase(); [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] public String getName() { [LINE] public String getName() { [EOL]     return tagName; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return tagName; [LINE] public String getName() { [EOL]     return tagName; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] public static Tag valueOf(String tagName) { [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] Validate.notNull(tagName); [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] tagName = tagName.trim().toLowerCase(); [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] Validate.notEmpty(tagName); [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] synchronized (tags) { [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] Tag tag = tags.get(tagName); [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (tag == null) { [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] tag = new Tag(tagName); [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] tag.setAncestor(defaultAncestor.tagName); [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] tag.isBlock = false; [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] tag.canContainBlock = true; [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return tag; [LINE] public static Tag valueOf(String tagName) { [EOL]     Validate.notNull(tagName); [EOL]     tagName = tagName.trim().toLowerCase(); [EOL]     Validate.notEmpty(tagName); [EOL]     synchronized (tags) { [EOL]         Tag tag = tags.get(tagName); [EOL]         if (tag == null) { [EOL]             tag = new Tag(tagName); [EOL]             tag.setAncestor(defaultAncestor.tagName); [EOL]             tag.isBlock = false; [EOL]             tag.canContainBlock = true; [EOL]         } [EOL]         return tag; [EOL]     } [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] boolean canContain(Tag child) { [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] Validate.notNull(child); [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (child.isBlock && !this.canContainBlock) [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (!child.isBlock && !this.canContainInline) // not block == inline [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this.optionalClosing && this.equals(child)) [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this.empty || this.isData()) [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this.tagName.equals("head")) { [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this.tagName.equals("dt") && child.tagName.equals("dd")) [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this.tagName.equals("dd") && child.tagName.equals("dt")) [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return true; [LINE] boolean canContain(Tag child) { [EOL]     Validate.notNull(child); [EOL]     if (child.isBlock && !this.canContainBlock) [EOL]         return false; [EOL]     if (!child.isBlock && !this.canContainInline) [EOL]         return false; [EOL]     if (this.optionalClosing && this.equals(child)) [EOL]         return false; [EOL]     if (this.empty || this.isData()) [EOL]         return false; [EOL]     if (this.tagName.equals("head")) { [EOL]         if (child.tagName.equals("base") || child.tagName.equals("script") || child.tagName.equals("noscript") || child.tagName.equals("link") || child.tagName.equals("meta") || child.tagName.equals("title") || child.tagName.equals("style") || child.tagName.equals("object")) { [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (this.tagName.equals("dt") && child.tagName.equals("dd")) [EOL]         return false; [EOL]     if (this.tagName.equals("dd") && child.tagName.equals("dt")) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] public boolean isData() { [LINE] public boolean isData() { [EOL]     return !canContainInline && !isEmpty(); [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return !canContainInline && !isEmpty(); [LINE] public boolean isData() { [EOL]     return !canContainInline && !isEmpty(); [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] public boolean isEmpty() { [LINE] public boolean isEmpty() { [EOL]     return empty; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return empty; [LINE] public boolean isEmpty() { [EOL]     return empty; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] public boolean preserveWhitespace() { [LINE] public boolean preserveWhitespace() { [EOL]     return preserveWhitespace; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return preserveWhitespace; [LINE] public boolean preserveWhitespace() { [EOL]     return preserveWhitespace; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] Tag getImplicitParent() { [LINE] Tag getImplicitParent() { [EOL]     return (!ancestors.isEmpty()) ? ancestors.get(0) : null; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return (!ancestors.isEmpty()) ? ancestors.get(0) : null; [LINE] Tag getImplicitParent() { [EOL]     return (!ancestors.isEmpty()) ? ancestors.get(0) : null; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] boolean isValidParent(Tag child) { [LINE] boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (child.ancestors.isEmpty()) [LINE] boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] for (Tag tag : child.ancestors) { [LINE] boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this.equals(tag)) [LINE] boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return false; [LINE] boolean isValidParent(Tag child) { [EOL]     if (child.ancestors.isEmpty()) [EOL]         return true; [EOL]     for (Tag tag : child.ancestors) { [EOL]         if (this.equals(tag)) [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (this == o) return true; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (o == null || getClass() != o.getClass()) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] Tag tag = (Tag) o; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (canContainBlock != tag.canContainBlock) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (canContainInline != tag.canContainInline) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (empty != tag.empty) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (isBlock != tag.isBlock) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (optionalClosing != tag.optionalClosing) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (this == o) [EOL]         return true; [EOL]     if (o == null || getClass() != o.getClass()) [EOL]         return false; [EOL]     Tag tag = (Tag) o; [EOL]     if (canContainBlock != tag.canContainBlock) [EOL]         return false; [EOL]     if (canContainInline != tag.canContainInline) [EOL]         return false; [EOL]     if (empty != tag.empty) [EOL]         return false; [EOL]     if (isBlock != tag.isBlock) [EOL]         return false; [EOL]     if (optionalClosing != tag.optionalClosing) [EOL]         return false; [EOL]     if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) [EOL]         return false; [EOL]     return true; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] int result = tagName != null ? tagName.hashCode() : 0; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] result = 31 * result + (isBlock ? 1 : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] result = 31 * result + (canContainBlock ? 1 : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] result = 31 * result + (canContainInline ? 1 : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] result = 31 * result + (optionalClosing ? 1 : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] result = 31 * result + (empty ? 1 : 0); [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return result; [LINE] @Override [EOL] public int hashCode() { [EOL]     int result = tagName != null ? tagName.hashCode() : 0; [EOL]     result = 31 * result + (isBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainBlock ? 1 : 0); [EOL]     result = 31 * result + (canContainInline ? 1 : 0); [EOL]     result = 31 * result + (optionalClosing ? 1 : 0); [EOL]     result = 31 * result + (empty ? 1 : 0); [EOL]     return result; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] private Tag setAncestor(String... tagNames) { [LINE] private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] if (tagNames == null) { [LINE] private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] ancestors = new ArrayList<Tag>(tagNames.length); [LINE] private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] for (String name : tagNames) { [LINE] private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] ancestors.add(Tag.valueOf(name)); [LINE] private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
 [LINE] return this; [LINE] private Tag setAncestor(String... tagNames) { [EOL]     if (tagNames == null) { [EOL]         ancestors = Collections.emptyList(); [EOL]     } else { [EOL]         ancestors = new ArrayList<Tag>(tagNames.length); [EOL]         for (String name : tagNames) { [EOL]             ancestors.add(Tag.valueOf(name)); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } private Tag(String tagName); public String getName(); public static Tag valueOf(String tagName);  boolean canContain(Tag child); public boolean isBlock(); public boolean canContainBlock(); public boolean isInline(); public boolean isData(); public boolean isEmpty(); public boolean preserveWhitespace();  Tag getImplicitParent();  boolean isValidParent(Tag child); public boolean equals(Object o); public int hashCode(); public String toString(); private static Tag createBlock(String tagName); private static Tag createInline(String tagName); private static Tag register(Tag tag); private Tag setContainInlineOnly(); private Tag setContainDataOnly(); private Tag setEmpty(); private Tag setOptionalClosing(); private Tag setPreserveWhitespace(); private Tag setAncestor(String... tagNames); Map<String, Tag> tags=Optional[new HashMap<String, Tag>()]; Tag defaultAncestor; String tagName; boolean isBlock=Optional[true]; boolean canContainBlock=Optional[true]; boolean canContainInline=Optional[true]; boolean optionalClosing=Optional[false]; boolean empty=Optional[false]; boolean preserveWhitespace=Optional[false]; List<Tag> ancestors
