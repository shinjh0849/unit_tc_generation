 [LINE] @Override [LINE] @Override [EOL] public Version version() { [EOL]     return PackageVersion.VERSION; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return PackageVersion.VERSION; [LINE] @Override [EOL] public Version version() { [EOL]     return PackageVersion.VERSION; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] @Override [LINE] @Override [EOL] public JsonReadContext getParsingContext() { [EOL]     return _parsingContext; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return _parsingContext; [LINE] @Override [EOL] public JsonReadContext getParsingContext() { [EOL]     return _parsingContext; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] @Override [LINE] @Override [EOL] public JsonLocation getTokenLocation() { [EOL]     return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return new JsonLocation(_ioContext.getSourceReference(), [LINE] @Override [EOL] public JsonLocation getTokenLocation() { [EOL]     return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] @Override [LINE] @Override [EOL] public Object getEmbeddedObject() throws IOException, JsonParseException { [EOL]     return null; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return null; [LINE] @Override [EOL] public Object getEmbeddedObject() throws IOException, JsonParseException { [EOL]     return null; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] public long getTokenCharacterOffset() { return _tokenInputTotal; } [LINE] public long getTokenCharacterOffset() { [EOL]     return _tokenInputTotal; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] public int getTokenLineNr() { return _tokenInputRow; } [LINE] public int getTokenLineNr() { [EOL]     return _tokenInputRow; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] public int getTokenColumnNr() { [LINE] public int getTokenColumnNr() { [EOL]     int col = _tokenInputCol; [EOL]     return (col < 0) ? col : (col + 1); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] int col = _tokenInputCol; [LINE] public int getTokenColumnNr() { [EOL]     int col = _tokenInputCol; [EOL]     return (col < 0) ? col : (col + 1); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return (col < 0) ? col : (col + 1); [LINE] public int getTokenColumnNr() { [EOL]     int col = _tokenInputCol; [EOL]     return (col < 0) ? col : (col + 1); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] protected final void loadMoreGuaranteed() [LINE] protected final void loadMoreGuaranteed() throws IOException { [EOL]     if (!loadMore()) { [EOL]         _reportInvalidEOF(); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (!loadMore()) { [LINE] protected final void loadMoreGuaranteed() throws IOException { [EOL]     if (!loadMore()) { [EOL]         _reportInvalidEOF(); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] @Override [LINE] @Override [EOL] protected void _handleEOF() throws JsonParseException { [EOL]     if (!_parsingContext.inRoot()) { [EOL]         _reportInvalidEOF(": expected close marker for " + _parsingContext.getTypeDesc() + " (from " + _parsingContext.getStartLocation(_ioContext.getSourceReference()) + ")"); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (!_parsingContext.inRoot()) { [LINE] @Override [EOL] protected void _handleEOF() throws JsonParseException { [EOL]     if (!_parsingContext.inRoot()) { [EOL]         _reportInvalidEOF(": expected close marker for " + _parsingContext.getTypeDesc() + " (from " + _parsingContext.getStartLocation(_ioContext.getSourceReference()) + ")"); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _reportInvalidEOF(": expected close marker for "+_parsingContext.getTypeDesc()+" (from "+_parsingContext.getStartLocation(_ioContext.getSourceReference())+")"); [LINE] @Override [EOL] protected void _handleEOF() throws JsonParseException { [EOL]     if (!_parsingContext.inRoot()) { [EOL]         _reportInvalidEOF(": expected close marker for " + _parsingContext.getTypeDesc() + " (from " + _parsingContext.getStartLocation(_ioContext.getSourceReference()) + ")"); [EOL]     } [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] @Override [LINE] @Override [EOL] public Number getNumberValue() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return _numberInt; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return _numberLong; [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]             return _numberBigInt; [EOL]         } [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         _throwInternal(); [EOL]     } [EOL]     return _numberDouble; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (_numTypesValid == NR_UNKNOWN) { [LINE] @Override [EOL] public Number getNumberValue() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return _numberInt; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return _numberLong; [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]             return _numberBigInt; [EOL]         } [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         _throwInternal(); [EOL]     } [EOL]     return _numberDouble; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (_currToken == JsonToken.VALUE_NUMBER_INT) { [LINE] @Override [EOL] public Number getNumberValue() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return _numberInt; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return _numberLong; [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]             return _numberBigInt; [EOL]         } [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         _throwInternal(); [EOL]     } [EOL]     return _numberDouble; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if ((_numTypesValid & NR_INT) != 0) { [LINE] @Override [EOL] public Number getNumberValue() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return _numberInt; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return _numberLong; [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]             return _numberBigInt; [EOL]         } [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         _throwInternal(); [EOL]     } [EOL]     return _numberDouble; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return _numberInt; [LINE] @Override [EOL] public Number getNumberValue() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return _numberInt; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return _numberLong; [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]             return _numberBigInt; [EOL]         } [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         _throwInternal(); [EOL]     } [EOL]     return _numberDouble; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] long l = NumberInput.parseLong(buf, offset, len); [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (_numberNegative) { [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (len == 10) { [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (_numberNegative) { [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (l >= MIN_INT_L) { [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _numberInt = (int) l; [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _numTypesValid = NR_INT; [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return; [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (l <= MAX_INT_L) { [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _numberInt = (int) l; [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _numTypesValid = NR_INT; [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return; [LINE] protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] } else if ((_numTypesValid & NR_BIGINT) != 0) { [LINE] protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] } else if ((_numTypesValid & NR_DOUBLE) != 0) { [LINE] protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [LINE] protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _numberInt = (int) _numberDouble; [LINE] protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _numTypesValid |= NR_INT; [LINE] protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 [LINE] protected void convertNumberToLong() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberLong = (long) _numberInt; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigInt.longValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = (long) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigDecimal.longValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_LONG; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] reportOverflowLong(); [LINE] protected void convertNumberToLong() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberLong = (long) _numberInt; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigInt.longValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = (long) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigDecimal.longValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_LONG; [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] protected void reportInvalidNumber(String msg) [LINE] protected void reportInvalidNumber(String msg) throws JsonParseException { [EOL]     _reportError("Invalid numeric value: " + msg); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _reportError("Invalid numeric value: "+msg); [LINE] protected void reportInvalidNumber(String msg) throws JsonParseException { [EOL]     _reportError("Invalid numeric value: " + msg); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] protected void reportOverflowLong() [LINE] protected void reportOverflowLong() throws IOException, JsonParseException { [EOL]     _reportError("Numeric value (" + getText() + ") out of range of long (" + Long.MIN_VALUE + " - " + Long.MAX_VALUE + ")"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] _reportError("Numeric value ("+getText()+") out of range of long ("+Long.MIN_VALUE+" - "+Long.MAX_VALUE+")"); [LINE] protected void reportOverflowLong() throws IOException, JsonParseException { [EOL]     _reportError("Numeric value (" + getText() + ") out of range of long (" + Long.MIN_VALUE + " - " + Long.MAX_VALUE + ")"); [EOL] } protected ParserBase(IOContext ctxt, int features); public Version version(); public String getCurrentName() throws IOException, JsonParseException; public void overrideCurrentName(String name); public void close() throws IOException; public boolean isClosed(); public JsonReadContext getParsingContext(); public JsonLocation getTokenLocation(); public JsonLocation getCurrentLocation(); public boolean hasTextCharacters(); public Object getEmbeddedObject() throws IOException, JsonParseException; public long getTokenCharacterOffset(); public int getTokenLineNr(); public int getTokenColumnNr(); protected final void loadMoreGuaranteed() throws IOException; protected abstract boolean loadMore() throws IOException; protected abstract void _finishString() throws IOException, JsonParseException; protected abstract void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; protected void _handleEOF() throws JsonParseException; protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException; public ByteArrayBuilder _getByteArrayBuilder(); protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetInt(boolean negative, int intLen); protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen); protected final JsonToken resetAsNaN(String valueStr, double value); public Number getNumberValue() throws IOException, JsonParseException; public NumberType getNumberType() throws IOException, JsonParseException; public int getIntValue() throws IOException, JsonParseException; public long getLongValue() throws IOException, JsonParseException; public BigInteger getBigIntegerValue() throws IOException, JsonParseException; public float getFloatValue() throws IOException, JsonParseException; public double getDoubleValue() throws IOException, JsonParseException; public BigDecimal getDecimalValue() throws IOException, JsonParseException; protected void _parseNumericValue(int expType) throws IOException, JsonParseException; private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException; private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException; protected void convertNumberToInt() throws IOException, JsonParseException; protected void convertNumberToLong() throws IOException, JsonParseException; protected void convertNumberToBigInteger() throws IOException, JsonParseException; protected void convertNumberToDouble() throws IOException, JsonParseException; protected void convertNumberToBigDecimal() throws IOException, JsonParseException; protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException; protected void reportInvalidNumber(String msg) throws JsonParseException; protected void reportOverflowInt() throws IOException, JsonParseException; protected void reportOverflowLong() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException; protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException; protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException; IOContext _ioContext; boolean _closed; int _inputPtr=Optional[0]; int _inputEnd=Optional[0]; long _currInputProcessed=Optional[0L]; int _currInputRow=Optional[1]; int _currInputRowStart=Optional[0]; long _tokenInputTotal=Optional[0]; int _tokenInputRow=Optional[1]; int _tokenInputCol=Optional[0]; JsonReadContext _parsingContext; JsonToken _nextToken; TextBuffer _textBuffer; char[] _nameCopyBuffer=Optional[null]; boolean _nameCopied=Optional[false]; ByteArrayBuilder _byteArrayBuilder=Optional[null]; byte[] _binaryValue; int NR_UNKNOWN=Optional[0]; int NR_INT=Optional[0x0001]; int NR_LONG=Optional[0x0002]; int NR_BIGINT=Optional[0x0004]; int NR_DOUBLE=Optional[0x008]; int NR_BIGDECIMAL=Optional[0x0010]; BigInteger BI_MIN_INT=Optional[BigInteger.valueOf(Integer.MIN_VALUE)]; BigInteger BI_MAX_INT=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger BI_MIN_LONG=Optional[BigInteger.valueOf(Long.MIN_VALUE)]; BigInteger BI_MAX_LONG=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; BigDecimal BD_MIN_LONG=Optional[new BigDecimal(BI_MIN_LONG)]; BigDecimal BD_MAX_LONG=Optional[new BigDecimal(BI_MAX_LONG)]; BigDecimal BD_MIN_INT=Optional[new BigDecimal(BI_MIN_INT)]; BigDecimal BD_MAX_INT=Optional[new BigDecimal(BI_MAX_INT)]; long MIN_INT_L=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_L=Optional[(long) Integer.MAX_VALUE]; double MIN_LONG_D=Optional[(double) Long.MIN_VALUE]; double MAX_LONG_D=Optional[(double) Long.MAX_VALUE]; double MIN_INT_D=Optional[(double) Integer.MIN_VALUE]; double MAX_INT_D=Optional[(double) Integer.MAX_VALUE]; int INT_0=Optional['0']; int INT_1=Optional['1']; int INT_2=Optional['2']; int INT_3=Optional['3']; int INT_4=Optional['4']; int INT_5=Optional['5']; int INT_6=Optional['6']; int INT_7=Optional['7']; int INT_8=Optional['8']; int INT_9=Optional['9']; int INT_MINUS=Optional['-']; int INT_PLUS=Optional['+']; int INT_DECIMAL_POINT=Optional['.']; int INT_e=Optional['e']; int INT_E=Optional['E']; char CHAR_NULL=Optional['\0']; int _numTypesValid=Optional[NR_UNKNOWN]; int _numberInt; long _numberLong; double _numberDouble; BigInteger _numberBigInt; BigDecimal _numberBigDecimal; boolean _numberNegative; int _intLength; int _fractLength; int _expLength
 [LINE] return true; [LINE] @Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] } public Std(InputStream in, byte[] buffer); public Std(byte[] inputDocument); public Std(byte[] inputDocument, int start, int len);  boolean hasMoreBytes() throws IOException;  byte nextByte() throws IOException;  void reset(); public boolean hasMoreBytes() throws IOException; public byte nextByte() throws IOException; public void reset(); public DataFormatMatcher createMatcher(JsonFactory match, MatchStrength matchStrength)
 [LINE] buffer = balloc(type.size); [LINE] public final byte[] allocByteBuffer(ByteBufferType type) { [EOL]     int ix = type.ordinal(); [EOL]     byte[] buffer = _byteBuffers[ix]; [EOL]     if (buffer == null) { [EOL]         buffer = balloc(type.size); [EOL]     } else { [EOL]         _byteBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }  ByteBufferType(int size);  CharBufferType(int size); public BufferRecycler(); public final byte[] allocByteBuffer(ByteBufferType type); public final void releaseByteBuffer(ByteBufferType type, byte[] buffer); public final char[] allocCharBuffer(CharBufferType type); public final char[] allocCharBuffer(CharBufferType type, int minSize); public final void releaseCharBuffer(CharBufferType type, char[] buffer); private byte[] balloc(int size); private char[] calloc(int size); int DEFAULT_WRITE_CONCAT_BUFFER_LEN=Optional[2000]; byte[][] _byteBuffers=Optional[new byte[ByteBufferType.values().length][]]; char[][] _charBuffers=Optional[new char[CharBufferType.values().length][]]
 [LINE] private byte[] balloc(int size) [LINE] private byte[] balloc(int size) { [EOL]     return new byte[size]; [EOL] }  ByteBufferType(int size);  CharBufferType(int size); public BufferRecycler(); public final byte[] allocByteBuffer(ByteBufferType type); public final void releaseByteBuffer(ByteBufferType type, byte[] buffer); public final char[] allocCharBuffer(CharBufferType type); public final char[] allocCharBuffer(CharBufferType type, int minSize); public final void releaseCharBuffer(CharBufferType type, char[] buffer); private byte[] balloc(int size); private char[] calloc(int size); int DEFAULT_WRITE_CONCAT_BUFFER_LEN=Optional[2000]; byte[][] _byteBuffers=Optional[new byte[ByteBufferType.values().length][]]; char[][] _charBuffers=Optional[new char[CharBufferType.values().length][]]
 [LINE] return new byte[size]; [LINE] private byte[] balloc(int size) { [EOL]     return new byte[size]; [EOL] }  ByteBufferType(int size);  CharBufferType(int size); public BufferRecycler(); public final byte[] allocByteBuffer(ByteBufferType type); public final void releaseByteBuffer(ByteBufferType type, byte[] buffer); public final char[] allocCharBuffer(CharBufferType type); public final char[] allocCharBuffer(CharBufferType type, int minSize); public final void releaseCharBuffer(CharBufferType type, char[] buffer); private byte[] balloc(int size); private char[] calloc(int size); int DEFAULT_WRITE_CONCAT_BUFFER_LEN=Optional[2000]; byte[][] _byteBuffers=Optional[new byte[ByteBufferType.values().length][]]; char[][] _charBuffers=Optional[new char[CharBufferType.values().length][]]
 [LINE] public static Base64Variant valueOf(String name) throws IllegalArgumentException [LINE] public static Base64Variant valueOf(String name) throws IllegalArgumentException { [EOL]     if (MIME._name.equals(name)) { [EOL]         return MIME; [EOL]     } [EOL]     if (MIME_NO_LINEFEEDS._name.equals(name)) { [EOL]         return MIME_NO_LINEFEEDS; [EOL]     } [EOL]     if (PEM._name.equals(name)) { [EOL]         return PEM; [EOL]     } [EOL]     if (MODIFIED_FOR_URL._name.equals(name)) { [EOL]         return MODIFIED_FOR_URL; [EOL]     } [EOL]     if (name == null) { [EOL]         name = "<null>"; [EOL]     } else { [EOL]         name = "'" + name + "'"; [EOL]     } [EOL]     throw new IllegalArgumentException("No Base64Variant with name " + name); [EOL] } public static Base64Variant getDefaultVariant(); public static Base64Variant valueOf(String name) throws IllegalArgumentException; String STD_BASE64_ALPHABET=Optional["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"]; Base64Variant MIME; Base64Variant MIME_NO_LINEFEEDS; Base64Variant PEM=Optional[new Base64Variant(MIME, "PEM", true, '=', 64)]; Base64Variant MODIFIED_FOR_URL
 [LINE] if (MIME._name.equals(name)) { [LINE] public static Base64Variant valueOf(String name) throws IllegalArgumentException { [EOL]     if (MIME._name.equals(name)) { [EOL]         return MIME; [EOL]     } [EOL]     if (MIME_NO_LINEFEEDS._name.equals(name)) { [EOL]         return MIME_NO_LINEFEEDS; [EOL]     } [EOL]     if (PEM._name.equals(name)) { [EOL]         return PEM; [EOL]     } [EOL]     if (MODIFIED_FOR_URL._name.equals(name)) { [EOL]         return MODIFIED_FOR_URL; [EOL]     } [EOL]     if (name == null) { [EOL]         name = "<null>"; [EOL]     } else { [EOL]         name = "'" + name + "'"; [EOL]     } [EOL]     throw new IllegalArgumentException("No Base64Variant with name " + name); [EOL] } public static Base64Variant getDefaultVariant(); public static Base64Variant valueOf(String name) throws IllegalArgumentException; String STD_BASE64_ALPHABET=Optional["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"]; Base64Variant MIME; Base64Variant MIME_NO_LINEFEEDS; Base64Variant PEM=Optional[new Base64Variant(MIME, "PEM", true, '=', 64)]; Base64Variant MODIFIED_FOR_URL
 [LINE] if (MIME_NO_LINEFEEDS._name.equals(name)) { [LINE] public static Base64Variant valueOf(String name) throws IllegalArgumentException { [EOL]     if (MIME._name.equals(name)) { [EOL]         return MIME; [EOL]     } [EOL]     if (MIME_NO_LINEFEEDS._name.equals(name)) { [EOL]         return MIME_NO_LINEFEEDS; [EOL]     } [EOL]     if (PEM._name.equals(name)) { [EOL]         return PEM; [EOL]     } [EOL]     if (MODIFIED_FOR_URL._name.equals(name)) { [EOL]         return MODIFIED_FOR_URL; [EOL]     } [EOL]     if (name == null) { [EOL]         name = "<null>"; [EOL]     } else { [EOL]         name = "'" + name + "'"; [EOL]     } [EOL]     throw new IllegalArgumentException("No Base64Variant with name " + name); [EOL] } public static Base64Variant getDefaultVariant(); public static Base64Variant valueOf(String name) throws IllegalArgumentException; String STD_BASE64_ALPHABET=Optional["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"]; Base64Variant MIME; Base64Variant MIME_NO_LINEFEEDS; Base64Variant PEM=Optional[new Base64Variant(MIME, "PEM", true, '=', 64)]; Base64Variant MODIFIED_FOR_URL
 [LINE] if (PEM._name.equals(name)) { [LINE] public static Base64Variant valueOf(String name) throws IllegalArgumentException { [EOL]     if (MIME._name.equals(name)) { [EOL]         return MIME; [EOL]     } [EOL]     if (MIME_NO_LINEFEEDS._name.equals(name)) { [EOL]         return MIME_NO_LINEFEEDS; [EOL]     } [EOL]     if (PEM._name.equals(name)) { [EOL]         return PEM; [EOL]     } [EOL]     if (MODIFIED_FOR_URL._name.equals(name)) { [EOL]         return MODIFIED_FOR_URL; [EOL]     } [EOL]     if (name == null) { [EOL]         name = "<null>"; [EOL]     } else { [EOL]         name = "'" + name + "'"; [EOL]     } [EOL]     throw new IllegalArgumentException("No Base64Variant with name " + name); [EOL] } public static Base64Variant getDefaultVariant(); public static Base64Variant valueOf(String name) throws IllegalArgumentException; String STD_BASE64_ALPHABET=Optional["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"]; Base64Variant MIME; Base64Variant MIME_NO_LINEFEEDS; Base64Variant PEM=Optional[new Base64Variant(MIME, "PEM", true, '=', 64)]; Base64Variant MODIFIED_FOR_URL
 [LINE] return PEM; [LINE] public static Base64Variant valueOf(String name) throws IllegalArgumentException { [EOL]     if (MIME._name.equals(name)) { [EOL]         return MIME; [EOL]     } [EOL]     if (MIME_NO_LINEFEEDS._name.equals(name)) { [EOL]         return MIME_NO_LINEFEEDS; [EOL]     } [EOL]     if (PEM._name.equals(name)) { [EOL]         return PEM; [EOL]     } [EOL]     if (MODIFIED_FOR_URL._name.equals(name)) { [EOL]         return MODIFIED_FOR_URL; [EOL]     } [EOL]     if (name == null) { [EOL]         name = "<null>"; [EOL]     } else { [EOL]         name = "'" + name + "'"; [EOL]     } [EOL]     throw new IllegalArgumentException("No Base64Variant with name " + name); [EOL] } public static Base64Variant getDefaultVariant(); public static Base64Variant valueOf(String name) throws IllegalArgumentException; String STD_BASE64_ALPHABET=Optional["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"]; Base64Variant MIME; Base64Variant MIME_NO_LINEFEEDS; Base64Variant PEM=Optional[new Base64Variant(MIME, "PEM", true, '=', 64)]; Base64Variant MODIFIED_FOR_URL
 [LINE] if (value < 10) { [LINE] public static int outputInt(int value, char[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (char) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }]
 [LINE] offset = outputLeadingTriplet(value, buffer, offset); [LINE] public static int outputInt(int value, char[] buffer, int offset) { [EOL]     if (value < 0) { [EOL]         if (value == Integer.MIN_VALUE) { [EOL]             return outputLong((long) value, buffer, offset); [EOL]         } [EOL]         buffer[offset++] = '-'; [EOL]         value = -value; [EOL]     } [EOL]     if (value < MILLION) { [EOL]         if (value < 1000) { [EOL]             if (value < 10) { [EOL]                 buffer[offset++] = (char) ('0' + value); [EOL]             } else { [EOL]                 offset = outputLeadingTriplet(value, buffer, offset); [EOL]             } [EOL]         } else { [EOL]             int thousands = value / 1000; [EOL]             value -= (thousands * 1000); [EOL]             offset = outputLeadingTriplet(thousands, buffer, offset); [EOL]             offset = outputFullTriplet(value, buffer, offset); [EOL]         } [EOL]         return offset; [EOL]     } [EOL]     boolean hasBillions = (value >= BILLION); [EOL]     if (hasBillions) { [EOL]         value -= BILLION; [EOL]         if (value >= BILLION) { [EOL]             value -= BILLION; [EOL]             buffer[offset++] = '2'; [EOL]         } else { [EOL]             buffer[offset++] = '1'; [EOL]         } [EOL]     } [EOL]     int newValue = value / 1000; [EOL]     int ones = (value - (newValue * 1000)); [EOL]     value = newValue; [EOL]     newValue /= 1000; [EOL]     int thousands = (value - (newValue * 1000)); [EOL]     if (hasBillions) { [EOL]         offset = outputFullTriplet(newValue, buffer, offset); [EOL]     } else { [EOL]         offset = outputLeadingTriplet(newValue, buffer, offset); [EOL]     } [EOL]     offset = outputFullTriplet(thousands, buffer, offset); [EOL]     offset = outputFullTriplet(ones, buffer, offset); [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }]
 [LINE] buffer[offset++] = c; [LINE] private static int outputLeadingTriplet(int triplet, char[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     char c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = c; [EOL]     } [EOL]     c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = c; [EOL]     } [EOL]     buffer[offset++] = LEADING_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }]
 [LINE] buffer[offset++] = c; [LINE] private static int outputLeadingTriplet(int triplet, char[] buffer, int offset) { [EOL]     int digitOffset = (triplet << 2); [EOL]     char c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = c; [EOL]     } [EOL]     c = LEADING_TRIPLETS[digitOffset++]; [EOL]     if (c != NULL_CHAR) { [EOL]         buffer[offset++] = c; [EOL]     } [EOL]     buffer[offset++] = LEADING_TRIPLETS[digitOffset]; [EOL]     return offset; [EOL] } public static int outputInt(int value, char[] buffer, int offset); public static int outputInt(int value, byte[] buffer, int offset); public static int outputLong(long value, char[] buffer, int offset); public static int outputLong(long value, byte[] buffer, int offset); public static String toString(int value); public static String toString(long value); public static String toString(double value); private static int outputLeadingTriplet(int triplet, char[] buffer, int offset); private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset); private static int outputFullTriplet(int triplet, char[] buffer, int offset); private static int outputFullTriplet(int triplet, byte[] buffer, int offset); private static int calcLongStrLength(long posValue); char NULL_CHAR=Optional[(char) 0]; int MILLION=Optional[1000000]; int BILLION=Optional[1000000000]; long TEN_BILLION_L=Optional[10000000000L]; long THOUSAND_L=Optional[1000L]; long MIN_INT_AS_LONG=Optional[(long) Integer.MIN_VALUE]; long MAX_INT_AS_LONG=Optional[(long) Integer.MAX_VALUE]; String SMALLEST_LONG=Optional[String.valueOf(Long.MIN_VALUE)]; char[] LEADING_TRIPLETS=Optional[new char[4000]]; char[] FULL_TRIPLETS=Optional[new char[4000]]; byte[] FULL_TRIPLETS_B=Optional[new byte[4000]]; String[] sSmallIntStrs=Optional[new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" }]; String[] sSmallIntStrs2=Optional[new String[] { "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10" }]
 [LINE] _pastBlocks.clear(); [LINE] public void reset() { [EOL]     _pastLen = 0; [EOL]     _currBlockPtr = 0; [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         _pastBlocks.clear(); [EOL]     } [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] int len = block.length; [LINE] public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] System.arraycopy(block, 0, result, offset, len); [LINE] public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] offset += len; [LINE] public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] reset(); [LINE] public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] public byte[] finishCurrentSegment() { [LINE] public byte[] finishCurrentSegment() { [EOL]     _allocMore(); [EOL]     return _currBlock; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] _allocMore(); [LINE] public byte[] finishCurrentSegment() { [EOL]     _allocMore(); [EOL]     return _currBlock; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] return _currBlock; [LINE] public byte[] finishCurrentSegment() { [EOL]     _allocMore(); [EOL]     return _currBlock; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] public byte[] getCurrentSegment() { [LINE] public byte[] getCurrentSegment() { [EOL]     return _currBlock; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] return _currBlock; [LINE] public byte[] getCurrentSegment() { [EOL]     return _currBlock; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] public void setCurrentSegmentLength(int len) { [LINE] public void setCurrentSegmentLength(int len) { [EOL]     _currBlockPtr = len; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] _currBlockPtr = len; [LINE] public void setCurrentSegmentLength(int len) { [EOL]     _currBlockPtr = len; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] public int getCurrentSegmentLength() { [LINE] public int getCurrentSegmentLength() { [EOL]     return _currBlockPtr; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] return _currBlockPtr; [LINE] public int getCurrentSegmentLength() { [EOL]     return _currBlockPtr; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] private void _allocMore() [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] _pastLen += _currBlock.length; [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] if (newSize > MAX_BLOCK_SIZE) { [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] _pastBlocks.add(_currBlock); [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] _currBlock = new byte[newSize]; [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] _currBlockPtr = 0; [LINE] private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } public ByteArrayBuilder(); public ByteArrayBuilder(BufferRecycler br); public ByteArrayBuilder(int firstBlockSize); public ByteArrayBuilder(BufferRecycler br, int firstBlockSize); public void reset(); public void release(); public void append(int i); public void appendTwoBytes(int b16); public void appendThreeBytes(int b24); public byte[] toByteArray(); public byte[] resetAndGetFirstSegment(); public byte[] finishCurrentSegment(); public byte[] completeAndCoalesce(int lastBlockLength); public byte[] getCurrentSegment(); public void setCurrentSegmentLength(int len); public int getCurrentSegmentLength(); public void write(byte[] b); public void write(byte[] b, int off, int len); public void write(int b); public void close(); public void flush(); private void _allocMore(); byte[] NO_BYTES=Optional[new byte[0]]; int INITIAL_BLOCK_SIZE=Optional[500]; int MAX_BLOCK_SIZE=Optional[(1 << 18)]; int DEFAULT_BLOCK_ARRAY_SIZE=Optional[40]; BufferRecycler _bufferRecycler; LinkedList<byte[]> _pastBlocks=Optional[new LinkedList<byte[]>()]; int _pastLen; byte[] _currBlock; int _currBlockPtr
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (++offset < len) { [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (digitChars[offset] - '0'); [LINE] public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] public static int parseInt(String str) [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] char c = str.charAt(0); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] int length = str.length(); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] boolean negative = (c == '-'); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] int offset = 1; [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (negative) { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (length == 1 || length > 10) { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] return Integer.parseInt(str); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] c = str.charAt(offset++); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (length > 9) { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] return Integer.parseInt(str); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (c > '9' || c < '0') { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] int num = c - '0'; [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (offset < length) { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] c = str.charAt(offset++); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (c > '9' || c < '0') { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (c - '0'); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (offset < length) { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] c = str.charAt(offset++); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (c > '9' || c < '0') { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (c - '0'); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (offset < length) { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] do { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] c = str.charAt(offset++); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (c > '9' || c < '0') { [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] num = (num * 10) + (c - '0'); [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] return negative ? -num : num; [LINE] public static int parseInt(String str) { [EOL]     char c = str.charAt(0); [EOL]     int length = str.length(); [EOL]     boolean negative = (c == '-'); [EOL]     int offset = 1; [EOL]     if (negative) { [EOL]         if (length == 1 || length > 10) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         c = str.charAt(offset++); [EOL]     } else { [EOL]         if (length > 9) { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]     } [EOL]     if (c > '9' || c < '0') { [EOL]         return Integer.parseInt(str); [EOL]     } [EOL]     int num = c - '0'; [EOL]     if (offset < length) { [EOL]         c = str.charAt(offset++); [EOL]         if (c > '9' || c < '0') { [EOL]             return Integer.parseInt(str); [EOL]         } [EOL]         num = (num * 10) + (c - '0'); [EOL]         if (offset < length) { [EOL]             c = str.charAt(offset++); [EOL]             if (c > '9' || c < '0') { [EOL]                 return Integer.parseInt(str); [EOL]             } [EOL]             num = (num * 10) + (c - '0'); [EOL]             if (offset < length) { [EOL]                 do { [EOL]                     c = str.charAt(offset++); [EOL]                     if (c > '9' || c < '0') { [EOL]                         return Integer.parseInt(str); [EOL]                     } [EOL]                     num = (num * 10) + (c - '0'); [EOL]                 } while (offset < length); [EOL]             } [EOL]         } [EOL]     } [EOL]     return negative ? -num : num; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] public static long parseLong(char[] digitChars, int offset, int len) [LINE] public static long parseLong(char[] digitChars, int offset, int len) { [EOL]     int len1 = len - 9; [EOL]     long val = parseInt(digitChars, offset, len1) * L_BILLION; [EOL]     return val + (long) parseInt(digitChars, offset + len1, 9); [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] int len1 = len-9; [LINE] public static long parseLong(char[] digitChars, int offset, int len) { [EOL]     int len1 = len - 9; [EOL]     long val = parseInt(digitChars, offset, len1) * L_BILLION; [EOL]     return val + (long) parseInt(digitChars, offset + len1, 9); [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] long val = parseInt(digitChars, offset, len1) * L_BILLION; [LINE] public static long parseLong(char[] digitChars, int offset, int len) { [EOL]     int len1 = len - 9; [EOL]     long val = parseInt(digitChars, offset, len1) * L_BILLION; [EOL]     return val + (long) parseInt(digitChars, offset + len1, 9); [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] return val + (long) parseInt(digitChars, offset+len1, 9); [LINE] public static long parseLong(char[] digitChars, int offset, int len) { [EOL]     int len1 = len - 9; [EOL]     long val = parseInt(digitChars, offset, len1) * L_BILLION; [EOL]     return val + (long) parseInt(digitChars, offset + len1, 9); [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] for (int i = 0; i < cmpLen; ++i) { [LINE] public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] int diff = digitChars[offset+i] - cmpStr.charAt(i); [LINE] public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] if (diff != 0) { [LINE] public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] return (diff < 0); [LINE] public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public static int parseInt(char[] digitChars, int offset, int len); public static int parseInt(String str); public static long parseLong(char[] digitChars, int offset, int len); public static long parseLong(String str); public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative); public static boolean inLongRange(String numberStr, boolean negative); public static int parseAsInt(String input, int defaultValue); public static long parseAsLong(String input, long defaultValue); public static double parseAsDouble(String input, double defaultValue); public static double parseDouble(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException; public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len) throws NumberFormatException; private static NumberFormatException _badBigDecimal(String str); String NASTY_SMALL_DOUBLE=Optional["2.2250738585072012e-308"]; long L_BILLION=Optional[1000000000]; String MIN_LONG_STR_NO_SIGN=Optional[String.valueOf(Long.MIN_VALUE).substring(1)]; String MAX_LONG_STR=Optional[String.valueOf(Long.MAX_VALUE)]
 [LINE] @Override [LINE] @Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return _objectCodec; [LINE] @Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] @Override [LINE] @Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int count = _inputEnd - _inputPtr; [LINE] @Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (count < 1) { [LINE] @Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int origPtr = _inputPtr; [LINE] @Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] out.write(_inputBuffer, origPtr, count); [LINE] @Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return count; [LINE] @Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return null; [LINE] protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return null; [LINE] @Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return 0; [LINE] @Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return 0; [LINE] @Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _tokenIncomplete = true; [LINE] private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return (_currToken = JsonToken.VALUE_STRING); [LINE] private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_RBRACKET: [LINE] private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _reportUnexpectedChar(i, "expected a value"); [LINE] private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_8: [LINE] private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] reportInvalidNumber("Leading zeroes not allowed"); [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ++_inputPtr; // Leading zero to be skipped [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (ch == INT_0) { [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] while (_inputPtr < _inputEnd || loadMore()) { [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch = _inputBuffer[_inputPtr] & 0xFF; [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ++_inputPtr; // skip previous zeroes [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (ch != INT_0) { // followed by other number; return [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return ch; [LINE] private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (i == INT_QUOTE) { // 8 bytes [LINE] protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 1); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 1); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 2); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 2); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 3); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 3); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 4); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 4); [EOL]     } [EOL]     _quadBuffer[0] = _quad1; [EOL]     _quadBuffer[1] = q2; [EOL]     return parseLongFieldName(i); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return findName(_quad1, q2, 4); [LINE] protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 1); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 1); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 2); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 2); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 3); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 3); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 4); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 4); [EOL]     } [EOL]     _quadBuffer[0] = _quad1; [EOL]     _quadBuffer[1] = q2; [EOL]     return parseLongFieldName(i); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] q = (q << 8) | i; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] i = _inputBuffer[_inputPtr++] & 0xFF; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (codes[i] != 0) { [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (i == INT_QUOTE) { [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return findName(_quadBuffer, qlen, q, 2); [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] q = (q << 8) | i; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] i = _inputBuffer[_inputPtr++] & 0xFF; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (codes[i] != 0) { [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (i == INT_QUOTE) { [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return findName(_quadBuffer, qlen, q, 3); [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] q = (q << 8) | i; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] i = _inputBuffer[_inputPtr++] & 0xFF; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (codes[i] != 0) { [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (qlen >= _quadBuffer.length) { [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _quadBuffer = growArrayBy(_quadBuffer, qlen); [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _quadBuffer[qlen++] = q; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] q = i; [LINE] protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int needed; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF) [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch &= 0x1F; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] needed = 1; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF) [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch &= 0x0F; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] needed = 2; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((ix + needed) > byteLen) { [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int ch2 = quads[ix >> 2]; // current quad, need to shift+mask [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] byteIx = (ix & 3); [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch2 = (ch2 >> ((3 - byteIx) << 3)); [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ++ix; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((ch2 & 0xC0) != 0x080) { [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch = (ch << 6) | (ch2 & 0x3F); [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (needed > 1) { [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch2 = quads[ix >> 2]; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] byteIx = (ix & 3); [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch2 = (ch2 >> ((3 - byteIx) << 3)); [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ++ix; [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((ch2 & 0xC0) != 0x080) { [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ch = (ch << 6) | (ch2 & 0x3F); [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (needed > 2) { // 4 bytes? (need surrogates on output) [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (needed > 2) { // surrogate pair? once again, let's output one here, one later on [LINE] private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] loadMoreGuaranteed(); [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ptr = _inputPtr; [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] outBuf[outPtr++] = (char) c; [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _inputPtr = ptr; [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case 1: // backslash [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c = _decodeEscaped(); [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case 2: // 2-byte UTF [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c = _decodeUtf8_2(c); [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case 3: // 3-byte UTF [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((_inputEnd - _inputPtr) >= 2) { [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c = _decodeUtf8_3fast(c); [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c = _decodeUtf8_3(c); [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (Character.isJavaIdentifierStart(c)) { [LINE] protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [LINE] protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _skipComment(); [LINE] private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] } else if (i == INT_CR) { [LINE] private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _skipCR(); [LINE] private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] private void _skipComment() [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (!isEnabled(Feature.ALLOW_COMMENTS)) { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd && !loadMore()) { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int c = _inputBuffer[_inputPtr++] & 0xFF; [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (c == INT_SLASH) { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _skipCppComment(); [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] } else if (c == INT_ASTERISK) { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _skipCComment(); [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] private void _skipCComment() [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] final int[] codes = CharTypes.getInputCodeComment(); [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] main_loop: [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] while ((_inputPtr < _inputEnd) || loadMore()) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int code = codes[i]; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (code != 0) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] switch (code) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_ASTERISK: [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd && !loadMore()) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputBuffer[_inputPtr] == INT_SLASH) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ++_inputPtr; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_LF: [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _skipLF(); [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] private void _skipCppComment() [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] final int[] codes = CharTypes.getInputCodeComment(); [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] while ((_inputPtr < _inputEnd) || loadMore()) { [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int code = codes[i]; [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (code != 0) { [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] switch (code) { [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_LF: [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _skipLF(); [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return; [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] @Override [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (!loadMore()) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int c = (int) _inputBuffer[_inputPtr++]; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] switch ((int) c) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_b: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return '\b'; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_t: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return '\t'; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_n: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return '\n'; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_f: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return '\f'; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_r: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return '\r'; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_QUOTE: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_BACKSLASH: [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return (char) c; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] case INT_u: // and finally hex-escaped [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int value = 0; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] for (int i = 0; i < 4; ++i) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (!loadMore()) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int ch = (int) _inputBuffer[_inputPtr++]; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int digit = CharTypes.charToHex(ch); [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (digit < 0) { [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] value = (value << 4) | digit; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return (char) value; [LINE] @Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] private int _decodeUtf8_2(int c) [LINE] private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd) { [LINE] private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] loadMoreGuaranteed(); [LINE] private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int d = (int) _inputBuffer[_inputPtr++]; [LINE] private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((d & 0xC0) != 0x080) { [LINE] private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return ((c & 0x1F) << 6) | (d & 0x3F); [LINE] private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] private int _decodeUtf8_3(int c1) [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd) { [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] loadMoreGuaranteed(); [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c1 &= 0x0F; [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int d = (int) _inputBuffer[_inputPtr++]; [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((d & 0xC0) != 0x080) { [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int c = (c1 << 6) | (d & 0x3F); [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr >= _inputEnd) { [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] loadMoreGuaranteed(); [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] d = (int) _inputBuffer[_inputPtr++]; [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((d & 0xC0) != 0x080) { [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c = (c << 6) | (d & 0x3F); [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return c; [LINE] private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] private int _decodeUtf8_3fast(int c1) [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c1 &= 0x0F; [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int d = (int) _inputBuffer[_inputPtr++]; [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((d & 0xC0) != 0x080) { [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] int c = (c1 << 6) | (d & 0x3F); [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] d = (int) _inputBuffer[_inputPtr++]; [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if ((d & 0xC0) != 0x080) { [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] c = (c << 6) | (d & 0x3F); [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return c; [LINE] private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] protected void _skipCR() throws IOException [LINE] protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputPtr < _inputEnd || loadMore()) { [LINE] protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (_inputBuffer[_inputPtr] == BYTE_LF) { [LINE] protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] ++_currInputRow; [LINE] protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] _currInputRowStart = _inputPtr; [LINE] protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] public static int[] growArrayBy(int[] arr, int more) [LINE] public static int[] growArrayBy(int[] arr, int more) { [EOL]     if (arr == null) { [EOL]         return new int[more]; [EOL]     } [EOL]     return Arrays.copyOf(arr, arr.length + more); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] if (arr == null) { [LINE] public static int[] growArrayBy(int[] arr, int more) { [EOL]     if (arr == null) { [EOL]         return new int[more]; [EOL]     } [EOL]     return Arrays.copyOf(arr, arr.length + more); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] return Arrays.copyOf(arr, arr.length + more); [LINE] public static int[] growArrayBy(int[] arr, int more) { [EOL]     if (arr == null) { [EOL]         return new int[more]; [EOL]     } [EOL]     return Arrays.copyOf(arr, arr.length + more); [EOL] } public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(OutputStream out) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException; private JsonToken _nextAfterName(); public void close() throws IOException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; private void _isNextTokenNameYes() throws IOException, JsonParseException; private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; protected JsonToken parseNumberText(int c) throws IOException, JsonParseException; private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException; private int _verifyNoLeadingZeroes() throws IOException, JsonParseException; private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException; protected Name _parseFieldName(int i) throws IOException, JsonParseException; protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException; protected Name parseLongFieldName(int q) throws IOException, JsonParseException; protected Name slowParseFieldName() throws IOException, JsonParseException; private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException; private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException; protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException; protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException; protected Name _parseApostropheFieldName() throws IOException, JsonParseException; private Name findName(int q1, int lastQuadBytes) throws JsonParseException; private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException; private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException; private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException; protected void _finishString() throws IOException, JsonParseException; private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private int _skipColon() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException; private int _decodeUtf8_2(int c) throws IOException, JsonParseException; private int _decodeUtf8_3(int c1) throws IOException, JsonParseException; private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException; private int _decodeUtf8_4(int c) throws IOException, JsonParseException; private void _skipUtf8_2(int c) throws IOException, JsonParseException; private void _skipUtf8_3(int c) throws IOException, JsonParseException; private void _skipUtf8_4(int c) throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int nextByte() throws IOException, JsonParseException; protected void _reportInvalidChar(int c) throws JsonParseException; protected void _reportInvalidInitial(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask) throws JsonParseException; protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException; public static int[] growArrayBy(int[] arr, int more); protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; byte BYTE_LF=Optional[(byte) '\n']; int[] sInputCodesUtf8=Optional[CharTypes.getInputCodeUtf8()]; int[] sInputCodesLatin1=Optional[CharTypes.getInputCodeLatin1()]; ObjectCodec _objectCodec; BytesToNameCanonicalizer _symbols; int[] _quadBuffer=Optional[new int[16]]; boolean _tokenIncomplete=Optional[false]; int _quad1; InputStream _inputStream; byte[] _inputBuffer; boolean _bufferRecyclable
 [LINE] public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource) [LINE] public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource) { [EOL]     _bufferRecycler = br; [EOL]     _sourceRef = sourceRef; [EOL]     _managedResource = managedResource; [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _bufferRecycler = br; [LINE] public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource) { [EOL]     _bufferRecycler = br; [EOL]     _sourceRef = sourceRef; [EOL]     _managedResource = managedResource; [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _sourceRef = sourceRef; [LINE] public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource) { [EOL]     _bufferRecycler = br; [EOL]     _sourceRef = sourceRef; [EOL]     _managedResource = managedResource; [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _managedResource = managedResource; [LINE] public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource) { [EOL]     _bufferRecycler = br; [EOL]     _sourceRef = sourceRef; [EOL]     _managedResource = managedResource; [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public byte[] allocReadIOBuffer() [LINE] public byte[] allocReadIOBuffer() { [EOL]     _verifyAlloc(_readIOBuffer); [EOL]     return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyAlloc(_readIOBuffer); [LINE] public byte[] allocReadIOBuffer() { [EOL]     _verifyAlloc(_readIOBuffer); [EOL]     return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER)); [LINE] public byte[] allocReadIOBuffer() { [EOL]     _verifyAlloc(_readIOBuffer); [EOL]     return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public byte[] allocWriteEncodingBuffer() [LINE] public byte[] allocWriteEncodingBuffer() { [EOL]     _verifyAlloc(_writeEncodingBuffer); [EOL]     return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyAlloc(_writeEncodingBuffer); [LINE] public byte[] allocWriteEncodingBuffer() { [EOL]     _verifyAlloc(_writeEncodingBuffer); [EOL]     return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER)); [LINE] public byte[] allocWriteEncodingBuffer() { [EOL]     _verifyAlloc(_writeEncodingBuffer); [EOL]     return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public char[] allocTokenBuffer() [LINE] public char[] allocTokenBuffer() { [EOL]     _verifyAlloc(_tokenCBuffer); [EOL]     return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyAlloc(_tokenCBuffer); [LINE] public char[] allocTokenBuffer() { [EOL]     _verifyAlloc(_tokenCBuffer); [EOL]     return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER)); [LINE] public char[] allocTokenBuffer() { [EOL]     _verifyAlloc(_tokenCBuffer); [EOL]     return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public char[] allocConcatBuffer() [LINE] public char[] allocConcatBuffer() { [EOL]     _verifyAlloc(_concatCBuffer); [EOL]     return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyAlloc(_concatCBuffer); [LINE] public char[] allocConcatBuffer() { [EOL]     _verifyAlloc(_concatCBuffer); [EOL]     return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER)); [LINE] public char[] allocConcatBuffer() { [EOL]     _verifyAlloc(_concatCBuffer); [EOL]     return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public char[] allocNameCopyBuffer(int minSize) [LINE] public char[] allocNameCopyBuffer(int minSize) { [EOL]     _verifyAlloc(_nameCopyBuffer); [EOL]     return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyAlloc(_nameCopyBuffer); [LINE] public char[] allocNameCopyBuffer(int minSize) { [EOL]     _verifyAlloc(_nameCopyBuffer); [EOL]     return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize)); [LINE] public char[] allocNameCopyBuffer(int minSize) { [EOL]     _verifyAlloc(_nameCopyBuffer); [EOL]     return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize)); [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public void releaseReadIOBuffer(byte[] buf) [LINE] public void releaseReadIOBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _readIOBuffer); [EOL]         _readIOBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (buf != null) { [LINE] public void releaseReadIOBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _readIOBuffer); [EOL]         _readIOBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyRelease(buf, _readIOBuffer); [LINE] public void releaseReadIOBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _readIOBuffer); [EOL]         _readIOBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public void releaseWriteEncodingBuffer(byte[] buf) [LINE] public void releaseWriteEncodingBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _writeEncodingBuffer); [EOL]         _writeEncodingBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (buf != null) { [LINE] public void releaseWriteEncodingBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _writeEncodingBuffer); [EOL]         _writeEncodingBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyRelease(buf, _writeEncodingBuffer); [LINE] public void releaseWriteEncodingBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _writeEncodingBuffer); [EOL]         _writeEncodingBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public void releaseTokenBuffer(char[] buf) [LINE] public void releaseTokenBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _tokenCBuffer); [EOL]         _tokenCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (buf != null) { [LINE] public void releaseTokenBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _tokenCBuffer); [EOL]         _tokenCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyRelease(buf, _tokenCBuffer); [LINE] public void releaseTokenBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _tokenCBuffer); [EOL]         _tokenCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public void releaseConcatBuffer(char[] buf) [LINE] public void releaseConcatBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _concatCBuffer); [EOL]         _concatCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (buf != null) { [LINE] public void releaseConcatBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _concatCBuffer); [EOL]         _concatCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyRelease(buf, _concatCBuffer); [LINE] public void releaseConcatBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _concatCBuffer); [EOL]         _concatCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] public void releaseNameCopyBuffer(char[] buf) [LINE] public void releaseNameCopyBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _nameCopyBuffer); [EOL]         _nameCopyBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (buf != null) { [LINE] public void releaseNameCopyBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _nameCopyBuffer); [EOL]         _nameCopyBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] _verifyRelease(buf, _nameCopyBuffer); [LINE] public void releaseNameCopyBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _nameCopyBuffer); [EOL]         _nameCopyBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] private final void _verifyAlloc(Object buffer) [LINE] private final void _verifyAlloc(Object buffer) { [EOL]     if (buffer != null) { [EOL]         throw new IllegalStateException("Trying to call same allocXxx() method second time"); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (buffer != null) { [LINE] private final void _verifyAlloc(Object buffer) { [EOL]     if (buffer != null) { [EOL]         throw new IllegalStateException("Trying to call same allocXxx() method second time"); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] throw new IllegalStateException("Trying to call same allocXxx() method second time"); [LINE] private final void _verifyAlloc(Object buffer) { [EOL]     if (buffer != null) { [EOL]         throw new IllegalStateException("Trying to call same allocXxx() method second time"); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] private final void _verifyRelease(Object toRelease, Object src) [LINE] private final void _verifyRelease(Object toRelease, Object src) { [EOL]     if (toRelease != src) { [EOL]         throw new IllegalArgumentException("Trying to release buffer not owned by the context"); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] if (toRelease != src) { [LINE] private final void _verifyRelease(Object toRelease, Object src) { [EOL]     if (toRelease != src) { [EOL]         throw new IllegalArgumentException("Trying to release buffer not owned by the context"); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] throw new IllegalArgumentException("Trying to release buffer not owned by the context"); [LINE] private final void _verifyRelease(Object toRelease, Object src) { [EOL]     if (toRelease != src) { [EOL]         throw new IllegalArgumentException("Trying to release buffer not owned by the context"); [EOL]     } [EOL] } public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource); public void setEncoding(JsonEncoding enc); public Object getSourceReference(); public JsonEncoding getEncoding(); public boolean isResourceManaged(); public TextBuffer constructTextBuffer(); public byte[] allocReadIOBuffer(); public byte[] allocWriteEncodingBuffer(); public byte[] allocBase64Buffer(); public char[] allocTokenBuffer(); public char[] allocConcatBuffer(); public char[] allocNameCopyBuffer(int minSize); public void releaseReadIOBuffer(byte[] buf); public void releaseWriteEncodingBuffer(byte[] buf); public void releaseBase64Buffer(byte[] buf); public void releaseTokenBuffer(char[] buf); public void releaseConcatBuffer(char[] buf); public void releaseNameCopyBuffer(char[] buf); private final void _verifyAlloc(Object buffer); private final void _verifyRelease(Object toRelease, Object src); Object _sourceRef; JsonEncoding _encoding; boolean _managedResource; BufferRecycler _bufferRecycler; byte[] _readIOBuffer=Optional[null]; byte[] _writeEncodingBuffer=Optional[null]; byte[] _base64Buffer=Optional[null]; char[] _tokenCBuffer=Optional[null]; char[] _concatCBuffer=Optional[null]; char[] _nameCopyBuffer=Optional[null]
 [LINE] break; [LINE] private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] } public DataFormatDetector(JsonFactory... detectors); public DataFormatDetector(Collection<JsonFactory> detectors); private DataFormatDetector(JsonFactory[] detectors, MatchStrength optMatch, MatchStrength minMatch, int maxInputLookahead); public DataFormatDetector withOptimalMatch(MatchStrength optMatch); public DataFormatDetector withMinimalMatch(MatchStrength minMatch); public DataFormatDetector withMaxInputLookahead(int lookaheadBytes); public DataFormatMatcher findFormat(InputStream in) throws IOException; public DataFormatMatcher findFormat(byte[] fullInputData) throws IOException; public DataFormatMatcher findFormat(byte[] fullInputData, int offset, int len) throws IOException; public String toString(); private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException; int DEFAULT_MAX_INPUT_LOOKAHEAD=Optional[64]; JsonFactory[] _detectors; MatchStrength _optimalMatch; MatchStrength _minimalMatch; int _maxInputLookahead
 [LINE] @SuppressWarnings("unchecked") [LINE] @SuppressWarnings("unchecked") [EOL] public <T extends TreeNode> T readValueAsTree() throws IOException, JsonProcessingException { [EOL]     ObjectCodec codec = getCodec(); [EOL]     if (codec == null) { [EOL]         throw new IllegalStateException("No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree"); [EOL]     } [EOL]     return (T) codec.readTree(this); [EOL] } private Feature(boolean defaultState); protected JsonParser(); protected JsonParser(int features); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract ObjectCodec getCodec(); public abstract void setCodec(ObjectCodec c); public Object getInputSource(); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public boolean canUseSchema(FormatSchema schema); public boolean requiresCustomCodec(); public abstract Version version(); public abstract void close() throws IOException; public int releaseBuffered(OutputStream out) throws IOException; public int releaseBuffered(Writer w) throws IOException; public JsonParser enable(Feature f); public JsonParser disable(Feature f); public JsonParser configure(Feature f, boolean state); public boolean isEnabled(Feature f); public int getFeatureMask(); public JsonParser setFeatureMask(int mask); public abstract JsonToken nextToken() throws IOException, JsonParseException; public abstract JsonToken nextValue() throws IOException, JsonParseException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public abstract JsonParser skipChildren() throws IOException, JsonParseException; public abstract boolean isClosed(); public abstract JsonToken getCurrentToken(); public abstract boolean hasCurrentToken(); public abstract String getCurrentName() throws IOException, JsonParseException; public abstract JsonStreamContext getParsingContext(); public abstract JsonLocation getTokenLocation(); public abstract JsonLocation getCurrentLocation(); public boolean isExpectedStartArrayToken(); public abstract void clearCurrentToken(); public abstract JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract Number getNumberValue() throws IOException, JsonParseException; public abstract NumberType getNumberType() throws IOException, JsonParseException; public byte getByteValue() throws IOException, JsonParseException; public short getShortValue() throws IOException, JsonParseException; public abstract int getIntValue() throws IOException, JsonParseException; public abstract long getLongValue() throws IOException, JsonParseException; public abstract BigInteger getBigIntegerValue() throws IOException, JsonParseException; public abstract float getFloatValue() throws IOException, JsonParseException; public abstract double getDoubleValue() throws IOException, JsonParseException; public abstract BigDecimal getDecimalValue() throws IOException, JsonParseException; public boolean getBooleanValue() throws IOException, JsonParseException; public abstract Object getEmbeddedObject() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public byte[] getBinaryValue() throws IOException, JsonParseException; public int readBinaryValue(OutputStream out) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; public int getValueAsInt() throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong() throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble() throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public boolean getValueAsBoolean() throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public abstract String getValueAsString(String defaultValue) throws IOException, JsonParseException; public boolean canReadObjectId(); public boolean canReadTypeId(); public Object getObjectId() throws IOException, JsonGenerationException; public Object getTypeId() throws IOException, JsonGenerationException; public T readValueAs(Class<T> valueType) throws IOException, JsonProcessingException; public T readValueAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValueAsTree() throws IOException, JsonProcessingException; protected JsonParseException _constructError(String msg); protected void _reportUnsupportedOperation(); int MIN_BYTE_I=Optional[(int) Byte.MIN_VALUE]; int MAX_BYTE_I=Optional[(int) 255]; int MIN_SHORT_I=Optional[(int) Short.MIN_VALUE]; int MAX_SHORT_I=Optional[(int) Short.MAX_VALUE]; int _features
 [LINE] ObjectCodec codec = getCodec(); [LINE] @SuppressWarnings("unchecked") [EOL] public <T extends TreeNode> T readValueAsTree() throws IOException, JsonProcessingException { [EOL]     ObjectCodec codec = getCodec(); [EOL]     if (codec == null) { [EOL]         throw new IllegalStateException("No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree"); [EOL]     } [EOL]     return (T) codec.readTree(this); [EOL] } private Feature(boolean defaultState); protected JsonParser(); protected JsonParser(int features); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract ObjectCodec getCodec(); public abstract void setCodec(ObjectCodec c); public Object getInputSource(); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public boolean canUseSchema(FormatSchema schema); public boolean requiresCustomCodec(); public abstract Version version(); public abstract void close() throws IOException; public int releaseBuffered(OutputStream out) throws IOException; public int releaseBuffered(Writer w) throws IOException; public JsonParser enable(Feature f); public JsonParser disable(Feature f); public JsonParser configure(Feature f, boolean state); public boolean isEnabled(Feature f); public int getFeatureMask(); public JsonParser setFeatureMask(int mask); public abstract JsonToken nextToken() throws IOException, JsonParseException; public abstract JsonToken nextValue() throws IOException, JsonParseException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public abstract JsonParser skipChildren() throws IOException, JsonParseException; public abstract boolean isClosed(); public abstract JsonToken getCurrentToken(); public abstract boolean hasCurrentToken(); public abstract String getCurrentName() throws IOException, JsonParseException; public abstract JsonStreamContext getParsingContext(); public abstract JsonLocation getTokenLocation(); public abstract JsonLocation getCurrentLocation(); public boolean isExpectedStartArrayToken(); public abstract void clearCurrentToken(); public abstract JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract Number getNumberValue() throws IOException, JsonParseException; public abstract NumberType getNumberType() throws IOException, JsonParseException; public byte getByteValue() throws IOException, JsonParseException; public short getShortValue() throws IOException, JsonParseException; public abstract int getIntValue() throws IOException, JsonParseException; public abstract long getLongValue() throws IOException, JsonParseException; public abstract BigInteger getBigIntegerValue() throws IOException, JsonParseException; public abstract float getFloatValue() throws IOException, JsonParseException; public abstract double getDoubleValue() throws IOException, JsonParseException; public abstract BigDecimal getDecimalValue() throws IOException, JsonParseException; public boolean getBooleanValue() throws IOException, JsonParseException; public abstract Object getEmbeddedObject() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public byte[] getBinaryValue() throws IOException, JsonParseException; public int readBinaryValue(OutputStream out) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; public int getValueAsInt() throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong() throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble() throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public boolean getValueAsBoolean() throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public abstract String getValueAsString(String defaultValue) throws IOException, JsonParseException; public boolean canReadObjectId(); public boolean canReadTypeId(); public Object getObjectId() throws IOException, JsonGenerationException; public Object getTypeId() throws IOException, JsonGenerationException; public T readValueAs(Class<T> valueType) throws IOException, JsonProcessingException; public T readValueAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValueAsTree() throws IOException, JsonProcessingException; protected JsonParseException _constructError(String msg); protected void _reportUnsupportedOperation(); int MIN_BYTE_I=Optional[(int) Byte.MIN_VALUE]; int MAX_BYTE_I=Optional[(int) 255]; int MIN_SHORT_I=Optional[(int) Short.MIN_VALUE]; int MAX_SHORT_I=Optional[(int) Short.MAX_VALUE]; int _features
 [LINE] if (codec == null) { [LINE] @SuppressWarnings("unchecked") [EOL] public <T extends TreeNode> T readValueAsTree() throws IOException, JsonProcessingException { [EOL]     ObjectCodec codec = getCodec(); [EOL]     if (codec == null) { [EOL]         throw new IllegalStateException("No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree"); [EOL]     } [EOL]     return (T) codec.readTree(this); [EOL] } private Feature(boolean defaultState); protected JsonParser(); protected JsonParser(int features); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract ObjectCodec getCodec(); public abstract void setCodec(ObjectCodec c); public Object getInputSource(); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public boolean canUseSchema(FormatSchema schema); public boolean requiresCustomCodec(); public abstract Version version(); public abstract void close() throws IOException; public int releaseBuffered(OutputStream out) throws IOException; public int releaseBuffered(Writer w) throws IOException; public JsonParser enable(Feature f); public JsonParser disable(Feature f); public JsonParser configure(Feature f, boolean state); public boolean isEnabled(Feature f); public int getFeatureMask(); public JsonParser setFeatureMask(int mask); public abstract JsonToken nextToken() throws IOException, JsonParseException; public abstract JsonToken nextValue() throws IOException, JsonParseException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public abstract JsonParser skipChildren() throws IOException, JsonParseException; public abstract boolean isClosed(); public abstract JsonToken getCurrentToken(); public abstract boolean hasCurrentToken(); public abstract String getCurrentName() throws IOException, JsonParseException; public abstract JsonStreamContext getParsingContext(); public abstract JsonLocation getTokenLocation(); public abstract JsonLocation getCurrentLocation(); public boolean isExpectedStartArrayToken(); public abstract void clearCurrentToken(); public abstract JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract Number getNumberValue() throws IOException, JsonParseException; public abstract NumberType getNumberType() throws IOException, JsonParseException; public byte getByteValue() throws IOException, JsonParseException; public short getShortValue() throws IOException, JsonParseException; public abstract int getIntValue() throws IOException, JsonParseException; public abstract long getLongValue() throws IOException, JsonParseException; public abstract BigInteger getBigIntegerValue() throws IOException, JsonParseException; public abstract float getFloatValue() throws IOException, JsonParseException; public abstract double getDoubleValue() throws IOException, JsonParseException; public abstract BigDecimal getDecimalValue() throws IOException, JsonParseException; public boolean getBooleanValue() throws IOException, JsonParseException; public abstract Object getEmbeddedObject() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public byte[] getBinaryValue() throws IOException, JsonParseException; public int readBinaryValue(OutputStream out) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; public int getValueAsInt() throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong() throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble() throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public boolean getValueAsBoolean() throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public abstract String getValueAsString(String defaultValue) throws IOException, JsonParseException; public boolean canReadObjectId(); public boolean canReadTypeId(); public Object getObjectId() throws IOException, JsonGenerationException; public Object getTypeId() throws IOException, JsonGenerationException; public T readValueAs(Class<T> valueType) throws IOException, JsonProcessingException; public T readValueAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValueAsTree() throws IOException, JsonProcessingException; protected JsonParseException _constructError(String msg); protected void _reportUnsupportedOperation(); int MIN_BYTE_I=Optional[(int) Byte.MIN_VALUE]; int MAX_BYTE_I=Optional[(int) 255]; int MIN_SHORT_I=Optional[(int) Short.MIN_VALUE]; int MAX_SHORT_I=Optional[(int) Short.MAX_VALUE]; int _features
 [LINE] throw new IllegalStateException("No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree"); [LINE] @SuppressWarnings("unchecked") [EOL] public <T extends TreeNode> T readValueAsTree() throws IOException, JsonProcessingException { [EOL]     ObjectCodec codec = getCodec(); [EOL]     if (codec == null) { [EOL]         throw new IllegalStateException("No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree"); [EOL]     } [EOL]     return (T) codec.readTree(this); [EOL] } private Feature(boolean defaultState); protected JsonParser(); protected JsonParser(int features); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract ObjectCodec getCodec(); public abstract void setCodec(ObjectCodec c); public Object getInputSource(); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public boolean canUseSchema(FormatSchema schema); public boolean requiresCustomCodec(); public abstract Version version(); public abstract void close() throws IOException; public int releaseBuffered(OutputStream out) throws IOException; public int releaseBuffered(Writer w) throws IOException; public JsonParser enable(Feature f); public JsonParser disable(Feature f); public JsonParser configure(Feature f, boolean state); public boolean isEnabled(Feature f); public int getFeatureMask(); public JsonParser setFeatureMask(int mask); public abstract JsonToken nextToken() throws IOException, JsonParseException; public abstract JsonToken nextValue() throws IOException, JsonParseException; public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException; public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public abstract JsonParser skipChildren() throws IOException, JsonParseException; public abstract boolean isClosed(); public abstract JsonToken getCurrentToken(); public abstract boolean hasCurrentToken(); public abstract String getCurrentName() throws IOException, JsonParseException; public abstract JsonStreamContext getParsingContext(); public abstract JsonLocation getTokenLocation(); public abstract JsonLocation getCurrentLocation(); public boolean isExpectedStartArrayToken(); public abstract void clearCurrentToken(); public abstract JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract Number getNumberValue() throws IOException, JsonParseException; public abstract NumberType getNumberType() throws IOException, JsonParseException; public byte getByteValue() throws IOException, JsonParseException; public short getShortValue() throws IOException, JsonParseException; public abstract int getIntValue() throws IOException, JsonParseException; public abstract long getLongValue() throws IOException, JsonParseException; public abstract BigInteger getBigIntegerValue() throws IOException, JsonParseException; public abstract float getFloatValue() throws IOException, JsonParseException; public abstract double getDoubleValue() throws IOException, JsonParseException; public abstract BigDecimal getDecimalValue() throws IOException, JsonParseException; public boolean getBooleanValue() throws IOException, JsonParseException; public abstract Object getEmbeddedObject() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public byte[] getBinaryValue() throws IOException, JsonParseException; public int readBinaryValue(OutputStream out) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; public int getValueAsInt() throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong() throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble() throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public boolean getValueAsBoolean() throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public abstract String getValueAsString(String defaultValue) throws IOException, JsonParseException; public boolean canReadObjectId(); public boolean canReadTypeId(); public Object getObjectId() throws IOException, JsonGenerationException; public Object getTypeId() throws IOException, JsonGenerationException; public T readValueAs(Class<T> valueType) throws IOException, JsonProcessingException; public T readValueAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(Class<T> valueType) throws IOException, JsonProcessingException; public Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException, JsonProcessingException; public T readValueAsTree() throws IOException, JsonProcessingException; protected JsonParseException _constructError(String msg); protected void _reportUnsupportedOperation(); int MIN_BYTE_I=Optional[(int) Byte.MIN_VALUE]; int MAX_BYTE_I=Optional[(int) 255]; int MIN_SHORT_I=Optional[(int) Short.MIN_VALUE]; int MAX_SHORT_I=Optional[(int) Short.MAX_VALUE]; int _features
 [LINE] public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec) [LINE] public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec) { [EOL]     super(features, codec); [EOL]     _ioContext = ctxt; [EOL]     if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] super(features, codec); [LINE] public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec) { [EOL]     super(features, codec); [EOL]     _ioContext = ctxt; [EOL]     if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] _ioContext = ctxt; [LINE] public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec) { [EOL]     super(features, codec); [EOL]     _ioContext = ctxt; [EOL]     if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [LINE] public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec) { [EOL]     super(features, codec); [EOL]     _ioContext = ctxt; [EOL]     if (isEnabled(Feature.ESCAPE_NON_ASCII)) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] @Override [LINE] @Override [EOL] public Version version() { [EOL]     return VersionUtil.versionFor(getClass()); [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return VersionUtil.versionFor(getClass()); [LINE] @Override [EOL] public Version version() { [EOL]     return VersionUtil.versionFor(getClass()); [EOL] } public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setRootValueSeparator(SerializableString sep); public Version version(); public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; int[] sOutputEscapes=Optional[CharTypes.get7BitOutputEscapes()]; IOContext _ioContext; int[] _outputEscapes=Optional[sOutputEscapes]; int _maximumNonEscapedChar; CharacterEscapes _characterEscapes; SerializableString _rootValueSeparator=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public void resetWithShared(char[] buf, int start, int len) [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _resultString = null; [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _resultArray = null; [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _inputBuffer = buf; [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _inputStart = start; [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _inputLen = len; [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_hasSegments) { [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] clearSegments(); [LINE] public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] public void resetWithCopy(char[] buf, int start, int len) [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _inputBuffer = null; [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _inputStart = -1; // indicates shared buffer not used [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _inputLen = 0; [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _resultString = null; [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _resultArray = null; [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_hasSegments) { [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] } else if (_currentSegment == null) { [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSegment = findBuffer(len); [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSize = _segmentSize = 0; [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] append(buf, start, len); [LINE] public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] private void clearSegments() [LINE] private void clearSegments() { [EOL]     _hasSegments = false; [EOL]     _segments.clear(); [EOL]     _currentSize = _segmentSize = 0; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _hasSegments = false; [LINE] private void clearSegments() { [EOL]     _hasSegments = false; [EOL]     _segments.clear(); [EOL]     _currentSize = _segmentSize = 0; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _segments.clear(); [LINE] private void clearSegments() { [EOL]     _hasSegments = false; [EOL]     _segments.clear(); [EOL]     _currentSize = _segmentSize = 0; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSize = _segmentSize = 0; [LINE] private void clearSegments() { [EOL]     _hasSegments = false; [EOL]     _segments.clear(); [EOL]     _currentSize = _segmentSize = 0; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] return (_resultArray = _resultString.toCharArray()); [LINE] public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_inputStart >= 0) { [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_inputLen < 1) { [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _resultString = new String(_inputBuffer, _inputStart, _inputLen); [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] int segLen = _segmentSize; [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] int currLen = _currentSize; [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (segLen == 0) { // yup [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] StringBuilder sb = new StringBuilder(segLen + currLen); [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_segments != null) { [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] for (int i = 0, len = _segments.size(); i < len; ++i) { [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] char[] curr = _segments.get(i); [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] sb.append(curr, 0, curr.length); [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] sb.append(_currentSegment, 0, _currentSize); [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _resultString = sb.toString(); [LINE] public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (max > 0) { [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] System.arraycopy(c, start, curr, _currentSize, max); [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] start += max; [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] len -= max; [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] do { [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] expand(len); [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] int amount = Math.min(_currentSegment.length, len); [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] System.arraycopy(c, start, _currentSegment, 0, amount); [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSize += amount; [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] start += amount; [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] len -= amount; [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] } while (len > 0); [LINE] public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] unshare(len); [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (max > 0) { [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] str.getChars(offset, offset+max, curr, _currentSize); [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] len -= max; [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] offset += max; [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] do { [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] expand(len); [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] int amount = Math.min(_currentSegment.length, len); [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] str.getChars(offset, offset+amount, _currentSegment, 0); [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSize += amount; [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] offset += amount; [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] len -= amount; [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] } while (len > 0); [LINE] public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] public char[] getCurrentSegment() [LINE] public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_inputStart >= 0) { [LINE] public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] char[] curr = _currentSegment; [LINE] public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (curr == null) { [LINE] public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] } else if (_currentSize >= curr.length) { [LINE] public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] return _currentSegment; [LINE] public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] public int getCurrentSegmentSize() { [LINE] public int getCurrentSegmentSize() { [EOL]     return _currentSize; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] return _currentSize; [LINE] public int getCurrentSegmentSize() { [EOL]     return _currentSize; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] private void expand(int minNewSegmentSize) [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (_segments == null) { [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _segments = new ArrayList<char[]>(); [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] char[] curr = _currentSegment; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _hasSegments = true; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _segments.add(curr); [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _segmentSize += curr.length; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] int oldLen = curr.length; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] int sizeAddition = oldLen >> 1; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] if (sizeAddition < minNewSegmentSize) { [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] sizeAddition = minNewSegmentSize; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSize = 0; [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [LINE] private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] return _resultString.toCharArray(); [LINE] private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] } public TextBuffer(BufferRecycler allocator); public void releaseBuffers(); public void resetWithEmpty(); public void resetWithShared(char[] buf, int start, int len); public void resetWithCopy(char[] buf, int start, int len); public void resetWithString(String value); private char[] findBuffer(int needed); private void clearSegments(); public int size(); public int getTextOffset(); public boolean hasTextAsCharacters(); public char[] getTextBuffer(); public String contentsAsString(); public char[] contentsAsArray(); public BigDecimal contentsAsDecimal() throws NumberFormatException; public double contentsAsDouble() throws NumberFormatException; public void ensureNotShared(); public void append(char c); public void append(char[] c, int start, int len); public void append(String str, int offset, int len); public char[] getCurrentSegment(); public char[] emptyAndGetCurrentSegment(); public int getCurrentSegmentSize(); public void setCurrentLength(int len); public char[] finishCurrentSegment(); public char[] expandCurrentSegment(); public String toString(); private void unshare(int needExtra); private void expand(int minNewSegmentSize); private char[] buildResultArray(); private char[] _charArray(int len); char[] NO_CHARS=Optional[new char[0]]; int MIN_SEGMENT_LEN=Optional[1000]; int MAX_SEGMENT_LEN=Optional[0x40000]; BufferRecycler _allocator; char[] _inputBuffer; int _inputStart; int _inputLen; ArrayList<char[]> _segments; boolean _hasSegments=Optional[false]; int _segmentSize; char[] _currentSegment; int _currentSize; String _resultString; char[] _resultArray
 [LINE] protected GeneratorBase(int features, ObjectCodec codec) [LINE] protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] super(); [LINE] protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] _features = features; [LINE] protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] _writeContext = JsonWriteContext.createRootContext(); [LINE] protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] _objectCodec = codec; [LINE] protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [LINE] protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] @Override [LINE] @Override [EOL] public final boolean isEnabled(Feature f) { [EOL]     return (_features & f.getMask()) != 0; [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] return (_features & f.getMask()) != 0; [LINE] @Override [EOL] public final boolean isEnabled(Feature f) { [EOL]     return (_features & f.getMask()) != 0; [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] @Override [LINE] @Override [EOL] public final JsonWriteContext getOutputContext() { [EOL]     return _writeContext; [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] public final JsonWriteContext getOutputContext() { return _writeContext; } [LINE] @Override [EOL] public final JsonWriteContext getOutputContext() { [EOL]     return _writeContext; [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] @Override [LINE] @Override [EOL] public void close() throws IOException { [EOL]     _closed = true; [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] _closed = true; [LINE] @Override [EOL] public void close() throws IOException { [EOL]     _closed = true; [EOL] } protected GeneratorBase(int features, ObjectCodec codec); public Version version(); public JsonGenerator enable(Feature f); public JsonGenerator disable(Feature f); public final boolean isEnabled(Feature f); public int getFeatureMask(); public JsonGenerator setFeatureMask(int mask); public JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setCodec(ObjectCodec oc); public final ObjectCodec getCodec(); public final JsonWriteContext getOutputContext(); public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawValue(String text) throws IOException, JsonGenerationException; public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeObject(Object value) throws IOException, JsonProcessingException; public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public abstract void flush() throws IOException; public void close() throws IOException; public boolean isClosed(); public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; protected abstract void _releaseBuffers(); protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _reportError(String msg) throws JsonGenerationException; protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException; protected final void _throwInternal(); protected void _reportUnsupportedOperation(); ObjectCodec _objectCodec; int _features; boolean _cfgNumbersAsStrings; JsonWriteContext _writeContext; boolean _closed
 [LINE] @Override [LINE] @Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _verifyValueWrite("start an array"); [LINE] @Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _writeContext = _writeContext.createChildArrayContext(); [LINE] @Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_cfgPrettyPrinter != null) { [LINE] @Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_outputTail >= _outputEnd) { [LINE] @Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputBuffer[_outputTail++] = BYTE_LBRACKET; [LINE] @Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_LBRACKET; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] @Override [LINE] @Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (!_writeContext.inArray()) { [LINE] @Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_cfgPrettyPrinter != null) { [LINE] @Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_outputTail >= _outputEnd) { [LINE] @Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputBuffer[_outputTail++] = BYTE_RBRACKET; [LINE] @Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _writeContext = _writeContext.getParent(); [LINE] @Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_RBRACKET; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _writeLongString(_charBuffer, 0, len); [LINE] @Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] return; [LINE] @Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] private void _writeLongString(char[] text, int offset, int len) [LINE] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_outputTail >= _outputEnd) { [LINE] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputBuffer[_outputTail++] = BYTE_QUOTE; [LINE] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _writeStringSegments(_charBuffer, 0, len); [LINE] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_outputTail >= _outputEnd) { [LINE] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputBuffer[_outputTail++] = BYTE_QUOTE; [LINE] private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegments(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] @Override [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _verifyValueWrite("write text value"); [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_outputTail >= _outputEnd) { [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputBuffer[_outputTail++] = BYTE_QUOTE; [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _writeBytes(text, offset, length); [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (_outputTail >= _outputEnd) { [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputBuffer[_outputTail++] = BYTE_QUOTE; [LINE] @Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeBytes(text, offset, length); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] case JsonWriteContext.STATUS_OK_AFTER_COMMA: [LINE] @Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         byte b; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 b = BYTE_COMMA; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 b = BYTE_COLON; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL]                     if (raw.length > 0) { [EOL]                         _writeBytes(raw); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = b; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] b = BYTE_COMMA; [LINE] @Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         byte b; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 b = BYTE_COMMA; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 b = BYTE_COLON; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL]                     if (raw.length > 0) { [EOL]                         _writeBytes(raw); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = b; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] break; [LINE] @Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         byte b; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 b = BYTE_COMMA; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 b = BYTE_COLON; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL]                     if (raw.length > 0) { [EOL]                         _writeBytes(raw); [EOL]                     } [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = b; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] writeEndArray(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_outputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _outputStream.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _outputStream.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if ((_outputTail + len) > _outputEnd) { [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _flushBuffer(); [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] if (len > MAX_BYTES_TO_BUFFER) { [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputStream.write(bytes, offset, len); [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] return; [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _outputTail += len; [LINE] private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException { [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > MAX_BYTES_TO_BUFFER) { [EOL]             _outputStream.write(bytes, offset, len); [EOL]             return; [EOL]         } [EOL]     } [EOL]     System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len); [EOL]     _outputTail += len; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _flushBuffer(); [LINE] private final void _writeStringSegments(String text) throws IOException, JsonGenerationException { [EOL]     int left = text.length(); [EOL]     int offset = 0; [EOL]     final char[] cbuf = _charBuffer; [EOL]     while (left > 0) { [EOL]         int len = Math.min(_outputMaxContiguous, left); [EOL]         text.getChars(offset, offset + len, cbuf, 0); [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(cbuf, 0, len); [EOL]         offset += len; [EOL]         left -= len; [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] _flushBuffer(); [LINE] private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException { [EOL]     do { [EOL]         int len = Math.min(_outputMaxContiguous, totalLen); [EOL]         if ((_outputTail + len) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _writeStringSegment(cbuf, offset, len); [EOL]         offset += len; [EOL]         totalLen -= len; [EOL]     } while (totalLen > 0); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }]; OutputStream _outputStream; byte[] _outputBuffer; int _outputTail=Optional[0]; int _outputEnd; int _outputMaxContiguous; char[] _charBuffer; int _charBufferLength; byte[] _entityBuffer; boolean _bufferRecyclable
 [LINE] public final boolean inRoot() { return _type == TYPE_ROOT; } [LINE] public final boolean inRoot() { [EOL]     return _type == TYPE_ROOT; [EOL] } protected JsonStreamContext(); public abstract JsonStreamContext getParent(); public final boolean inArray(); public final boolean inRoot(); public final boolean inObject(); public final String getTypeDesc(); public final int getEntryCount(); public final int getCurrentIndex(); public abstract String getCurrentName(); int TYPE_ROOT=Optional[0]; int TYPE_ARRAY=Optional[1]; int TYPE_OBJECT=Optional[2]; int _type; int _index
 [LINE] public final int getCurrentIndex() [LINE] public final int getCurrentIndex() { [EOL]     return (_index < 0) ? 0 : _index; [EOL] } protected JsonStreamContext(); public abstract JsonStreamContext getParent(); public final boolean inArray(); public final boolean inRoot(); public final boolean inObject(); public final String getTypeDesc(); public final int getEntryCount(); public final int getCurrentIndex(); public abstract String getCurrentName(); int TYPE_ROOT=Optional[0]; int TYPE_ARRAY=Optional[1]; int TYPE_OBJECT=Optional[2]; int _type; int _index
 [LINE] return (_index < 0) ? 0 : _index; [LINE] public final int getCurrentIndex() { [EOL]     return (_index < 0) ? 0 : _index; [EOL] } protected JsonStreamContext(); public abstract JsonStreamContext getParent(); public final boolean inArray(); public final boolean inRoot(); public final boolean inObject(); public final String getTypeDesc(); public final int getEntryCount(); public final int getCurrentIndex(); public abstract String getCurrentName(); int TYPE_ROOT=Optional[0]; int TYPE_ARRAY=Optional[1]; int TYPE_OBJECT=Optional[2]; int _type; int _index
 [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (!acc.hasMoreBytes()) { [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] byte b = acc.nextByte(); [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] int ch = skipSpace(acc, b); [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (ch < 0) { [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (ch == '{') { // JSON object? [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] MatchStrength strength; [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (ch == '[') { [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] ch = skipSpace(acc); [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (ch < 0) { [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (ch == ']' || ch == '[') { [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] return MatchStrength.SOLID_MATCH; [LINE] public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] private static int skipSpace(InputAccessor acc) throws IOException [LINE] private static int skipSpace(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return -1; [EOL]     } [EOL]     return skipSpace(acc, acc.nextByte()); [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (!acc.hasMoreBytes()) { [LINE] private static int skipSpace(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return -1; [EOL]     } [EOL]     return skipSpace(acc, acc.nextByte()); [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] return skipSpace(acc, acc.nextByte()); [LINE] private static int skipSpace(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return -1; [EOL]     } [EOL]     return skipSpace(acc, acc.nextByte()); [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] while (true) { [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] int ch = (int) b & 0xFF; [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] return ch; [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] if (!acc.hasMoreBytes()) { [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] b = acc.nextByte(); [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] ch = (int) b & 0xFF; [LINE] private static int skipSpace(InputAccessor acc, byte b) throws IOException { [EOL]     while (true) { [EOL]         int ch = (int) b & 0xFF; [EOL]         if (!(ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')) { [EOL]             return ch; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return -1; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]         ch = (int) b & 0xFF; [EOL]     } [EOL] } public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in); public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen); public JsonEncoding detectEncoding() throws IOException, JsonParseException; public Reader constructReader() throws IOException; public JsonParser constructParser(int parserFeatures, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols, boolean canonicalize, boolean intern) throws IOException, JsonParseException; public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; private static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength) throws IOException; private static int skipSpace(InputAccessor acc) throws IOException; private static int skipSpace(InputAccessor acc, byte b) throws IOException; private boolean handleBOM(int quad) throws IOException; private boolean checkUTF32(int quad) throws IOException; private boolean checkUTF16(int i16); private void reportWeirdUCS4(String type) throws IOException; protected boolean ensureLoaded(int minimum) throws IOException; byte UTF8_BOM_1=Optional[(byte) 0xEF]; byte UTF8_BOM_2=Optional[(byte) 0xBB]; byte UTF8_BOM_3=Optional[(byte) 0xBF]; IOContext _context; InputStream _in; byte[] _inputBuffer; int _inputPtr; int _inputEnd; boolean _bufferRecyclable; int _inputProcessed; boolean _bigEndian=Optional[true]; int _bytesPerChar=Optional[0]
 [LINE] public int getMask() { return _mask; } [LINE] public int getMask() { [EOL]     return _mask; [EOL] } private Feature(boolean defaultState); protected JsonGenerator(); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); public abstract Version version(); public Object getOutputTarget(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state); public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); public abstract JsonGenerator setFeatureMask(int mask); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public JsonGenerator setPrettyPrinter(PrettyPrinter pp); public PrettyPrinter getPrettyPrinter(); public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public JsonGenerator setRootValueSeparator(SerializableString sep); public boolean canUseSchema(FormatSchema schema); public boolean canWriteObjectId(); public boolean canWriteTypeId(); public boolean canOmitFields(); public abstract void writeStartArray() throws IOException, JsonGenerationException; public abstract void writeEndArray() throws IOException, JsonGenerationException; public abstract void writeStartObject() throws IOException, JsonGenerationException; public abstract void writeEndObject() throws IOException, JsonGenerationException; public abstract void writeFieldName(String name) throws IOException, JsonGenerationException; public abstract void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public abstract void writeString(String text) throws IOException, JsonGenerationException; public abstract void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeString(SerializableString text) throws IOException, JsonGenerationException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public abstract void writeRaw(String text) throws IOException, JsonGenerationException; public abstract void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRaw(SerializableString raw) throws IOException, JsonGenerationException; public abstract void writeRawValue(String text) throws IOException, JsonGenerationException; public abstract void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(byte[] data, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(byte[] data) throws IOException, JsonGenerationException; public int writeBinary(InputStream data, int dataLength) throws IOException, JsonGenerationException; public abstract int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short v) throws IOException, JsonGenerationException; public abstract void writeNumber(int v) throws IOException, JsonGenerationException; public abstract void writeNumber(long v) throws IOException, JsonGenerationException; public abstract void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public abstract void writeNumber(double d) throws IOException, JsonGenerationException; public abstract void writeNumber(float f) throws IOException, JsonGenerationException; public abstract void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public abstract void writeNumber(String encodedValue) throws IOException, JsonGenerationException, UnsupportedOperationException; public abstract void writeBoolean(boolean state) throws IOException, JsonGenerationException; public abstract void writeNull() throws IOException, JsonGenerationException; public void writeObjectId(Object id) throws IOException, JsonGenerationException; public void writeObjectRef(Object id) throws IOException, JsonGenerationException; public void writeTypeId(Object id) throws IOException, JsonGenerationException; public abstract void writeObject(Object pojo) throws IOException, JsonProcessingException; public abstract void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; public final void writeBooleanField(String fieldName, boolean value) throws IOException, JsonGenerationException; public final void writeNullField(String fieldName) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, int value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, long value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, double value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, float value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, BigDecimal value) throws IOException, JsonGenerationException; public final void writeBinaryField(String fieldName, byte[] data) throws IOException, JsonGenerationException; public final void writeArrayFieldStart(String fieldName) throws IOException, JsonGenerationException; public final void writeObjectFieldStart(String fieldName) throws IOException, JsonGenerationException; public final void writeObjectField(String fieldName, Object pojo) throws IOException, JsonProcessingException; public void writeOmittedField(String fieldName) throws IOException, JsonGenerationException; public abstract void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public abstract void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; public abstract JsonStreamContext getOutputContext(); public abstract void flush() throws IOException; public abstract boolean isClosed(); public abstract void close() throws IOException; PrettyPrinter _cfgPrettyPrinter
 [LINE] protected JsonGenerator() { } [LINE] protected JsonGenerator() { [EOL] } private Feature(boolean defaultState); protected JsonGenerator(); public static int collectDefaults(); public boolean enabledByDefault(); public int getMask(); public abstract JsonGenerator setCodec(ObjectCodec oc); public abstract ObjectCodec getCodec(); public abstract Version version(); public Object getOutputTarget(); public abstract JsonGenerator enable(Feature f); public abstract JsonGenerator disable(Feature f); public final JsonGenerator configure(Feature f, boolean state); public abstract boolean isEnabled(Feature f); public abstract int getFeatureMask(); public abstract JsonGenerator setFeatureMask(int mask); public void setSchema(FormatSchema schema); public FormatSchema getSchema(); public JsonGenerator setPrettyPrinter(PrettyPrinter pp); public PrettyPrinter getPrettyPrinter(); public abstract JsonGenerator useDefaultPrettyPrinter(); public JsonGenerator setHighestNonEscapedChar(int charCode); public int getHighestEscapedChar(); public CharacterEscapes getCharacterEscapes(); public JsonGenerator setCharacterEscapes(CharacterEscapes esc); public JsonGenerator setRootValueSeparator(SerializableString sep); public boolean canUseSchema(FormatSchema schema); public boolean canWriteObjectId(); public boolean canWriteTypeId(); public boolean canOmitFields(); public abstract void writeStartArray() throws IOException, JsonGenerationException; public abstract void writeEndArray() throws IOException, JsonGenerationException; public abstract void writeStartObject() throws IOException, JsonGenerationException; public abstract void writeEndObject() throws IOException, JsonGenerationException; public abstract void writeFieldName(String name) throws IOException, JsonGenerationException; public abstract void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public abstract void writeString(String text) throws IOException, JsonGenerationException; public abstract void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeString(SerializableString text) throws IOException, JsonGenerationException; public abstract void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public abstract void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public abstract void writeRaw(String text) throws IOException, JsonGenerationException; public abstract void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRaw(char c) throws IOException, JsonGenerationException; public void writeRaw(SerializableString raw) throws IOException, JsonGenerationException; public abstract void writeRawValue(String text) throws IOException, JsonGenerationException; public abstract void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException; public abstract void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(byte[] data, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(byte[] data) throws IOException, JsonGenerationException; public int writeBinary(InputStream data, int dataLength) throws IOException, JsonGenerationException; public abstract int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short v) throws IOException, JsonGenerationException; public abstract void writeNumber(int v) throws IOException, JsonGenerationException; public abstract void writeNumber(long v) throws IOException, JsonGenerationException; public abstract void writeNumber(BigInteger v) throws IOException, JsonGenerationException; public abstract void writeNumber(double d) throws IOException, JsonGenerationException; public abstract void writeNumber(float f) throws IOException, JsonGenerationException; public abstract void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException; public abstract void writeNumber(String encodedValue) throws IOException, JsonGenerationException, UnsupportedOperationException; public abstract void writeBoolean(boolean state) throws IOException, JsonGenerationException; public abstract void writeNull() throws IOException, JsonGenerationException; public void writeObjectId(Object id) throws IOException, JsonGenerationException; public void writeObjectRef(Object id) throws IOException, JsonGenerationException; public void writeTypeId(Object id) throws IOException, JsonGenerationException; public abstract void writeObject(Object pojo) throws IOException, JsonProcessingException; public abstract void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException; public void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException; public final void writeBooleanField(String fieldName, boolean value) throws IOException, JsonGenerationException; public final void writeNullField(String fieldName) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, int value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, long value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, double value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, float value) throws IOException, JsonGenerationException; public final void writeNumberField(String fieldName, BigDecimal value) throws IOException, JsonGenerationException; public final void writeBinaryField(String fieldName, byte[] data) throws IOException, JsonGenerationException; public final void writeArrayFieldStart(String fieldName) throws IOException, JsonGenerationException; public final void writeObjectFieldStart(String fieldName) throws IOException, JsonGenerationException; public final void writeObjectField(String fieldName, Object pojo) throws IOException, JsonProcessingException; public void writeOmittedField(String fieldName) throws IOException, JsonGenerationException; public abstract void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException; public abstract void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException; public abstract JsonStreamContext getOutputContext(); public abstract void flush() throws IOException; public abstract boolean isClosed(); public abstract void close() throws IOException; PrettyPrinter _cfgPrettyPrinter
 [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _name = name; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _usesPadding = usesPadding; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _paddingChar = paddingChar; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _maxLineLength = maxLineLength; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] int alphaLen = base64Alphabet.length(); [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] if (alphaLen != 64) { [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] for (int i = 0; i < alphaLen; ++i) { [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] char alpha = _base64ToAsciiC[i]; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _base64ToAsciiB[i] = (byte) alpha; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _asciiToBase64[alpha] = i; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] if (usesPadding) { [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [LINE] public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public Base64Variant(Base64Variant base, String name, int maxLineLength) [LINE] public Base64Variant(Base64Variant base, String name, int maxLineLength) { [EOL]     this(base, name, base._usesPadding, base._paddingChar, maxLineLength); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] this(base, name, base._usesPadding, base._paddingChar, maxLineLength); [LINE] public Base64Variant(Base64Variant base, String name, int maxLineLength) { [EOL]     this(base, name, base._usesPadding, base._paddingChar, maxLineLength); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _name = name; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] byte[] srcB = base._base64ToAsciiB; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] char[] srcC = base._base64ToAsciiC; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] int[] srcV = base._asciiToBase64; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _usesPadding = usesPadding; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _paddingChar = paddingChar; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] _maxLineLength = maxLineLength; [LINE] public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] protected Object readResolve() { [LINE] protected Object readResolve() { [EOL]     return Base64Variants.valueOf(_name); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] return Base64Variants.valueOf(_name); [LINE] protected Object readResolve() { [EOL]     return Base64Variants.valueOf(_name); [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public String getName() { return _name; } [LINE] public String getName() { [EOL]     return _name; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public boolean usesPadding() { return _usesPadding; } [LINE] public boolean usesPadding() { [EOL]     return _usesPadding; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public boolean usesPaddingChar(char c) { return c == _paddingChar; } [LINE] public boolean usesPaddingChar(char c) { [EOL]     return c == _paddingChar; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public char getPaddingChar() { return _paddingChar; } [LINE] public char getPaddingChar() { [EOL]     return _paddingChar; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public byte getPaddingByte() { return (byte)_paddingChar; } [LINE] public byte getPaddingByte() { [EOL]     return (byte) _paddingChar; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public int getMaxLineLength() { return _maxLineLength; } [LINE] public int getMaxLineLength() { [EOL]     return _maxLineLength; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] @Override [LINE] @Override [EOL] public String toString() { [EOL]     return _name; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] public String toString() { return _name; } [LINE] @Override [EOL] public String toString() { [EOL]     return _name; [EOL] } public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength); public Base64Variant(Base64Variant base, String name, int maxLineLength); public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength); protected Object readResolve(); public String getName(); public boolean usesPadding(); public boolean usesPaddingChar(char c); public boolean usesPaddingChar(int ch); public char getPaddingChar(); public byte getPaddingByte(); public int getMaxLineLength(); public int decodeBase64Char(char c); public int decodeBase64Char(int ch); public int decodeBase64Byte(byte b); public char encodeBase64BitsAsChar(int value); public int encodeBase64Chunk(int b24, char[] buffer, int ptr); public void encodeBase64Chunk(StringBuilder sb, int b24); public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr); public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes); public byte encodeBase64BitsAsByte(int value); public int encodeBase64Chunk(int b24, byte[] buffer, int ptr); public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr); public String encode(byte[] input); public String encode(byte[] input, boolean addQuotes); public byte[] decode(String input) throws IllegalArgumentException; public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException; public String toString(); public boolean equals(Object o); public int hashCode(); protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException; protected void _reportBase64EOF() throws IllegalArgumentException; int INT_SPACE=Optional[0x20]; long serialVersionUID=Optional[1L]; char PADDING_CHAR_NONE=Optional['\0']; int BASE64_VALUE_INVALID=Optional[-1]; int BASE64_VALUE_PADDING=Optional[-2]; int[] _asciiToBase64=Optional[new int[128]]; char[] _base64ToAsciiC=Optional[new char[64]]; byte[] _base64ToAsciiB=Optional[new byte[64]]; String _name; boolean _usesPadding; char _paddingChar; int _maxLineLength
 [LINE] @Override [LINE] @Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] return _objectCodec; [LINE] @Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] reportInvalidNumber("Leading zeroes not allowed"); [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] ++_inputPtr; // Leading zero to be skipped [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (ch == INT_0) { [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] while (_inputPtr < _inputEnd || loadMore()) { [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] ch = _inputBuffer[_inputPtr]; [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (ch < '0' || ch > '9') { // followed by non-number; retain one zero [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] ++_inputPtr; // skip previous zero [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (ch != '0') { // followed by other number; return [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] break; [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] return ch; [LINE] private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [LINE] protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] break; [LINE] @Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr)); [LINE] @Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _inputPtr = ptr; [LINE] @Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _finishString2(); [LINE] @Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] protected void _finishString2() [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] char[] outBuf = _textBuffer.getCurrentSegment(); [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] int outPtr = _textBuffer.getCurrentSegmentSize(); [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] while (true) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (_inputPtr >= _inputEnd) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] char c = _inputBuffer[_inputPtr++]; [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] int i = (int) c; [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i <= INT_BACKSLASH) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i == INT_BACKSLASH) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] } else if (i <= INT_QUOTE) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i == INT_QUOTE) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i < INT_SPACE) { [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _throwUnquotedSpace(i, "string value"); [LINE] protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] continue; [LINE] private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (_inputPtr >= _inputEnd && !loadMore()) { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] char c = _inputBuffer[_inputPtr++]; [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (c == '/') { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _skipCppComment(); [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] } else if (c == '*') { [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _skipCComment(); [LINE] private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] private void _skipCComment() [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] main_loop: [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] while ((_inputPtr < _inputEnd) || loadMore()) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] int i = (int) _inputBuffer[_inputPtr++]; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i <= INT_ASTERISK) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i == INT_ASTERISK) { // end? [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if ((_inputPtr >= _inputEnd) && !loadMore()) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (_inputBuffer[_inputPtr] == INT_SLASH) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] ++_inputPtr; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] return; [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i < INT_SPACE) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i == INT_LF) { [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _skipLF(); [LINE] private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] private void _skipCppComment() [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] while ((_inputPtr < _inputEnd) || loadMore()) { [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] int i = (int) _inputBuffer[_inputPtr++]; [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i < INT_SPACE) { [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] if (i == INT_LF) { [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] _skipLF(); [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] break; [LINE] private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st); public ObjectCodec getCodec(); public void setCodec(ObjectCodec c); public int releaseBuffered(Writer w) throws IOException; public Object getInputSource(); protected boolean loadMore() throws IOException; protected char getNextChar(String eofMsg) throws IOException, JsonParseException; protected void _closeInput() throws IOException; protected void _releaseBuffers() throws IOException; public String getText() throws IOException, JsonParseException; public String getValueAsString() throws IOException, JsonParseException; public String getValueAsString(String defValue) throws IOException, JsonParseException; protected String _getText2(JsonToken t); public char[] getTextCharacters() throws IOException, JsonParseException; public int getTextLength() throws IOException, JsonParseException; public int getTextOffset() throws IOException, JsonParseException; public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException; protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException; public JsonToken nextToken() throws IOException, JsonParseException; private JsonToken _nextAfterName(); public String nextTextValue() throws IOException, JsonParseException; public int nextIntValue(int defaultValue) throws IOException, JsonParseException; public long nextLongValue(long defaultValue) throws IOException, JsonParseException; public Boolean nextBooleanValue() throws IOException, JsonParseException; public void close() throws IOException; protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException; private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException; private char _verifyNoLeadingZeroes() throws IOException, JsonParseException; protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException; protected String _parseFieldName(int i) throws IOException, JsonParseException; private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException; protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException; protected String _parseApostropheFieldName() throws IOException, JsonParseException; protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException; protected JsonToken _handleApostropheValue() throws IOException, JsonParseException; private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException; protected void _finishString() throws IOException, JsonParseException; protected void _finishString2() throws IOException, JsonParseException; protected void _skipString() throws IOException, JsonParseException; protected void _skipCR() throws IOException; protected void _skipLF() throws IOException; private int _skipWS() throws IOException, JsonParseException; private int _skipWSOrEnd() throws IOException, JsonParseException; private void _skipComment() throws IOException, JsonParseException; private void _skipCComment() throws IOException, JsonParseException; private void _skipCppComment() throws IOException, JsonParseException; protected char _decodeEscaped() throws IOException, JsonParseException; protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException; protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException; protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException; Reader _reader; char[] _inputBuffer; ObjectCodec _objectCodec; CharsToNameCanonicalizer _symbols; int _hashSeed; boolean _tokenIncomplete=Optional[false]
 [LINE] public WriterBasedJsonGenerator(IOContext ctxt, int features, [LINE] public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { [EOL]     super(ctxt, features, codec); [EOL]     _writer = w; [EOL]     _outputBuffer = ctxt.allocConcatBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] super(ctxt, features, codec); [LINE] public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { [EOL]     super(ctxt, features, codec); [EOL]     _writer = w; [EOL]     _outputBuffer = ctxt.allocConcatBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _writer = w; [LINE] public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { [EOL]     super(ctxt, features, codec); [EOL]     _writer = w; [EOL]     _outputBuffer = ctxt.allocConcatBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _outputBuffer = ctxt.allocConcatBuffer(); [LINE] public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { [EOL]     super(ctxt, features, codec); [EOL]     _writer = w; [EOL]     _outputBuffer = ctxt.allocConcatBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _outputEnd = _outputBuffer.length; [LINE] public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { [EOL]     super(ctxt, features, codec); [EOL]     _writer = w; [EOL]     _outputBuffer = ctxt.allocConcatBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _reportError("Current context not an object but "+_writeContext.getTypeDesc()); [LINE] @Override [EOL] public void writeEndObject() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inObject()) { [EOL]         _reportError("Current context not an object but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '}'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] @Override [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] super.close(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] if (_outputBuffer != null [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] while (true) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] JsonStreamContext ctxt = getOutputContext(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] if (ctxt.inArray()) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] } else if (ctxt.inObject()) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] break; [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _flushBuffer(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] if (_writer != null) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _writer.close(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _writer.flush(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _releaseBuffers(); [LINE] @Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] @Override [LINE] @Override [EOL] protected void _releaseBuffers() { [EOL]     char[] buf = _outputBuffer; [EOL]     if (buf != null) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(buf); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] char[] buf = _outputBuffer; [LINE] @Override [EOL] protected void _releaseBuffers() { [EOL]     char[] buf = _outputBuffer; [EOL]     if (buf != null) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(buf); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] if (buf != null) { [LINE] @Override [EOL] protected void _releaseBuffers() { [EOL]     char[] buf = _outputBuffer; [EOL]     if (buf != null) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(buf); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _outputBuffer = null; [LINE] @Override [EOL] protected void _releaseBuffers() { [EOL]     char[] buf = _outputBuffer; [EOL]     if (buf != null) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(buf); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] _ioContext.releaseConcatBuffer(buf); [LINE] @Override [EOL] protected void _releaseBuffers() { [EOL]     char[] buf = _outputBuffer; [EOL]     if (buf != null) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(buf); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] buffer[ptr++] = '0'; [LINE] private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] buffer[ptr++] = '0'; [LINE] private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] protected void _flushBuffer() throws IOException [LINE] protected void _flushBuffer() throws IOException { [EOL]     int len = _outputTail - _outputHead; [EOL]     if (len > 0) { [EOL]         int offset = _outputHead; [EOL]         _outputTail = _outputHead = 0; [EOL]         _writer.write(_outputBuffer, offset, len); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] int len = _outputTail - _outputHead; [LINE] protected void _flushBuffer() throws IOException { [EOL]     int len = _outputTail - _outputHead; [EOL]     if (len > 0) { [EOL]         int offset = _outputHead; [EOL]         _outputTail = _outputHead = 0; [EOL]         _writer.write(_outputBuffer, offset, len); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] if (len > 0) { [LINE] protected void _flushBuffer() throws IOException { [EOL]     int len = _outputTail - _outputHead; [EOL]     if (len > 0) { [EOL]         int offset = _outputHead; [EOL]         _outputTail = _outputHead = 0; [EOL]         _writer.write(_outputBuffer, offset, len); [EOL]     } [EOL] } public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w); public Object getOutputTarget(); public void writeFieldName(String name) throws IOException, JsonGenerationException; public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public void writeStartArray() throws IOException, JsonGenerationException; public void writeEndArray() throws IOException, JsonGenerationException; public void writeStartObject() throws IOException, JsonGenerationException; public void writeEndObject() throws IOException, JsonGenerationException; protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(SerializableString sstr) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char c) throws IOException, JsonGenerationException; private void writeRawLong(String text) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private void _writeString(String text) throws IOException, JsonGenerationException; private void _writeString2(final int len) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeSegment(int end) throws IOException, JsonGenerationException; private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException; private void _writeStringCustom(final int len) throws IOException, JsonGenerationException; private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException; private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private void _writeNull() throws IOException; private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException; private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException; private char[] _allocateEntityBuffer(); protected void _flushBuffer() throws IOException; int SHORT_WRITE=Optional[32]; char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; Writer _writer; char[] _outputBuffer; int _outputHead=Optional[0]; int _outputTail=Optional[0]; int _outputEnd; char[] _entityBuffer; SerializableString _currentEscape
 [LINE] public static int[] getInputCodeUtf8() { return sInputCodesUtf8; } [LINE] public static int[] getInputCodeUtf8() { [EOL]     return sInputCodesUtf8; [EOL] } public static int[] getInputCodeLatin1(); public static int[] getInputCodeUtf8(); public static int[] getInputCodeLatin1JsNames(); public static int[] getInputCodeUtf8JsNames(); public static int[] getInputCodeComment(); public static int[] get7BitOutputEscapes(); public static int charToHex(int ch); public static void appendQuoted(StringBuilder sb, String content); public static char[] copyHexChars(); public static byte[] copyHexBytes(); char[] HEX_CHARS=Optional["0123456789ABCDEF".toCharArray()]; byte[] HEX_BYTES; int[] sInputCodes; int[] sInputCodesUtf8; int[] sInputCodesJsNames; int[] sInputCodesUtf8JsNames; int[] sInputCodesComment=Optional[new int[256]]; int[] sOutputEscapes128; int[] sHexValues=Optional[new int[128]]
 [LINE] public static int[] getInputCodeComment() { return sInputCodesComment; } [LINE] public static int[] getInputCodeComment() { [EOL]     return sInputCodesComment; [EOL] } public static int[] getInputCodeLatin1(); public static int[] getInputCodeUtf8(); public static int[] getInputCodeLatin1JsNames(); public static int[] getInputCodeUtf8JsNames(); public static int[] getInputCodeComment(); public static int[] get7BitOutputEscapes(); public static int charToHex(int ch); public static void appendQuoted(StringBuilder sb, String content); public static char[] copyHexChars(); public static byte[] copyHexBytes(); char[] HEX_CHARS=Optional["0123456789ABCDEF".toCharArray()]; byte[] HEX_BYTES; int[] sInputCodes; int[] sInputCodesUtf8; int[] sInputCodesJsNames; int[] sInputCodesUtf8JsNames; int[] sInputCodesComment=Optional[new int[256]]; int[] sOutputEscapes128; int[] sHexValues=Optional[new int[128]]
 [LINE] public static int charToHex(int ch) [LINE] public static int charToHex(int ch) { [EOL]     return (ch > 127) ? -1 : sHexValues[ch]; [EOL] } public static int[] getInputCodeLatin1(); public static int[] getInputCodeUtf8(); public static int[] getInputCodeLatin1JsNames(); public static int[] getInputCodeUtf8JsNames(); public static int[] getInputCodeComment(); public static int[] get7BitOutputEscapes(); public static int charToHex(int ch); public static void appendQuoted(StringBuilder sb, String content); public static char[] copyHexChars(); public static byte[] copyHexBytes(); char[] HEX_CHARS=Optional["0123456789ABCDEF".toCharArray()]; byte[] HEX_BYTES; int[] sInputCodes; int[] sInputCodesUtf8; int[] sInputCodesJsNames; int[] sInputCodesUtf8JsNames; int[] sInputCodesComment=Optional[new int[256]]; int[] sOutputEscapes128; int[] sHexValues=Optional[new int[128]]
 [LINE] return (ch > 127) ? -1 : sHexValues[ch]; [LINE] public static int charToHex(int ch) { [EOL]     return (ch > 127) ? -1 : sHexValues[ch]; [EOL] } public static int[] getInputCodeLatin1(); public static int[] getInputCodeUtf8(); public static int[] getInputCodeLatin1JsNames(); public static int[] getInputCodeUtf8JsNames(); public static int[] getInputCodeComment(); public static int[] get7BitOutputEscapes(); public static int charToHex(int ch); public static void appendQuoted(StringBuilder sb, String content); public static char[] copyHexChars(); public static byte[] copyHexBytes(); char[] HEX_CHARS=Optional["0123456789ABCDEF".toCharArray()]; byte[] HEX_BYTES; int[] sInputCodes; int[] sInputCodesUtf8; int[] sInputCodesJsNames; int[] sInputCodesUtf8JsNames; int[] sInputCodesComment=Optional[new int[256]]; int[] sOutputEscapes128; int[] sHexValues=Optional[new int[128]]
 [LINE] if (outPtr >= outputBuffer.length) { [LINE] public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer[outPtr++] = c; [LINE] public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (++inPtr >= inputLen) { [LINE] public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] break outer_loop; [LINE] public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] @SuppressWarnings("resource") [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] ByteArrayBuilder byteBuilder = _byteBuilder; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (byteBuilder == null) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] int inputPtr = 0; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] int inputEnd = text.length(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] int outputPtr = 0; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] main_loop: [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] while (inputPtr < inputEnd) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] final int[] escCodes = CharTypes.get7BitOutputEscapes(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] inner_loop: // ASCII and escapes [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] int ch = text.charAt(inputPtr); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (ch > 0x7F || escCodes[ch] != 0) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] break inner_loop; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (outputPtr >= outputBuffer.length) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer[outputPtr++] = (byte) ch; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (++inputPtr >= inputEnd) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (outputPtr >= outputBuffer.length) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer = byteBuilder.finishCurrentSegment(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputPtr = 0; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] int ch = (int) text.charAt(inputPtr++); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (ch <= 0x7F) { // needs quoting [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] int escape = escCodes[ch]; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer = byteBuilder.getCurrentSegment(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] continue main_loop; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] } else if (ch <= 0x7FF) { // fine, just needs 2 byte output [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] ch = (0x80 | (ch & 0x3f)); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (outputPtr >= outputBuffer.length) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer = byteBuilder.finishCurrentSegment(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputPtr = 0; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] ch = (0x80 | (ch & 0x3f)); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (outputPtr >= outputBuffer.length) { [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer = byteBuilder.finishCurrentSegment(); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputPtr = 0; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] outputBuffer[outputPtr++] = (byte) ch; [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] return _byteBuilder.completeAndCoalesce(outputPtr); [LINE] @SuppressWarnings("resource") [EOL] public byte[] quoteAsUTF8(String text) { [EOL]     ByteArrayBuilder byteBuilder = _byteBuilder; [EOL]     if (byteBuilder == null) { [EOL]         _byteBuilder = byteBuilder = new ByteArrayBuilder(null); [EOL]     } [EOL]     int inputPtr = 0; [EOL]     int inputEnd = text.length(); [EOL]     int outputPtr = 0; [EOL]     byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment(); [EOL]     main_loop: while (inputPtr < inputEnd) { [EOL]         final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]         inner_loop: while (true) { [EOL]             int ch = text.charAt(inputPtr); [EOL]             if (ch > 0x7F || escCodes[ch] != 0) { [EOL]                 break inner_loop; [EOL]             } [EOL]             if (outputPtr >= outputBuffer.length) { [EOL]                 outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                 outputPtr = 0; [EOL]             } [EOL]             outputBuffer[outputPtr++] = (byte) ch; [EOL]             if (++inputPtr >= inputEnd) { [EOL]                 break main_loop; [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int ch = (int) text.charAt(inputPtr++); [EOL]         if (ch <= 0x7F) { [EOL]             int escape = escCodes[ch]; [EOL]             outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr); [EOL]             outputBuffer = byteBuilder.getCurrentSegment(); [EOL]             continue main_loop; [EOL]         } else if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             ch = (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             if (ch < SURR1_FIRST || ch > SURR2_LAST) { [EOL]                 outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } else { [EOL]                 if (ch > SURR1_LAST) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 if (inputPtr >= inputEnd) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 ch = _convertSurrogate(ch, text.charAt(inputPtr++)); [EOL]                 if (ch > 0x10FFFF) { [EOL]                     _illegalSurrogate(ch); [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f)); [EOL]                 if (outputPtr >= outputBuffer.length) { [EOL]                     outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]                     outputPtr = 0; [EOL]                 } [EOL]                 outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f)); [EOL]                 ch = (0x80 | (ch & 0x3f)); [EOL]             } [EOL]         } [EOL]         if (outputPtr >= outputBuffer.length) { [EOL]             outputBuffer = byteBuilder.finishCurrentSegment(); [EOL]             outputPtr = 0; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]     } [EOL]     return _byteBuilder.completeAndCoalesce(outputPtr); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.setCurrentSegmentLength(ptr); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append(INT_BACKSLASH); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (escCode < 0) { // standard escape [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append(INT_U); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] if (ch > 0xFF) { [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append(INT_0); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append(INT_0); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append(HEX_BYTES[ch >> 4]); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append(HEX_BYTES[ch & 0xF]); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] byteBuilder.append((byte) escCode); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] return byteBuilder.getCurrentSegmentLength(); [LINE] private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr) { [EOL]     byteBuilder.setCurrentSegmentLength(ptr); [EOL]     byteBuilder.append(INT_BACKSLASH); [EOL]     if (escCode < 0) { [EOL]         byteBuilder.append(INT_U); [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8); [EOL]             byteBuilder.append(HEX_BYTES[hi >> 4]); [EOL]             byteBuilder.append(HEX_BYTES[hi & 0xF]); [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             byteBuilder.append(INT_0); [EOL]             byteBuilder.append(INT_0); [EOL]         } [EOL]         byteBuilder.append(HEX_BYTES[ch >> 4]); [EOL]         byteBuilder.append(HEX_BYTES[ch & 0xF]); [EOL]     } else { [EOL]         byteBuilder.append((byte) escCode); [EOL]     } [EOL]     return byteBuilder.getCurrentSegmentLength(); [EOL] } public JsonStringEncoder(); public static JsonStringEncoder getInstance(); public char[] quoteAsString(String input); public byte[] quoteAsUTF8(String text); public byte[] encodeAsUTF8(String text); private int _appendNumericEscape(int value, char[] quoteBuffer); private int _appendNamedEscape(int escCode, char[] quoteBuffer); private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr); protected static int _convertSurrogate(int firstPart, int secondPart); protected static void _illegalSurrogate(int code); char[] HEX_CHARS=Optional[CharTypes.copyHexChars()]; byte[] HEX_BYTES=Optional[CharTypes.copyHexBytes()]; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int INT_BACKSLASH=Optional['\\']; int INT_U=Optional['u']; int INT_0=Optional['0']; ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder=Optional[new ThreadLocal<SoftReference<JsonStringEncoder>>()]; TextBuffer _textBuffer; ByteArrayBuilder _byteBuilder; char[] _quoteBuffer
 [LINE] @Override [LINE] @Override [EOL] public boolean hasCurrentToken() { [EOL]     return _currToken != null; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] return _currToken != null; [LINE] @Override [EOL] public boolean hasCurrentToken() { [EOL]     return _currToken != null; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] @Override [LINE] @Override [EOL] public void clearCurrentToken() { [EOL]     if (_currToken != null) { [EOL]         _lastClearedToken = _currToken; [EOL]         _currToken = null; [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] if (_currToken != null) { [LINE] @Override [EOL] public void clearCurrentToken() { [EOL]     if (_currToken != null) { [EOL]         _lastClearedToken = _currToken; [EOL]         _currToken = null; [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] _lastClearedToken = _currToken; [LINE] @Override [EOL] public void clearCurrentToken() { [EOL]     if (_currToken != null) { [EOL]         _lastClearedToken = _currToken; [EOL]         _currToken = null; [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] _currToken = null; [LINE] @Override [EOL] public void clearCurrentToken() { [EOL]     if (_currToken != null) { [EOL]         _lastClearedToken = _currToken; [EOL]         _currToken = null; [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] protected void _reportUnexpectedChar(int ch, String comment) [LINE] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { [EOL]     String msg = "Unexpected character (" + _getCharDesc(ch) + ")"; [EOL]     if (comment != null) { [EOL]         msg += ": " + comment; [EOL]     } [EOL]     _reportError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] String msg = "Unexpected character ("+_getCharDesc(ch)+")"; [LINE] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { [EOL]     String msg = "Unexpected character (" + _getCharDesc(ch) + ")"; [EOL]     if (comment != null) { [EOL]         msg += ": " + comment; [EOL]     } [EOL]     _reportError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] if (comment != null) { [LINE] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { [EOL]     String msg = "Unexpected character (" + _getCharDesc(ch) + ")"; [EOL]     if (comment != null) { [EOL]         msg += ": " + comment; [EOL]     } [EOL]     _reportError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] msg += ": "+comment; [LINE] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { [EOL]     String msg = "Unexpected character (" + _getCharDesc(ch) + ")"; [EOL]     if (comment != null) { [EOL]         msg += ": " + comment; [EOL]     } [EOL]     _reportError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] _reportError(msg); [LINE] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException { [EOL]     String msg = "Unexpected character (" + _getCharDesc(ch) + ")"; [EOL]     if (comment != null) { [EOL]         msg += ": " + comment; [EOL]     } [EOL]     _reportError(msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] protected void _reportInvalidEOF(String msg) [LINE] protected void _reportInvalidEOF(String msg) throws JsonParseException { [EOL]     _reportError("Unexpected end-of-input" + msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] _reportError("Unexpected end-of-input"+msg); [LINE] protected void _reportInvalidEOF(String msg) throws JsonParseException { [EOL]     _reportError("Unexpected end-of-input" + msg); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] protected void _throwUnquotedSpace(int i, String ctxtDesc) [LINE] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [EOL]         char c = (char) i; [EOL]         String msg = "Illegal unquoted character (" + _getCharDesc(c) + "): has to be escaped using backslash to be included in " + ctxtDesc; [EOL]         _reportError(msg); [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [LINE] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [EOL]         char c = (char) i; [EOL]         String msg = "Illegal unquoted character (" + _getCharDesc(c) + "): has to be escaped using backslash to be included in " + ctxtDesc; [EOL]         _reportError(msg); [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] char c = (char) i; [LINE] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [EOL]         char c = (char) i; [EOL]         String msg = "Illegal unquoted character (" + _getCharDesc(c) + "): has to be escaped using backslash to be included in " + ctxtDesc; [EOL]         _reportError(msg); [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] String msg = "Illegal unquoted character ("+_getCharDesc(c)+"): has to be escaped using backslash to be included in "+ctxtDesc; [LINE] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [EOL]         char c = (char) i; [EOL]         String msg = "Illegal unquoted character (" + _getCharDesc(c) + "): has to be escaped using backslash to be included in " + ctxtDesc; [EOL]         _reportError(msg); [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] _reportError(msg); [LINE] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) { [EOL]         char c = (char) i; [EOL]         String msg = "Illegal unquoted character (" + _getCharDesc(c) + "): has to be escaped using backslash to be included in " + ctxtDesc; [EOL]         _reportError(msg); [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] protected final static String _getCharDesc(int ch) [LINE] protected final static String _getCharDesc(int ch) { [EOL]     char c = (char) ch; [EOL]     if (Character.isISOControl(c)) { [EOL]         return "(CTRL-CHAR, code " + ch + ")"; [EOL]     } [EOL]     if (ch > 255) { [EOL]         return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL]     } [EOL]     return "'" + c + "' (code " + ch + ")"; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] char c = (char) ch; [LINE] protected final static String _getCharDesc(int ch) { [EOL]     char c = (char) ch; [EOL]     if (Character.isISOControl(c)) { [EOL]         return "(CTRL-CHAR, code " + ch + ")"; [EOL]     } [EOL]     if (ch > 255) { [EOL]         return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL]     } [EOL]     return "'" + c + "' (code " + ch + ")"; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] if (Character.isISOControl(c)) { [LINE] protected final static String _getCharDesc(int ch) { [EOL]     char c = (char) ch; [EOL]     if (Character.isISOControl(c)) { [EOL]         return "(CTRL-CHAR, code " + ch + ")"; [EOL]     } [EOL]     if (ch > 255) { [EOL]         return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL]     } [EOL]     return "'" + c + "' (code " + ch + ")"; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] return "(CTRL-CHAR, code "+ch+")"; [LINE] protected final static String _getCharDesc(int ch) { [EOL]     char c = (char) ch; [EOL]     if (Character.isISOControl(c)) { [EOL]         return "(CTRL-CHAR, code " + ch + ")"; [EOL]     } [EOL]     if (ch > 255) { [EOL]         return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL]     } [EOL]     return "'" + c + "' (code " + ch + ")"; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] if (ch > 255) { [LINE] protected final static String _getCharDesc(int ch) { [EOL]     char c = (char) ch; [EOL]     if (Character.isISOControl(c)) { [EOL]         return "(CTRL-CHAR, code " + ch + ")"; [EOL]     } [EOL]     if (ch > 255) { [EOL]         return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL]     } [EOL]     return "'" + c + "' (code " + ch + ")"; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] return "'"+c+"' (code "+ch+")"; [LINE] protected final static String _getCharDesc(int ch) { [EOL]     char c = (char) ch; [EOL]     if (Character.isISOControl(c)) { [EOL]         return "(CTRL-CHAR, code " + ch + ")"; [EOL]     } [EOL]     if (ch > 255) { [EOL]         return "'" + c + "' (code " + ch + " / 0x" + Integer.toHexString(ch) + ")"; [EOL]     } [EOL]     return "'" + c + "' (code " + ch + ")"; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}']; int INT_QUOTE=Optional['"']; int INT_BACKSLASH=Optional['\\']; int INT_SLASH=Optional['/']; int INT_COLON=Optional[':']; int INT_COMMA=Optional[',']; int INT_ASTERISK=Optional['*']; int INT_APOSTROPHE=Optional['\'']; int INT_b=Optional['b']; int INT_f=Optional['f']; int INT_n=Optional['n']; int INT_r=Optional['r']; int INT_t=Optional['t']; int INT_u=Optional['u']; JsonToken _currToken; JsonToken _lastClearedToken
 [LINE] protected JsonWriteContext(int type, JsonWriteContext parent) [LINE] protected JsonWriteContext(int type, JsonWriteContext parent) { [EOL]     super(); [EOL]     _type = type; [EOL]     _parent = parent; [EOL]     _index = -1; [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] super(); [LINE] protected JsonWriteContext(int type, JsonWriteContext parent) { [EOL]     super(); [EOL]     _type = type; [EOL]     _parent = parent; [EOL]     _index = -1; [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] _type = type; [LINE] protected JsonWriteContext(int type, JsonWriteContext parent) { [EOL]     super(); [EOL]     _type = type; [EOL]     _parent = parent; [EOL]     _index = -1; [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] _parent = parent; [LINE] protected JsonWriteContext(int type, JsonWriteContext parent) { [EOL]     super(); [EOL]     _type = type; [EOL]     _parent = parent; [EOL]     _index = -1; [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] _index = -1; [LINE] protected JsonWriteContext(int type, JsonWriteContext parent) { [EOL]     super(); [EOL]     _type = type; [EOL]     _parent = parent; [EOL]     _index = -1; [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] public static JsonWriteContext createRootContext() [LINE] public static JsonWriteContext createRootContext() { [EOL]     return new JsonWriteContext(TYPE_ROOT, null); [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] return new JsonWriteContext(TYPE_ROOT, null); [LINE] public static JsonWriteContext createRootContext() { [EOL]     return new JsonWriteContext(TYPE_ROOT, null); [EOL] } protected JsonWriteContext(int type, JsonWriteContext parent); public static JsonWriteContext createRootContext(); private JsonWriteContext reset(int type); public final JsonWriteContext createChildArrayContext(); public final JsonWriteContext createChildObjectContext(); public final JsonWriteContext getParent(); public final String getCurrentName(); public final int writeFieldName(String name); public final int writeValue(); protected final void appendDesc(StringBuilder sb); public final String toString(); int STATUS_OK_AS_IS=Optional[0]; int STATUS_OK_AFTER_COMMA=Optional[1]; int STATUS_OK_AFTER_COLON=Optional[2]; int STATUS_OK_AFTER_SPACE=Optional[3]; int STATUS_EXPECT_VALUE=Optional[4]; int STATUS_EXPECT_NAME=Optional[5]; JsonWriteContext _parent; String _currentName; JsonWriteContext _child=Optional[null]
 [LINE] public JsonFactory copy() [LINE] public JsonFactory copy() { [EOL]     _checkInvalidCopy(JsonFactory.class); [EOL]     return new JsonFactory(this, null); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] _checkInvalidCopy(JsonFactory.class); [LINE] public JsonFactory copy() { [EOL]     _checkInvalidCopy(JsonFactory.class); [EOL]     return new JsonFactory(this, null); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return new JsonFactory(this, null); [LINE] public JsonFactory copy() { [EOL]     _checkInvalidCopy(JsonFactory.class); [EOL]     return new JsonFactory(this, null); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] protected void _checkInvalidCopy(Class<?> exp) [LINE] protected void _checkInvalidCopy(Class<?> exp) { [EOL]     if (getClass() != exp) { [EOL]         throw new IllegalStateException("Failed copy(): " + getClass().getName() + " (version: " + version() + ") does not override copy(); it has to"); [EOL]     } [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] if (getClass() != exp) { [LINE] protected void _checkInvalidCopy(Class<?> exp) { [EOL]     if (getClass() != exp) { [EOL]         throw new IllegalStateException("Failed copy(): " + getClass().getName() + " (version: " + version() + ") does not override copy(); it has to"); [EOL]     } [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public String getFormatName() [LINE] public String getFormatName() { [EOL]     if (getClass() == JsonFactory.class) { [EOL]         return FORMAT_NAME_JSON; [EOL]     } [EOL]     return null; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] if (getClass() == JsonFactory.class) { [LINE] public String getFormatName() { [EOL]     if (getClass() == JsonFactory.class) { [EOL]         return FORMAT_NAME_JSON; [EOL]     } [EOL]     return null; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return FORMAT_NAME_JSON; [LINE] public String getFormatName() { [EOL]     if (getClass() == JsonFactory.class) { [EOL]         return FORMAT_NAME_JSON; [EOL]     } [EOL]     return null; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public MatchStrength hasFormat(InputAccessor acc) throws IOException [LINE] public MatchStrength hasFormat(InputAccessor acc) throws IOException { [EOL]     if (getClass() == JsonFactory.class) { [EOL]         return hasJSONFormat(acc); [EOL]     } [EOL]     return null; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] if (getClass() == JsonFactory.class) { [LINE] public MatchStrength hasFormat(InputAccessor acc) throws IOException { [EOL]     if (getClass() == JsonFactory.class) { [EOL]         return hasJSONFormat(acc); [EOL]     } [EOL]     return null; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return hasJSONFormat(acc); [LINE] public MatchStrength hasFormat(InputAccessor acc) throws IOException { [EOL]     if (getClass() == JsonFactory.class) { [EOL]         return hasJSONFormat(acc); [EOL]     } [EOL]     return null; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException [LINE] protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     return ByteSourceJsonBootstrapper.hasJSONFormat(acc); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return ByteSourceJsonBootstrapper.hasJSONFormat(acc); [LINE] protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     return ByteSourceJsonBootstrapper.hasJSONFormat(acc); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] @Override [LINE] @Override [EOL] public Version version() { [EOL]     return PackageVersion.VERSION; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return PackageVersion.VERSION; [LINE] @Override [EOL] public Version version() { [EOL]     return PackageVersion.VERSION; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public JsonFactory enable(JsonParser.Feature f) { [LINE] public JsonFactory enable(JsonParser.Feature f) { [EOL]     _parserFeatures |= f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] _parserFeatures |= f.getMask(); [LINE] public JsonFactory enable(JsonParser.Feature f) { [EOL]     _parserFeatures |= f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return this; [LINE] public JsonFactory enable(JsonParser.Feature f) { [EOL]     _parserFeatures |= f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public final boolean isEnabled(JsonParser.Feature f) { [LINE] public final boolean isEnabled(JsonParser.Feature f) { [EOL]     return (_parserFeatures & f.getMask()) != 0; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return (_parserFeatures & f.getMask()) != 0; [LINE] public final boolean isEnabled(JsonParser.Feature f) { [EOL]     return (_parserFeatures & f.getMask()) != 0; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public final JsonFactory configure(JsonGenerator.Feature f, boolean state) { [LINE] public final JsonFactory configure(JsonGenerator.Feature f, boolean state) { [EOL]     return state ? enable(f) : disable(f); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return state ? enable(f) : disable(f); [LINE] public final JsonFactory configure(JsonGenerator.Feature f, boolean state) { [EOL]     return state ? enable(f) : disable(f); [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public JsonFactory enable(JsonGenerator.Feature f) { [LINE] public JsonFactory enable(JsonGenerator.Feature f) { [EOL]     _generatorFeatures |= f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] _generatorFeatures |= f.getMask(); [LINE] public JsonFactory enable(JsonGenerator.Feature f) { [EOL]     _generatorFeatures |= f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return this; [LINE] public JsonFactory enable(JsonGenerator.Feature f) { [EOL]     _generatorFeatures |= f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public JsonFactory disable(JsonGenerator.Feature f) { [LINE] public JsonFactory disable(JsonGenerator.Feature f) { [EOL]     _generatorFeatures &= ~f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] _generatorFeatures &= ~f.getMask(); [LINE] public JsonFactory disable(JsonGenerator.Feature f) { [EOL]     _generatorFeatures &= ~f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return this; [LINE] public JsonFactory disable(JsonGenerator.Feature f) { [EOL]     _generatorFeatures &= ~f.getMask(); [EOL]     return this; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] public final boolean isEnabled(JsonGenerator.Feature f) { [LINE] public final boolean isEnabled(JsonGenerator.Feature f) { [EOL]     return (_generatorFeatures & f.getMask()) != 0; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] return (_generatorFeatures & f.getMask()) != 0; [LINE] public final boolean isEnabled(JsonGenerator.Feature f) { [EOL]     return (_generatorFeatures & f.getMask()) != 0; [EOL] } private Feature(boolean defaultState); public JsonFactory(); public JsonFactory(ObjectCodec oc); protected JsonFactory(JsonFactory src, ObjectCodec codec); public static int collectDefaults(); public boolean enabledByDefault(); public boolean enabledIn(int flags); public int getMask(); public JsonFactory copy(); protected void _checkInvalidCopy(Class<?> exp); protected Object readResolve(); public boolean requiresPropertyOrdering(); public boolean canUseSchema(FormatSchema schema); public String getFormatName(); public MatchStrength hasFormat(InputAccessor acc) throws IOException; public boolean requiresCustomCodec(); protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException; public Version version(); public final JsonFactory configure(JsonFactory.Feature f, boolean state); public JsonFactory enable(JsonFactory.Feature f); public JsonFactory disable(JsonFactory.Feature f); public final boolean isEnabled(JsonFactory.Feature f); public final JsonFactory configure(JsonParser.Feature f, boolean state); public JsonFactory enable(JsonParser.Feature f); public JsonFactory disable(JsonParser.Feature f); public final boolean isEnabled(JsonParser.Feature f); public InputDecorator getInputDecorator(); public JsonFactory setInputDecorator(InputDecorator d); public final JsonFactory configure(JsonGenerator.Feature f, boolean state); public JsonFactory enable(JsonGenerator.Feature f); public JsonFactory disable(JsonGenerator.Feature f); public final boolean isEnabled(JsonGenerator.Feature f); public CharacterEscapes getCharacterEscapes(); public JsonFactory setCharacterEscapes(CharacterEscapes esc); public OutputDecorator getOutputDecorator(); public JsonFactory setOutputDecorator(OutputDecorator d); public JsonFactory setRootValueSeparator(String sep); public String getRootValueSeparator(); public JsonFactory setCodec(ObjectCodec oc); public ObjectCodec getCodec(); public JsonParser createParser(File f) throws IOException, JsonParseException; public JsonParser createParser(URL url) throws IOException, JsonParseException; public JsonParser createParser(InputStream in) throws IOException, JsonParseException; public JsonParser createParser(Reader r) throws IOException, JsonParseException; public JsonParser createParser(byte[] data) throws IOException, JsonParseException; public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createParser(String content) throws IOException, JsonParseException; public JsonParser createJsonParser(File f) throws IOException, JsonParseException; public JsonParser createJsonParser(URL url) throws IOException, JsonParseException; public JsonParser createJsonParser(InputStream in) throws IOException, JsonParseException; public JsonParser createJsonParser(Reader r) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data) throws IOException, JsonParseException; public JsonParser createJsonParser(byte[] data, int offset, int len) throws IOException, JsonParseException; public JsonParser createJsonParser(String content) throws IOException, JsonParseException; public JsonGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createGenerator(OutputStream out) throws IOException; public JsonGenerator createGenerator(Writer out) throws IOException; public JsonGenerator createGenerator(File f, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc) throws IOException; public JsonGenerator createJsonGenerator(Writer out) throws IOException; public JsonGenerator createJsonGenerator(OutputStream out) throws IOException; public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException; protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(InputStream in, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(Reader r, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException; protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException; protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt) throws IOException; protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException; protected IOContext _createContext(Object srcRef, boolean resourceManaged); public BufferRecycler _getBufferRecycler(); protected InputStream _optimizedStreamFromURL(URL url) throws IOException; long serialVersionUID=Optional[3194418244231611666L]; String FORMAT_NAME_JSON=Optional["JSON"]; int DEFAULT_FACTORY_FEATURE_FLAGS=Optional[JsonFactory.Feature.collectDefaults()]; int DEFAULT_PARSER_FEATURE_FLAGS=Optional[JsonParser.Feature.collectDefaults()]; int DEFAULT_GENERATOR_FEATURE_FLAGS=Optional[JsonGenerator.Feature.collectDefaults()]; SerializableString DEFAULT_ROOT_VALUE_SEPARATOR=Optional[DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR]; ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef=Optional[new ThreadLocal<SoftReference<BufferRecycler>>()]; CharsToNameCanonicalizer _rootCharSymbols=Optional[CharsToNameCanonicalizer.createRoot()]; BytesToNameCanonicalizer _rootByteSymbols=Optional[BytesToNameCanonicalizer.createRoot()]; ObjectCodec _objectCodec; int _factoryFeatures=Optional[DEFAULT_FACTORY_FEATURE_FLAGS]; int _parserFeatures=Optional[DEFAULT_PARSER_FEATURE_FLAGS]; int _generatorFeatures=Optional[DEFAULT_GENERATOR_FEATURE_FLAGS]; CharacterEscapes _characterEscapes; InputDecorator _inputDecorator; OutputDecorator _outputDecorator; SerializableString _rootValueSeparator=Optional[DEFAULT_ROOT_VALUE_SEPARATOR]
 [LINE] Name2(String name, int hash, int quad1, int quad2) [LINE] Name2(String name, int hash, int quad1, int quad2) { [EOL]     super(name, hash); [EOL]     mQuad1 = quad1; [EOL]     mQuad2 = quad2; [EOL] }  Name2(String name, int hash, int quad1, int quad2); public boolean equals(int quad); public boolean equals(int quad1, int quad2); public boolean equals(int[] quads, int qlen); int mQuad1; int mQuad2
 [LINE] super(name, hash); [LINE] Name2(String name, int hash, int quad1, int quad2) { [EOL]     super(name, hash); [EOL]     mQuad1 = quad1; [EOL]     mQuad2 = quad2; [EOL] }  Name2(String name, int hash, int quad1, int quad2); public boolean equals(int quad); public boolean equals(int quad1, int quad2); public boolean equals(int[] quads, int qlen); int mQuad1; int mQuad2
 [LINE] mQuad1 = quad1; [LINE] Name2(String name, int hash, int quad1, int quad2) { [EOL]     super(name, hash); [EOL]     mQuad1 = quad1; [EOL]     mQuad2 = quad2; [EOL] }  Name2(String name, int hash, int quad1, int quad2); public boolean equals(int quad); public boolean equals(int quad1, int quad2); public boolean equals(int[] quads, int qlen); int mQuad1; int mQuad2
 [LINE] mQuad2 = quad2; [LINE] Name2(String name, int hash, int quad1, int quad2) { [EOL]     super(name, hash); [EOL]     mQuad1 = quad1; [EOL]     mQuad2 = quad2; [EOL] }  Name2(String name, int hash, int quad1, int quad2); public boolean equals(int quad); public boolean equals(int quad1, int quad2); public boolean equals(int[] quads, int qlen); int mQuad1; int mQuad2
