 [LINE] public GzipCompressorOutputStream( final OutputStream outputStream ) throws IOException { [LINE] public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException { [EOL]     out = new GZIPOutputStream(outputStream); [EOL] } public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; GZIPOutputStream out
 [LINE] out = new GZIPOutputStream(outputStream); [LINE] public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException { [EOL]     out = new GZIPOutputStream(outputStream); [EOL] } public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; GZIPOutputStream out
 [LINE] public void write(int b) throws IOException { [LINE] public void write(int b) throws IOException { [EOL]     out.write(b); [EOL] } public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; GZIPOutputStream out
 [LINE] out.write(b); [LINE] public void write(int b) throws IOException { [EOL]     out.write(b); [EOL] } public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; GZIPOutputStream out
 [LINE] public void close() throws IOException { [LINE] public void close() throws IOException { [EOL]     out.close(); [EOL] } public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; GZIPOutputStream out
 [LINE] out.close(); [LINE] public void close() throws IOException { [EOL]     out.close(); [EOL] } public GzipCompressorOutputStream(final OutputStream outputStream) throws IOException; public void write(int b) throws IOException; public void close() throws IOException; GZIPOutputStream out
 [LINE] public Object clone() { [LINE] public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException cnfe) { [EOL]         throw new RuntimeException(cnfe); [EOL]     } [EOL] } public ZipLong(long value); public ZipLong(byte[] bytes); public ZipLong(byte[] bytes, int offset); public byte[] getBytes(); public long getValue(); public static byte[] getBytes(long value); public static long getValue(byte[] bytes, int offset); public static long getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int WORD=Optional[4]; int BYTE_MASK=Optional[0xFF]; int BYTE_1=Optional[1]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int BYTE_2=Optional[2]; int BYTE_2_MASK=Optional[0xFF0000]; int BYTE_2_SHIFT=Optional[16]; int BYTE_3=Optional[3]; long BYTE_3_MASK=Optional[0xFF000000L]; int BYTE_3_SHIFT=Optional[24]; long value
 [LINE] try { [LINE] public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException cnfe) { [EOL]         throw new RuntimeException(cnfe); [EOL]     } [EOL] } public ZipLong(long value); public ZipLong(byte[] bytes); public ZipLong(byte[] bytes, int offset); public byte[] getBytes(); public long getValue(); public static byte[] getBytes(long value); public static long getValue(byte[] bytes, int offset); public static long getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int WORD=Optional[4]; int BYTE_MASK=Optional[0xFF]; int BYTE_1=Optional[1]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int BYTE_2=Optional[2]; int BYTE_2_MASK=Optional[0xFF0000]; int BYTE_2_SHIFT=Optional[16]; int BYTE_3=Optional[3]; long BYTE_3_MASK=Optional[0xFF000000L]; int BYTE_3_SHIFT=Optional[24]; long value
 [LINE] return super.clone(); [LINE] public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException cnfe) { [EOL]         throw new RuntimeException(cnfe); [EOL]     } [EOL] } public ZipLong(long value); public ZipLong(byte[] bytes); public ZipLong(byte[] bytes, int offset); public byte[] getBytes(); public long getValue(); public static byte[] getBytes(long value); public static long getValue(byte[] bytes, int offset); public static long getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int WORD=Optional[4]; int BYTE_MASK=Optional[0xFF]; int BYTE_1=Optional[1]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int BYTE_2=Optional[2]; int BYTE_2_MASK=Optional[0xFF0000]; int BYTE_2_SHIFT=Optional[16]; int BYTE_3=Optional[3]; long BYTE_3_MASK=Optional[0xFF000000L]; int BYTE_3_SHIFT=Optional[24]; long value
 [LINE] public ZipShort (int value) { [LINE] public ZipShort(int value) { [EOL]     this.value = value; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] this.value = value; [LINE] public ZipShort(int value) { [EOL]     this.value = value; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] public byte[] getBytes() { [LINE] public byte[] getBytes() { [EOL]     byte[] result = new byte[2]; [EOL]     result[0] = (byte) (value & BYTE_MASK); [EOL]     result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [EOL]     return result; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] byte[] result = new byte[2]; [LINE] public byte[] getBytes() { [EOL]     byte[] result = new byte[2]; [EOL]     result[0] = (byte) (value & BYTE_MASK); [EOL]     result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [EOL]     return result; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] result[0] = (byte) (value & BYTE_MASK); [LINE] public byte[] getBytes() { [EOL]     byte[] result = new byte[2]; [EOL]     result[0] = (byte) (value & BYTE_MASK); [EOL]     result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [EOL]     return result; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [LINE] public byte[] getBytes() { [EOL]     byte[] result = new byte[2]; [EOL]     result[0] = (byte) (value & BYTE_MASK); [EOL]     result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [EOL]     return result; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] return result; [LINE] public byte[] getBytes() { [EOL]     byte[] result = new byte[2]; [EOL]     result[0] = (byte) (value & BYTE_MASK); [EOL]     result[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT); [EOL]     return result; [EOL] } public ZipShort(int value); public ZipShort(byte[] bytes); public ZipShort(byte[] bytes, int offset); public byte[] getBytes(); public int getValue(); public static byte[] getBytes(int value); public static int getValue(byte[] bytes, int offset); public static int getValue(byte[] bytes); public boolean equals(Object o); public int hashCode(); public Object clone(); int BYTE_MASK=Optional[0xFF]; int BYTE_1_MASK=Optional[0xFF00]; int BYTE_1_SHIFT=Optional[8]; int value
 [LINE] return new ArArchiveInputStream(in); [LINE] public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException { [EOL]     if (archiverName == null || in == null) { [EOL]         throw new IllegalArgumentException("Archivername must not be null."); [EOL]     } [EOL]     if ("ar".equalsIgnoreCase(archiverName)) { [EOL]         return new ArArchiveInputStream(in); [EOL]     } else if ("zip".equalsIgnoreCase(archiverName)) { [EOL]         return new ZipArchiveInputStream(in); [EOL]     } else if ("tar".equalsIgnoreCase(archiverName)) { [EOL]         return new TarArchiveInputStream(in); [EOL]     } else if ("jar".equalsIgnoreCase(archiverName)) { [EOL]         return new JarArchiveInputStream(in); [EOL]     } else if ("cpio".equalsIgnoreCase(archiverName)) { [EOL]         return new CpioArchiveInputStream(in); [EOL]     } [EOL]     throw new ArchiveException("Archiver: " + archiverName + " not found."); [EOL] } public ArchiveInputStream createArchiveInputStream(final String archiverName, final InputStream in) throws ArchiveException; public ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out) throws ArchiveException; public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException
 [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] this.encoding = encoding; [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] this.useUnicodeExtraFields = useUnicodeExtraFields; [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive = new RandomAccessFile(f, "r"); [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] boolean success = false; [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] try { [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] Map entriesWithoutEFS = populateFromCentralDirectory(); [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] resolveLocalFileHeaderData(entriesWithoutEFS); [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] success = true; [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (!success) { [LINE] public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] public void close() throws IOException { [LINE] public void close() throws IOException { [EOL]     archive.close(); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.close(); [LINE] public void close() throws IOException { [EOL]     archive.close(); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] public static void closeQuietly(ZipFile zipfile) { [LINE] public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (zipfile != null) { [LINE] public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] try { [LINE] public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] zipfile.close(); [LINE] public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] public Enumeration getEntries() { [LINE] public Enumeration getEntries() { [EOL]     return Collections.enumeration(entries.keySet()); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] return Collections.enumeration(entries.keySet()); [LINE] public Enumeration getEntries() { [EOL]     return Collections.enumeration(entries.keySet()); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] private Map populateFromCentralDirectory() [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] HashMap noEFS = new HashMap(); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] positionAtCentralDirectory(); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] cfh = new byte[CFH_LEN]; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] signatureBytes = new byte[WORD]; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(signatureBytes); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] long sig = ZipLong.getValue(signatureBytes); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (sig != cfhSig && startsWithLocalFileHeader()) { [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] while (sig == cfhSig) { [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(cfh); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int off = 0; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ZipArchiveEntry ze = new ZipArchiveEntry(); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int versionMadeBy = ZipShort.getValue(cfh, off); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; // skip version info [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] final int generalPurposeFlag = ZipShort.getValue(cfh, off); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] final boolean hasEFS = [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] final ZipEncoding entryEncoding = [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setMethod(ZipShort.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setTime(time); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += WORD; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setCrc(ZipLong.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += WORD; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setCompressedSize(ZipLong.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += WORD; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setSize(ZipLong.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += WORD; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int fileNameLen = ZipShort.getValue(cfh, off); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int extraLen = ZipShort.getValue(cfh, off); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int commentLen = ZipShort.getValue(cfh, off); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; // disk number [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += SHORT; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] off += WORD; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] fileName = new byte[fileNameLen]; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(fileName); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setName(entryEncoding.decode(fileName)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] OffsetEntry offset = new OffsetEntry(); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] offset.headerOffset = ZipLong.getValue(cfh, off); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] entries.put(ze, offset); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] nameMap.put(ze.getName(), ze); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] cdExtraData = new byte[extraLen]; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(cdExtraData); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setCentralDirectoryExtra(cdExtraData); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] comment = new byte[commentLen]; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(comment); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setComment(entryEncoding.decode(comment)); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(signatureBytes); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] sig = ZipLong.getValue(signatureBytes); [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (!hasEFS && useUnicodeExtraFields) { [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] return noEFS; [LINE] private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] private void positionAtCentralDirectory() [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] boolean found = false; [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] long off = archive.length() - MIN_EOCD_SIZE; [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (off >= 0) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.seek(off); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int curr = archive.read(); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] while (off >= stopSearching && curr != -1) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (curr == sig[POS_0]) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] curr = archive.read(); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (curr == sig[POS_1]) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] curr = archive.read(); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (curr == sig[POS_2]) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] curr = archive.read(); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (curr == sig[POS_3]) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] found = true; [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] break; [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (!found) { [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.seek(off + CFD_LOCATOR_OFFSET); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] cfdOffset = new byte[WORD]; [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(cfdOffset); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.seek(ZipLong.getValue(cfdOffset)); [LINE] private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] Enumeration e = getEntries(); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] while (e.hasMoreElements()) { [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] long offset = offsetEntry.headerOffset; [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] b = new byte[SHORT]; [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(b); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int fileNameLen = ZipShort.getValue(b); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(b); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int extraFieldLen = ZipShort.getValue(b); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int lenToSkip = fileNameLen; [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] while (lenToSkip > 0) { [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] int skipped = archive.skipBytes(lenToSkip); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (skipped <= 0) { [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] lenToSkip -= skipped; [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] byte[] localExtraData = new byte[extraFieldLen]; [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] archive.readFully(localExtraData); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] ze.setExtra(localExtraData); [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] if (entriesWithoutEFS.containsKey(ze)) { [LINE] private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } public ZipFile(File f) throws IOException; public ZipFile(String name) throws IOException; public ZipFile(String name, String encoding) throws IOException; public ZipFile(File f, String encoding) throws IOException; public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException;  BoundedInputStream(long start, long remaining); private NameAndComment(byte[] name, byte[] comment); public String getEncoding(); public void close() throws IOException; public static void closeQuietly(ZipFile zipfile); public Enumeration getEntries(); public ZipArchiveEntry getEntry(String name); public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException; private Map populateFromCentralDirectory() throws IOException; private void positionAtCentralDirectory() throws IOException; private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException; private boolean startsWithLocalFileHeader() throws IOException; private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc); private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig); public int read() throws IOException; public int read(byte[] b, int off, int len) throws IOException;  void addDummy(); int HASH_SIZE=Optional[509]; int SHORT=Optional[2]; int WORD=Optional[4]; int NIBLET_MASK=Optional[0x0f]; int BYTE_SHIFT=Optional[8]; int POS_0=Optional[0]; int POS_1=Optional[1]; int POS_2=Optional[2]; int POS_3=Optional[3]; Map entries=Optional[new HashMap(HASH_SIZE)]; Map nameMap=Optional[new HashMap(HASH_SIZE)]; String encoding; ZipEncoding zipEncoding; RandomAccessFile archive; boolean useUnicodeExtraFields; int CFH_LEN=Optional[/* version made by                 */; SHORT + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD + /* filename length                 */; SHORT + /* extra field length              */; SHORT + /* file comment length             */; SHORT + /* disk number start               */; SHORT + /* internal file attributes        */; SHORT + /* external file attributes        */; WORD + /* relative offset of local header */; WORD]; int MIN_EOCD_SIZE=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD + /* offset of start of central      */; /* directory with respect to       */; /* the starting disk number        */; WORD + /* zipfile comment length          */; SHORT]; int MAX_EOCD_SIZE=Optional[MIN_EOCD_SIZE + /* maximum length of zipfile comment */; 0xFFFF]; int CFD_LOCATOR_OFFSET=Optional[/* end of central dir signature    */; WORD + /* number of this disk             */; SHORT + /* number of the disk with the     */; /* start of the central directory  */; SHORT + /* total number of entries in      */; /* the central dir on this disk    */; SHORT + /* total number of entries in      */; /* the central dir                 */; SHORT + /* size of the central directory   */; WORD]; long LFH_OFFSET_FOR_FILENAME_LENGTH=Optional[/* local file header signature     */; WORD + /* version needed to extract       */; SHORT + /* general purpose bit flag        */; SHORT + /* compression method              */; SHORT + /* last mod file time              */; SHORT + /* last mod file date              */; SHORT + /* crc-32                          */; WORD + /* compressed size                 */; WORD + /* uncompressed size               */; WORD]
 [LINE] protected AbstractUnicodeExtraField() { [LINE] protected AbstractUnicodeExtraField() { [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] CRC32 crc32 = new CRC32(); [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] crc32.update(bytes, off, len); [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] nameCRC32 = crc32.getValue(); [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] try { [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] unicodeName = text.getBytes("UTF-8"); [LINE] protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len) { [EOL]     CRC32 crc32 = new CRC32(); [EOL]     crc32.update(bytes, off, len); [EOL]     nameCRC32 = crc32.getValue(); [EOL]     try { [EOL]         unicodeName = text.getBytes("UTF-8"); [EOL]     } catch (UnsupportedEncodingException e) { [EOL]         throw new RuntimeException("FATAL: UTF-8 encoding not supported.", e); [EOL]     } [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] private void assembleData() { [LINE] private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] if (unicodeName == null) { [LINE] private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] data = new byte[5 + unicodeName.length]; [LINE] private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] data[0] = 0x01; [LINE] private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [LINE] private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [LINE] private void assembleData() { [EOL]     if (unicodeName == null) { [EOL]         return; [EOL]     } [EOL]     data = new byte[5 + unicodeName.length]; [EOL]     data[0] = 0x01; [EOL]     System.arraycopy(ZipLong.getBytes(nameCRC32), 0, data, 1, 4); [EOL]     System.arraycopy(unicodeName, 0, data, 5, unicodeName.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public long getNameCRC32() { [LINE] public long getNameCRC32() { [EOL]     return nameCRC32; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] return nameCRC32; [LINE] public long getNameCRC32() { [EOL]     return nameCRC32; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public byte[] getUnicodeName() { [LINE] public byte[] getUnicodeName() { [EOL]     return unicodeName; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] return unicodeName; [LINE] public byte[] getUnicodeName() { [EOL]     return unicodeName; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public byte[] getCentralDirectoryData() { [LINE] public byte[] getCentralDirectoryData() { [EOL]     if (data == null) { [EOL]         this.assembleData(); [EOL]     } [EOL]     return data; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] if (data == null) { [LINE] public byte[] getCentralDirectoryData() { [EOL]     if (data == null) { [EOL]         this.assembleData(); [EOL]     } [EOL]     return data; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] this.assembleData(); [LINE] public byte[] getCentralDirectoryData() { [EOL]     if (data == null) { [EOL]         this.assembleData(); [EOL]     } [EOL]     return data; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] return data; [LINE] public byte[] getCentralDirectoryData() { [EOL]     if (data == null) { [EOL]         this.assembleData(); [EOL]     } [EOL]     return data; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public ZipShort getCentralDirectoryLength() { [LINE] public ZipShort getCentralDirectoryLength() { [EOL]     if (data == null) { [EOL]         assembleData(); [EOL]     } [EOL]     return new ZipShort(data.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] if (data == null) { [LINE] public ZipShort getCentralDirectoryLength() { [EOL]     if (data == null) { [EOL]         assembleData(); [EOL]     } [EOL]     return new ZipShort(data.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] assembleData(); [LINE] public ZipShort getCentralDirectoryLength() { [EOL]     if (data == null) { [EOL]         assembleData(); [EOL]     } [EOL]     return new ZipShort(data.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] return new ZipShort(data.length); [LINE] public ZipShort getCentralDirectoryLength() { [EOL]     if (data == null) { [EOL]         assembleData(); [EOL]     } [EOL]     return new ZipShort(data.length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public byte[] getLocalFileDataData() { [LINE] public byte[] getLocalFileDataData() { [EOL]     return getCentralDirectoryData(); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] return getCentralDirectoryData(); [LINE] public byte[] getLocalFileDataData() { [EOL]     return getCentralDirectoryData(); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public ZipShort getLocalFileDataLength() { [LINE] public ZipShort getLocalFileDataLength() { [EOL]     return getCentralDirectoryLength(); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] return getCentralDirectoryLength(); [LINE] public ZipShort getLocalFileDataLength() { [EOL]     return getCentralDirectoryLength(); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] if (length < 5) { [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] int version = buffer[offset]; [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] if (version != 0x01) { [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] nameCRC32 = ZipLong.getValue(buffer, offset + 1); [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] unicodeName = new byte[length - 5]; [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] data = null; [LINE] public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     if (length < 5) { [EOL]         throw new ZipException("UniCode path extra data must have at least" + " 5 bytes."); [EOL]     } [EOL]     int version = buffer[offset]; [EOL]     if (version != 0x01) { [EOL]         throw new ZipException("Unsupported version [" + version + "] for UniCode path extra data."); [EOL]     } [EOL]     nameCRC32 = ZipLong.getValue(buffer, offset + 1); [EOL]     unicodeName = new byte[length - 5]; [EOL]     System.arraycopy(buffer, offset + 5, unicodeName, 0, length - 5); [EOL]     data = null; [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public void parseFromCentralDirectoryData(byte[] buffer, int offset, [LINE] public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     parseFromLocalFileData(buffer, offset, length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] parseFromLocalFileData(buffer, offset, length); [LINE] public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException { [EOL]     parseFromLocalFileData(buffer, offset, length); [EOL] } protected AbstractUnicodeExtraField(); protected AbstractUnicodeExtraField(String text, byte[] bytes, int off, int len); protected AbstractUnicodeExtraField(String text, byte[] bytes); private void assembleData(); public long getNameCRC32(); public void setNameCRC32(long nameCRC32); public byte[] getUnicodeName(); public void setUnicodeName(byte[] unicodeName); public byte[] getCentralDirectoryData(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public ZipShort getLocalFileDataLength(); public void parseFromLocalFileData(byte[] buffer, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; long nameCRC32; byte[] unicodeName; byte[] data
 [LINE] public void removeExtraField(ZipShort type) { [LINE] public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] } public ZipArchiveEntry(String name); public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException; public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException; protected ZipArchiveEntry(); public Object clone(); public int getInternalAttributes(); public void setInternalAttributes(int value); public long getExternalAttributes(); public void setExternalAttributes(long value); public void setUnixMode(int mode); public int getUnixMode(); public int getPlatform(); protected void setPlatform(int platform); public void setExtraFields(ZipExtraField[] fields); public ZipExtraField[] getExtraFields(); public void addExtraField(ZipExtraField ze); public void addAsFirstExtraField(ZipExtraField ze); public void removeExtraField(ZipShort type); public ZipExtraField getExtraField(ZipShort type); public void setExtra(byte[] extra) throws RuntimeException; protected void setExtra(); public void setCentralDirectoryExtra(byte[] b); public byte[] getLocalFileDataExtra(); public byte[] getCentralDirectoryExtra(); public String getName(); public boolean isDirectory(); protected void setName(String name); public int hashCode(); private void mergeExtraFields(ZipExtraField[] f, boolean local) throws ZipException; int PLATFORM_UNIX=Optional[3]; int PLATFORM_FAT=Optional[0]; int SHORT_MASK=Optional[0xFFFF]; int SHORT_SHIFT=Optional[16]; int internalAttributes=Optional[0]; int platform=Optional[PLATFORM_FAT]; long externalAttributes=Optional[0]; LinkedHashMap extraFields=Optional[null]; String name=Optional[null]
 [LINE] if (extraFields == null) { [LINE] public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] } public ZipArchiveEntry(String name); public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException; public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException; protected ZipArchiveEntry(); public Object clone(); public int getInternalAttributes(); public void setInternalAttributes(int value); public long getExternalAttributes(); public void setExternalAttributes(long value); public void setUnixMode(int mode); public int getUnixMode(); public int getPlatform(); protected void setPlatform(int platform); public void setExtraFields(ZipExtraField[] fields); public ZipExtraField[] getExtraFields(); public void addExtraField(ZipExtraField ze); public void addAsFirstExtraField(ZipExtraField ze); public void removeExtraField(ZipShort type); public ZipExtraField getExtraField(ZipShort type); public void setExtra(byte[] extra) throws RuntimeException; protected void setExtra(); public void setCentralDirectoryExtra(byte[] b); public byte[] getLocalFileDataExtra(); public byte[] getCentralDirectoryExtra(); public String getName(); public boolean isDirectory(); protected void setName(String name); public int hashCode(); private void mergeExtraFields(ZipExtraField[] f, boolean local) throws ZipException; int PLATFORM_UNIX=Optional[3]; int PLATFORM_FAT=Optional[0]; int SHORT_MASK=Optional[0xFFFF]; int SHORT_SHIFT=Optional[16]; int internalAttributes=Optional[0]; int platform=Optional[PLATFORM_FAT]; long externalAttributes=Optional[0]; LinkedHashMap extraFields=Optional[null]; String name=Optional[null]
 [LINE] if (extraFields.remove(type) == null) { [LINE] public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] } public ZipArchiveEntry(String name); public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException; public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException; protected ZipArchiveEntry(); public Object clone(); public int getInternalAttributes(); public void setInternalAttributes(int value); public long getExternalAttributes(); public void setExternalAttributes(long value); public void setUnixMode(int mode); public int getUnixMode(); public int getPlatform(); protected void setPlatform(int platform); public void setExtraFields(ZipExtraField[] fields); public ZipExtraField[] getExtraFields(); public void addExtraField(ZipExtraField ze); public void addAsFirstExtraField(ZipExtraField ze); public void removeExtraField(ZipShort type); public ZipExtraField getExtraField(ZipShort type); public void setExtra(byte[] extra) throws RuntimeException; protected void setExtra(); public void setCentralDirectoryExtra(byte[] b); public byte[] getLocalFileDataExtra(); public byte[] getCentralDirectoryExtra(); public String getName(); public boolean isDirectory(); protected void setName(String name); public int hashCode(); private void mergeExtraFields(ZipExtraField[] f, boolean local) throws ZipException; int PLATFORM_UNIX=Optional[3]; int PLATFORM_FAT=Optional[0]; int SHORT_MASK=Optional[0xFFFF]; int SHORT_SHIFT=Optional[16]; int internalAttributes=Optional[0]; int platform=Optional[PLATFORM_FAT]; long externalAttributes=Optional[0]; LinkedHashMap extraFields=Optional[null]; String name=Optional[null]
 [LINE] throw new java.util.NoSuchElementException(); [LINE] public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] } public ZipArchiveEntry(String name); public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException; public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException; protected ZipArchiveEntry(); public Object clone(); public int getInternalAttributes(); public void setInternalAttributes(int value); public long getExternalAttributes(); public void setExternalAttributes(long value); public void setUnixMode(int mode); public int getUnixMode(); public int getPlatform(); protected void setPlatform(int platform); public void setExtraFields(ZipExtraField[] fields); public ZipExtraField[] getExtraFields(); public void addExtraField(ZipExtraField ze); public void addAsFirstExtraField(ZipExtraField ze); public void removeExtraField(ZipShort type); public ZipExtraField getExtraField(ZipShort type); public void setExtra(byte[] extra) throws RuntimeException; protected void setExtra(); public void setCentralDirectoryExtra(byte[] b); public byte[] getLocalFileDataExtra(); public byte[] getCentralDirectoryExtra(); public String getName(); public boolean isDirectory(); protected void setName(String name); public int hashCode(); private void mergeExtraFields(ZipExtraField[] f, boolean local) throws ZipException; int PLATFORM_UNIX=Optional[3]; int PLATFORM_FAT=Optional[0]; int SHORT_MASK=Optional[0xFFFF]; int SHORT_SHIFT=Optional[16]; int internalAttributes=Optional[0]; int platform=Optional[PLATFORM_FAT]; long externalAttributes=Optional[0]; LinkedHashMap extraFields=Optional[null]; String name=Optional[null]
 [LINE] setExtra(); [LINE] public void removeExtraField(ZipShort type) { [EOL]     if (extraFields == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     if (extraFields.remove(type) == null) { [EOL]         throw new java.util.NoSuchElementException(); [EOL]     } [EOL]     setExtra(); [EOL] } public ZipArchiveEntry(String name); public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException; public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException; protected ZipArchiveEntry(); public Object clone(); public int getInternalAttributes(); public void setInternalAttributes(int value); public long getExternalAttributes(); public void setExternalAttributes(long value); public void setUnixMode(int mode); public int getUnixMode(); public int getPlatform(); protected void setPlatform(int platform); public void setExtraFields(ZipExtraField[] fields); public ZipExtraField[] getExtraFields(); public void addExtraField(ZipExtraField ze); public void addAsFirstExtraField(ZipExtraField ze); public void removeExtraField(ZipShort type); public ZipExtraField getExtraField(ZipShort type); public void setExtra(byte[] extra) throws RuntimeException; protected void setExtra(); public void setCentralDirectoryExtra(byte[] b); public byte[] getLocalFileDataExtra(); public byte[] getCentralDirectoryExtra(); public String getName(); public boolean isDirectory(); protected void setName(String name); public int hashCode(); private void mergeExtraFields(ZipExtraField[] f, boolean local) throws ZipException; int PLATFORM_UNIX=Optional[3]; int PLATFORM_FAT=Optional[0]; int SHORT_MASK=Optional[0xFFFF]; int SHORT_SHIFT=Optional[16]; int internalAttributes=Optional[0]; int platform=Optional[PLATFORM_FAT]; long externalAttributes=Optional[0]; LinkedHashMap extraFields=Optional[null]; String name=Optional[null]
 [LINE] public FallbackZipEncoding(String charset) { [LINE] public FallbackZipEncoding(String charset) { [EOL]     this.charset = charset; [EOL] } public FallbackZipEncoding(); public FallbackZipEncoding(String charset); public boolean canEncode(String name); public ByteBuffer encode(String name) throws IOException; public String decode(byte[] data) throws IOException; String charset
 [LINE] this.charset = charset; [LINE] public FallbackZipEncoding(String charset) { [EOL]     this.charset = charset; [EOL] } public FallbackZipEncoding(); public FallbackZipEncoding(String charset); public boolean canEncode(String name); public ByteBuffer encode(String name) throws IOException; public String decode(byte[] data) throws IOException; String charset
 [LINE] public static long adjustToLong(int i) { [LINE] public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] } public static ZipLong toDosTime(Date time); public static byte[] toDosTime(long t); public static long adjustToLong(int i); public static Date fromDosTime(ZipLong zipDosTime); public static long dosToJavaTime(long dosTime); byte[] DOS_TIME_MIN=Optional[ZipLong.getBytes(0x00002100L)]
 [LINE] if (i < 0) { [LINE] public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] } public static ZipLong toDosTime(Date time); public static byte[] toDosTime(long t); public static long adjustToLong(int i); public static Date fromDosTime(ZipLong zipDosTime); public static long dosToJavaTime(long dosTime); byte[] DOS_TIME_MIN=Optional[ZipLong.getBytes(0x00002100L)]
 [LINE] return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [LINE] public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] } public static ZipLong toDosTime(Date time); public static byte[] toDosTime(long t); public static long adjustToLong(int i); public static Date fromDosTime(ZipLong zipDosTime); public static long dosToJavaTime(long dosTime); byte[] DOS_TIME_MIN=Optional[ZipLong.getBytes(0x00002100L)]
 [LINE] return i; [LINE] public static long adjustToLong(int i) { [EOL]     if (i < 0) { [EOL]         return 2 * ((long) Integer.MAX_VALUE) + 2 + i; [EOL]     } else { [EOL]         return i; [EOL]     } [EOL] } public static ZipLong toDosTime(Date time); public static byte[] toDosTime(long t); public static long adjustToLong(int i); public static Date fromDosTime(ZipLong zipDosTime); public static long dosToJavaTime(long dosTime); byte[] DOS_TIME_MIN=Optional[ZipLong.getBytes(0x00002100L)]
 [LINE] public void setHeaderId(ZipShort headerId) { [LINE] public void setHeaderId(ZipShort headerId) { [EOL]     this.headerId = headerId; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] this.headerId = headerId; [LINE] public void setHeaderId(ZipShort headerId) { [EOL]     this.headerId = headerId; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] public ZipShort getHeaderId() { [LINE] public ZipShort getHeaderId() { [EOL]     return headerId; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] return headerId; [LINE] public ZipShort getHeaderId() { [EOL]     return headerId; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] public void setLocalFileDataData(byte[] data) { [LINE] public void setLocalFileDataData(byte[] data) { [EOL]     localData = copy(data); [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] localData = copy(data); [LINE] public void setLocalFileDataData(byte[] data) { [EOL]     localData = copy(data); [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] public ZipShort getLocalFileDataLength() { [LINE] public ZipShort getLocalFileDataLength() { [EOL]     return new ZipShort(localData.length); [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] return new ZipShort(localData.length); [LINE] public ZipShort getLocalFileDataLength() { [EOL]     return new ZipShort(localData.length); [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] public byte[] getLocalFileDataData() { [LINE] public byte[] getLocalFileDataData() { [EOL]     return copy(localData); [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] return copy(localData); [LINE] public byte[] getLocalFileDataData() { [EOL]     return copy(localData); [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] private static byte[] copy(byte[] from) { [LINE] private static byte[] copy(byte[] from) { [EOL]     if (from != null) { [EOL]         byte[] to = new byte[from.length]; [EOL]         System.arraycopy(from, 0, to, 0, to.length); [EOL]         return to; [EOL]     } [EOL]     return null; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] if (from != null) { [LINE] private static byte[] copy(byte[] from) { [EOL]     if (from != null) { [EOL]         byte[] to = new byte[from.length]; [EOL]         System.arraycopy(from, 0, to, 0, to.length); [EOL]         return to; [EOL]     } [EOL]     return null; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] byte[] to = new byte[from.length]; [LINE] private static byte[] copy(byte[] from) { [EOL]     if (from != null) { [EOL]         byte[] to = new byte[from.length]; [EOL]         System.arraycopy(from, 0, to, 0, to.length); [EOL]         return to; [EOL]     } [EOL]     return null; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] System.arraycopy(from, 0, to, 0, to.length); [LINE] private static byte[] copy(byte[] from) { [EOL]     if (from != null) { [EOL]         byte[] to = new byte[from.length]; [EOL]         System.arraycopy(from, 0, to, 0, to.length); [EOL]         return to; [EOL]     } [EOL]     return null; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] return to; [LINE] private static byte[] copy(byte[] from) { [EOL]     if (from != null) { [EOL]         byte[] to = new byte[from.length]; [EOL]         System.arraycopy(from, 0, to, 0, to.length); [EOL]         return to; [EOL]     } [EOL]     return null; [EOL] } public void setHeaderId(ZipShort headerId); public ZipShort getHeaderId(); public void setLocalFileDataData(byte[] data); public ZipShort getLocalFileDataLength(); public byte[] getLocalFileDataData(); public void setCentralDirectoryData(byte[] data); public ZipShort getCentralDirectoryLength(); public byte[] getCentralDirectoryData(); public void parseFromLocalFileData(byte[] data, int offset, int length); public void parseFromCentralDirectoryData(byte[] data, int offset, int length); private static byte[] copy(byte[] from); ZipShort headerId; byte[] localData; byte[] centralData
 [LINE] public GzipCompressorInputStream(InputStream inputStream) throws IOException { [LINE] public GzipCompressorInputStream(InputStream inputStream) throws IOException { [EOL]     in = new GZIPInputStream(inputStream); [EOL] } public GzipCompressorInputStream(InputStream inputStream) throws IOException; public int read() throws IOException; GZIPInputStream in
 [LINE] in = new GZIPInputStream(inputStream); [LINE] public GzipCompressorInputStream(InputStream inputStream) throws IOException { [EOL]     in = new GZIPInputStream(inputStream); [EOL] } public GzipCompressorInputStream(InputStream inputStream) throws IOException; public int read() throws IOException; GZIPInputStream in
 [LINE] public int read() throws IOException { [LINE] public int read() throws IOException { [EOL]     return in.read(); [EOL] } public GzipCompressorInputStream(InputStream inputStream) throws IOException; public int read() throws IOException; GZIPInputStream in
 [LINE] return in.read(); [LINE] public int read() throws IOException { [EOL]     return in.read(); [EOL] } public GzipCompressorInputStream(InputStream inputStream) throws IOException; public int read() throws IOException; GZIPInputStream in
 [LINE] public ZipShort getHeaderId() { [LINE] public ZipShort getHeaderId() { [EOL]     return HEADER_ID; [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[""]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]
 [LINE] return HEADER_ID; [LINE] public ZipShort getHeaderId() { [EOL]     return HEADER_ID; [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[""]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]
 [LINE] public ZipShort getCentralDirectoryLength() { [LINE] public ZipShort getCentralDirectoryLength() { [EOL]     return getLocalFileDataLength(); [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[""]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]
 [LINE] return getLocalFileDataLength(); [LINE] public ZipShort getCentralDirectoryLength() { [EOL]     return getLocalFileDataLength(); [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[""]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]
 [LINE] public byte[] getCentralDirectoryData() { [LINE] public byte[] getCentralDirectoryData() { [EOL]     return getLocalFileDataData(); [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[""]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]
 [LINE] return getLocalFileDataData(); [LINE] public byte[] getCentralDirectoryData() { [EOL]     return getLocalFileDataData(); [EOL] } public AsiExtraField(); public ZipShort getHeaderId(); public ZipShort getLocalFileDataLength(); public ZipShort getCentralDirectoryLength(); public byte[] getLocalFileDataData(); public byte[] getCentralDirectoryData(); public void setUserId(int uid); public int getUserId(); public void setGroupId(int gid); public int getGroupId(); public void setLinkedFile(String name); public String getLinkedFile(); public boolean isLink(); public void setMode(int mode); public int getMode(); public void setDirectory(boolean dirFlag); public boolean isDirectory(); public void parseFromLocalFileData(byte[] data, int offset, int length) throws ZipException; public void parseFromCentralDirectoryData(byte[] buffer, int offset, int length) throws ZipException; protected int getMode(int mode); public Object clone(); ZipShort HEADER_ID=Optional[new ZipShort(0x756E)]; int WORD=Optional[4]; int mode=Optional[0]; int uid=Optional[0]; int gid=Optional[0]; String link=Optional[""]; boolean dirFlag=Optional[false]; CRC32 crc=Optional[new CRC32()]
 [LINE] SimpleEncodingHolder(char [] highChars) { [LINE] SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }]; String UTF8=Optional["UTF8"]; ZipEncoding UTF8_ZIP_ENCODING=Optional[new FallbackZipEncoding(UTF8)]
 [LINE] this.highChars = highChars; [LINE] SimpleEncodingHolder(char[] highChars) { [EOL]     this.highChars = highChars; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }]; String UTF8=Optional["UTF8"]; ZipEncoding UTF8_ZIP_ENCODING=Optional[new FallbackZipEncoding(UTF8)]
 [LINE] this.encoding = new Simple8BitZipEncoding(this.highChars); [LINE] public synchronized Simple8BitZipEncoding getEncoding() { [EOL]     if (this.encoding == null) { [EOL]         this.encoding = new Simple8BitZipEncoding(this.highChars); [EOL]     } [EOL]     return this.encoding; [EOL] }  SimpleEncodingHolder(char[] highChars); public synchronized Simple8BitZipEncoding getEncoding();  static ByteBuffer growBuffer(ByteBuffer b, int newCapacity);  static void appendSurrogate(ByteBuffer bb, char c);  static ZipEncoding getZipEncoding(String name);  static boolean isUTF8(String encoding); Map simpleEncodings; byte[] HEX_DIGITS=Optional[new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }]; String UTF8=Optional["UTF8"]; ZipEncoding UTF8_ZIP_ENCODING=Optional[new FallbackZipEncoding(UTF8)]
 [LINE] public JarArchiveEntry(String name) { [LINE] public JarArchiveEntry(String name) { [EOL]     super(name); [EOL] } public JarArchiveEntry(ZipEntry entry) throws ZipException; public JarArchiveEntry(String name); public JarArchiveEntry(ZipArchiveEntry entry) throws ZipException; public JarArchiveEntry(JarEntry entry) throws ZipException; public Attributes getManifestAttributes(); public Certificate[] getCertificates(); Attributes manifestAttributes=Optional[null]; Certificate[] certificates=Optional[null]
 [LINE] super(name); [LINE] public JarArchiveEntry(String name) { [EOL]     super(name); [EOL] } public JarArchiveEntry(ZipEntry entry) throws ZipException; public JarArchiveEntry(String name); public JarArchiveEntry(ZipArchiveEntry entry) throws ZipException; public JarArchiveEntry(JarEntry entry) throws ZipException; public Attributes getManifestAttributes(); public Certificate[] getCertificates(); Attributes manifestAttributes=Optional[null]; Certificate[] certificates=Optional[null]
 [LINE] public static void register(Class c) { [LINE] public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] try { [LINE] public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] ZipExtraField ze = (ZipExtraField) c.newInstance(); [LINE] public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] implementations.put(ze.getHeaderId(), c); [LINE] public static void register(Class c) { [EOL]     try { [EOL]         ZipExtraField ze = (ZipExtraField) c.newInstance(); [EOL]         implementations.put(ze.getHeaderId(), c); [EOL]     } catch (ClassCastException cc) { [EOL]         throw new RuntimeException(c + " doesn\'t implement ZipExtraField"); [EOL]     } catch (InstantiationException ie) { [EOL]         throw new RuntimeException(c + " is not a concrete class"); [EOL]     } catch (IllegalAccessException ie) { [EOL]         throw new RuntimeException(c + "\'s no-arg constructor is not public"); [EOL]     } [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] int sum = WORD * data.length; [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] for (int i = 0; i < data.length; i++) { [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] sum += data[i].getLocalFileDataLength().getValue(); [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] byte[] result = new byte[sum]; [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] int start = 0; [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] for (int i = 0; i < data.length; i++) { [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] System.arraycopy(data[i].getHeaderId().getBytes(), [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] System.arraycopy(data[i].getLocalFileDataLength().getBytes(), [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] byte[] local = data[i].getLocalFileDataData(); [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] System.arraycopy(local, 0, result, start + WORD, local.length); [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] start += (local.length + WORD); [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] return result; [LINE] public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getLocalFileDataLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getLocalFileDataData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] int sum = WORD * data.length; [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] for (int i = 0; i < data.length; i++) { [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] sum += data[i].getCentralDirectoryLength().getValue(); [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] byte[] result = new byte[sum]; [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] int start = 0; [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] for (int i = 0; i < data.length; i++) { [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] System.arraycopy(data[i].getHeaderId().getBytes(), [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] byte[] local = data[i].getCentralDirectoryData(); [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] System.arraycopy(local, 0, result, start + WORD, local.length); [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] start += (local.length + WORD); [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] return result; [LINE] public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { [EOL]     int sum = WORD * data.length; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         sum += data[i].getCentralDirectoryLength().getValue(); [EOL]     } [EOL]     byte[] result = new byte[sum]; [EOL]     int start = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2); [EOL]         System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2); [EOL]         byte[] local = data[i].getCentralDirectoryData(); [EOL]         System.arraycopy(local, 0, result, start + WORD, local.length); [EOL]         start += (local.length + WORD); [EOL]     } [EOL]     return result; [EOL] } public static void register(Class c); public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException; public static ZipExtraField[] parse(byte[] data) throws ZipException; public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException; public static byte[] mergeLocalFileDataData(ZipExtraField[] data); public static byte[] mergeCentralDirectoryData(ZipExtraField[] data); int WORD=Optional[4]; Map implementations
 [LINE] Simple8BitChar(byte code, char unicode) { [LINE] Simple8BitChar(byte code, char unicode) { [EOL]     this.code = code; [EOL]     this.unicode = unicode; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] this.code = code; [LINE] Simple8BitChar(byte code, char unicode) { [EOL]     this.code = code; [EOL]     this.unicode = unicode; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] this.unicode = unicode; [LINE] Simple8BitChar(byte code, char unicode) { [EOL]     this.code = code; [EOL]     this.unicode = unicode; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public int compareTo(Object o) { [LINE] public int compareTo(Object o) { [EOL]     Simple8BitChar a = (Simple8BitChar) o; [EOL]     return this.unicode - a.unicode; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] Simple8BitChar a = (Simple8BitChar) o; [LINE] public int compareTo(Object o) { [EOL]     Simple8BitChar a = (Simple8BitChar) o; [EOL]     return this.unicode - a.unicode; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return this.unicode - a.unicode; [LINE] public int compareTo(Object o) { [EOL]     Simple8BitChar a = (Simple8BitChar) o; [EOL]     return this.unicode - a.unicode; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public Simple8BitZipEncoding(char[] highChars) { [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] this.highChars = highChars; [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] this.reverseMapping = new ArrayList(this.highChars.length); [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] byte code = 127; [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] for (int i = 0; i < this.highChars.length; ++i) { [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] this.reverseMapping.add(new Simple8BitChar(++code, [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] Collections.sort(this.reverseMapping); [LINE] public Simple8BitZipEncoding(char[] highChars) { [EOL]     this.highChars = highChars; [EOL]     this.reverseMapping = new ArrayList(this.highChars.length); [EOL]     byte code = 127; [EOL]     for (int i = 0; i < this.highChars.length; ++i) { [EOL]         this.reverseMapping.add(new Simple8BitChar(++code, this.highChars[i])); [EOL]     } [EOL]     Collections.sort(this.reverseMapping); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public char decodeByte(byte b) { [LINE] public char decodeByte(byte b) { [EOL]     if (b >= 0) { [EOL]         return (char) b; [EOL]     } [EOL]     return this.highChars[128 + b]; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (b >= 0) { [LINE] public char decodeByte(byte b) { [EOL]     if (b >= 0) { [EOL]         return (char) b; [EOL]     } [EOL]     return this.highChars[128 + b]; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return (char) b; [LINE] public char decodeByte(byte b) { [EOL]     if (b >= 0) { [EOL]         return (char) b; [EOL]     } [EOL]     return this.highChars[128 + b]; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return this.highChars[128 + b]; [LINE] public char decodeByte(byte b) { [EOL]     if (b >= 0) { [EOL]         return (char) b; [EOL]     } [EOL]     return this.highChars[128 + b]; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public boolean canEncodeChar(char c) { [LINE] public boolean canEncodeChar(char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     return r != null; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (c >= 0 && c < 128) { [LINE] public boolean canEncodeChar(char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     return r != null; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return true; [LINE] public boolean canEncodeChar(char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     return r != null; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] Simple8BitChar r = this.encodeHighChar(c); [LINE] public boolean canEncodeChar(char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     return r != null; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return r != null; [LINE] public boolean canEncodeChar(char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     return r != null; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (c >= 0 && c < 128) { [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] bb.put((byte) c); [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return true; [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] Simple8BitChar r = this.encodeHighChar(c); [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (r == null) { [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return false; [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] bb.put(r.code); [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return true; [LINE] public boolean pushEncodedChar(ByteBuffer bb, char c) { [EOL]     if (c >= 0 && c < 128) { [EOL]         bb.put((byte) c); [EOL]         return true; [EOL]     } [EOL]     Simple8BitChar r = this.encodeHighChar(c); [EOL]     if (r == null) { [EOL]         return false; [EOL]     } [EOL]     bb.put(r.code); [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] private Simple8BitChar encodeHighChar(char c) { [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] int i0 = 0; [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] int i1 = this.reverseMapping.size(); [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] while (i1 > i0) { [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] int i = i0 + (i1 - i0) / 2; [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (m.unicode == c) { [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return m; [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (m.unicode < c) { [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] i0 = i + 1; [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] i1 = i; [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (i0 >= this.reverseMapping.size()) { [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (r.unicode != c) { [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return null; [LINE] private Simple8BitChar encodeHighChar(char c) { [EOL]     int i0 = 0; [EOL]     int i1 = this.reverseMapping.size(); [EOL]     while (i1 > i0) { [EOL]         int i = i0 + (i1 - i0) / 2; [EOL]         Simple8BitChar m = (Simple8BitChar) this.reverseMapping.get(i); [EOL]         if (m.unicode == c) { [EOL]             return m; [EOL]         } [EOL]         if (m.unicode < c) { [EOL]             i0 = i + 1; [EOL]         } else { [EOL]             i1 = i; [EOL]         } [EOL]     } [EOL]     if (i0 >= this.reverseMapping.size()) { [EOL]         return null; [EOL]     } [EOL]     Simple8BitChar r = (Simple8BitChar) this.reverseMapping.get(i0); [EOL]     if (r.unicode != c) { [EOL]         return null; [EOL]     } [EOL]     return r; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public boolean canEncode(String name) { [LINE] public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] for (int i=0;i<name.length();++i) { [LINE] public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] char c = name.charAt(i); [LINE] public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (!this.canEncodeChar(c)) { [LINE] public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return false; [LINE] public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return true; [LINE] public boolean canEncode(String name) { [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (!this.canEncodeChar(c)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public ByteBuffer encode(String name) { [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] ByteBuffer out = ByteBuffer.allocate(name.length() [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] for (int i=0;i<name.length();++i) { [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] char c = name.charAt(i); [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (out.remaining() < 6) { [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] out = ZipEncodingHelper.growBuffer(out,out.position() + 6); [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] if (!this.pushEncodedChar(out,c)) { [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] ZipEncodingHelper.appendSurrogate(out,c); [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] out.limit(out.position()); [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] out.rewind(); [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return out; [LINE] public ByteBuffer encode(String name) { [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + 6 + (name.length() + 1) / 2); [EOL]     for (int i = 0; i < name.length(); ++i) { [EOL]         char c = name.charAt(i); [EOL]         if (out.remaining() < 6) { [EOL]             out = ZipEncodingHelper.growBuffer(out, out.position() + 6); [EOL]         } [EOL]         if (!this.pushEncodedChar(out, c)) { [EOL]             ZipEncodingHelper.appendSurrogate(out, c); [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public String decode(byte[] data) throws IOException { [LINE] public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] char [] ret = new char[data.length]; [LINE] public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] for (int i=0;i<data.length;++i) { [LINE] public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] ret[i] = this.decodeByte(data[i]); [LINE] public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] return new String(ret); [LINE] public String decode(byte[] data) throws IOException { [EOL]     char[] ret = new char[data.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         ret[i] = this.decodeByte(data[i]); [EOL]     } [EOL]     return new String(ret); [EOL] }  Simple8BitChar(byte code, char unicode); public Simple8BitZipEncoding(char[] highChars); public int compareTo(Object o); public String toString(); public char decodeByte(byte b); public boolean canEncodeChar(char c); public boolean pushEncodedChar(ByteBuffer bb, char c); private Simple8BitChar encodeHighChar(char c); public boolean canEncode(String name); public ByteBuffer encode(String name); public String decode(byte[] data) throws IOException; char[] highChars; List reverseMapping
 [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (offset == 0) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] expected = "!<arch>\n".getBytes(); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] realized = new byte[expected.length]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final int read = read(realized); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (read != expected.length) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] for (int i = 0; i < expected.length; i++) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (expected[i] != realized[i]) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (input.available() == 0) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (offset % 2 != 0) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] name = new byte[16]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] lastmodified = new byte[12]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] userid = new byte[6]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] groupid = new byte[6]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] filemode = new byte[8]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] length = new byte[10]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] read(name); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] read(lastmodified); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] read(userid); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] read(groupid); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] read(filemode); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] read(length); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] expected = "`\012".getBytes(); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final byte[] realized = new byte[expected.length]; [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final int read = read(realized); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (read != expected.length) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] for (int i = 0; i < expected.length; i++) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] if (expected[i] != realized[i]) { [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [LINE] public ArArchiveEntry getNextArEntry() throws IOException { [EOL]     if (offset == 0) { [EOL]         final byte[] expected = "!<arch>\n".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid header " + new String(realized)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (input.available() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (offset % 2 != 0) { [EOL]         read(); [EOL]     } [EOL]     final byte[] name = new byte[16]; [EOL]     final byte[] lastmodified = new byte[12]; [EOL]     final byte[] userid = new byte[6]; [EOL]     final byte[] groupid = new byte[6]; [EOL]     final byte[] filemode = new byte[8]; [EOL]     final byte[] length = new byte[10]; [EOL]     read(name); [EOL]     read(lastmodified); [EOL]     read(userid); [EOL]     read(groupid); [EOL]     read(filemode); [EOL]     read(length); [EOL]     { [EOL]         final byte[] expected = "`\012".getBytes(); [EOL]         final byte[] realized = new byte[expected.length]; [EOL]         final int read = read(realized); [EOL]         if (read != expected.length) { [EOL]             throw new IOException("failed to read entry header"); [EOL]         } [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             if (expected[i] != realized[i]) { [EOL]                 throw new IOException("invalid entry header. not read the content?"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim())); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] public ArchiveEntry getNextEntry() throws IOException { [LINE] public ArchiveEntry getNextEntry() throws IOException { [EOL]     return getNextArEntry(); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] return getNextArEntry(); [LINE] public ArchiveEntry getNextEntry() throws IOException { [EOL]     return getNextArEntry(); [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final int ret = read(b, 0, b.length); [LINE] public int read(byte[] b) throws IOException { [EOL]     final int ret = read(b, 0, b.length); [EOL]     offset = offset + b.length; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] offset = offset + b.length; [LINE] public int read(byte[] b) throws IOException { [EOL]     final int ret = read(b, 0, b.length); [EOL]     offset = offset + b.length; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] return ret; [LINE] public int read(byte[] b) throws IOException { [EOL]     final int ret = read(b, 0, b.length); [EOL]     offset = offset + b.length; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] public int read(byte[] b, int off, int len) throws IOException { [LINE] public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] final int ret = this.input.read(b, off, len); [LINE] public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] offset = offset + off; [LINE] public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] return ret; [LINE] public int read(byte[] b, int off, int len) throws IOException { [EOL]     final int ret = this.input.read(b, off, len); [EOL]     offset = offset + off; [EOL]     return ret; [EOL] } public ArArchiveInputStream(final InputStream pInput); public ArArchiveEntry getNextArEntry() throws IOException; public ArchiveEntry getNextEntry() throws IOException; public int read() throws IOException; public int read(byte[] b) throws IOException; public int read(byte[] b, int off, int len) throws IOException; public static boolean matches(byte[] signature, int length); InputStream input; long offset=Optional[0]
 [LINE] public CompressorInputStream createCompressorInputStream(final String name, [LINE] public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] if (name == null || in == null) { [LINE] public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] try { [LINE] public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] if ("gz".equalsIgnoreCase(name)) { [LINE] public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] return new GzipCompressorInputStream(in); [LINE] public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException { [EOL]     if (name == null || in == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorInputStream(in); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorInputStream(in); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorInputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] public CompressorOutputStream createCompressorOutputStream( [LINE] public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] if (name == null || out == null) { [LINE] public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] try { [LINE] public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] if ("gz".equalsIgnoreCase(name)) { [LINE] public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] return new GzipCompressorOutputStream(out); [LINE] public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException { [EOL]     if (name == null || out == null) { [EOL]         throw new IllegalArgumentException("Compressor name and stream must not be null."); [EOL]     } [EOL]     try { [EOL]         if ("gz".equalsIgnoreCase(name)) { [EOL]             return new GzipCompressorOutputStream(out); [EOL]         } else if ("bzip2".equalsIgnoreCase(name)) { [EOL]             return new BZip2CompressorOutputStream(out); [EOL]         } [EOL]         throw new CompressorException("Compressor: " + name + " not found."); [EOL]     } catch (IOException e) { [EOL]         throw new CompressorException("Could not create CompressorOutputStream", e); [EOL]     } [EOL] } public CompressorInputStream createCompressorInputStream(final String name, final InputStream in) throws CompressorException; public CompressorOutputStream createCompressorOutputStream(final String name, final OutputStream out) throws CompressorException
 [LINE] public UnicodePathExtraField () { [LINE] public UnicodePathExtraField() { [EOL] } public UnicodePathExtraField(); public UnicodePathExtraField(String text, byte[] bytes, int off, int len); public UnicodePathExtraField(String name, byte[] bytes); public ZipShort getHeaderId(); ZipShort UPATH_ID=Optional[new ZipShort(0x7075)]
 [LINE] public UnicodePathExtraField(String text, byte[] bytes, int off, int len) { [LINE] public UnicodePathExtraField(String text, byte[] bytes, int off, int len) { [EOL]     super(text, bytes, off, len); [EOL] } public UnicodePathExtraField(); public UnicodePathExtraField(String text, byte[] bytes, int off, int len); public UnicodePathExtraField(String name, byte[] bytes); public ZipShort getHeaderId(); ZipShort UPATH_ID=Optional[new ZipShort(0x7075)]
 [LINE] super(text, bytes, off, len); [LINE] public UnicodePathExtraField(String text, byte[] bytes, int off, int len) { [EOL]     super(text, bytes, off, len); [EOL] } public UnicodePathExtraField(); public UnicodePathExtraField(String text, byte[] bytes, int off, int len); public UnicodePathExtraField(String name, byte[] bytes); public ZipShort getHeaderId(); ZipShort UPATH_ID=Optional[new ZipShort(0x7075)]
 [LINE] public ZipShort getHeaderId() { [LINE] public ZipShort getHeaderId() { [EOL]     return UPATH_ID; [EOL] } public UnicodePathExtraField(); public UnicodePathExtraField(String text, byte[] bytes, int off, int len); public UnicodePathExtraField(String name, byte[] bytes); public ZipShort getHeaderId(); ZipShort UPATH_ID=Optional[new ZipShort(0x7075)]
 [LINE] return UPATH_ID; [LINE] public ZipShort getHeaderId() { [EOL]     return UPATH_ID; [EOL] } public UnicodePathExtraField(); public UnicodePathExtraField(String text, byte[] bytes, int off, int len); public UnicodePathExtraField(String name, byte[] bytes); public ZipShort getHeaderId(); ZipShort UPATH_ID=Optional[new ZipShort(0x7075)]
