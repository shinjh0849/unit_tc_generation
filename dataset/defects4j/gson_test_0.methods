 [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] this.factory = factory; [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] this.serializeNulls = serializeNulls; [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] this.serializers = serializers; [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] this.context = context; [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] this.ancestors = ancestors; [LINE] JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] public void start(ObjectTypePair node) { [LINE] public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (node == null) { [LINE] public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (ancestors.contains(node)) { [LINE] public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] ancestors.push(node); [LINE] public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] public void end(ObjectTypePair node) { [LINE] public void end(ObjectTypePair node) { [EOL]     if (node != null) { [EOL]         ancestors.pop(); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (node != null) { [LINE] public void end(ObjectTypePair node) { [EOL]     if (node != null) { [EOL]         ancestors.pop(); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] ancestors.pop(); [LINE] public void end(ObjectTypePair node) { [EOL]     if (node != null) { [EOL]         ancestors.pop(); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] public void visitArray(Object array, Type arrayType) { [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] assignToRoot(new JsonArray()); [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] int length = Array.getLength(array); [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] Type componentType = fieldTypeInfo.getSecondLevelType(); [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] for (int i = 0; i < length; ++i) { [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] Object child = Array.get(array, i); [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] Type childType = componentType; [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] addAsArrayElement(new ObjectTypePair(child, childType, false)); [LINE] public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] private void addAsArrayElement(ObjectTypePair elementTypePair) { [LINE] private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (elementTypePair.getObject() == null) { [LINE] private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] JsonElement childElement = getJsonElementForChild(elementTypePair); [LINE] private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] root.getAsJsonArray().add(childElement); [LINE] private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [LINE] private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] ObjectNavigator on = factory.create(fieldValueTypePair); [LINE] private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] JsonSerializationVisitor childVisitor = [LINE] private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] on.accept(childVisitor); [LINE] private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] return childVisitor.getJsonElement(); [LINE] private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] try { [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] Object obj = objTypePair.getObject(); [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (obj == null) { [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] JsonElement element = findAndInvokeCustomSerializer(objTypePair); [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (element != null) { [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] assignToRoot(element); [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] return true; [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] return false; [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] throw e.createDetailedException(null); [LINE] public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] if (pair == null) { [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] return null; [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] JsonSerializer serializer = pair.first; [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] objTypePair = pair.second; [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] start(objTypePair); [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] try { [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] JsonElement element = [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] return element == null ? JsonNull.createJsonNull() : element; [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] end(objTypePair); [LINE] @SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] private void assignToRoot(JsonElement newRoot) { [LINE] private void assignToRoot(JsonElement newRoot) { [EOL]     Preconditions.checkNotNull(newRoot); [EOL]     root = newRoot; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] Preconditions.checkNotNull(newRoot); [LINE] private void assignToRoot(JsonElement newRoot) { [EOL]     Preconditions.checkNotNull(newRoot); [EOL]     root = newRoot; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] root = newRoot; [LINE] private void assignToRoot(JsonElement newRoot) { [EOL]     Preconditions.checkNotNull(newRoot); [EOL]     root = newRoot; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] public JsonElement getJsonElement() { [LINE] public JsonElement getJsonElement() { [EOL]     return root; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] return root; [LINE] public JsonElement getJsonElement() { [EOL]     return root; [EOL] }  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors); public Object getTarget(); public void start(ObjectTypePair node); public void end(ObjectTypePair node); public void startVisitingObject(Object node); public void visitArray(Object array, Type arrayType); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitPrimitive(Object obj); private void addAsChildOfObject(FieldAttributes f, ObjectTypePair fieldValuePair); private void addChildAsElement(FieldAttributes f, JsonElement childElement); private void addAsArrayElement(ObjectTypePair elementTypePair); private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); private void assignToRoot(JsonElement newRoot); private boolean isFieldNull(FieldAttributes f, Object obj); private Object getFieldValue(FieldAttributes f, Object obj); public JsonElement getJsonElement(); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; JsonSerializationContext context; MemoryRefStack ancestors; JsonElement root
 [LINE] public void setIndent(String indent) { [LINE] public void setIndent(String indent) { [EOL]     if (indent.length() == 0) { [EOL]         this.indent = null; [EOL]         this.separator = ":"; [EOL]     } else { [EOL]         this.indent = indent; [EOL]         this.separator = ": "; [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] if (indent.length() == 0) { [LINE] public void setIndent(String indent) { [EOL]     if (indent.length() == 0) { [EOL]         this.indent = null; [EOL]         this.separator = ":"; [EOL]     } else { [EOL]         this.indent = indent; [EOL]         this.separator = ": "; [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] this.indent = indent; [LINE] public void setIndent(String indent) { [EOL]     if (indent.length() == 0) { [EOL]         this.indent = null; [EOL]         this.separator = ":"; [EOL]     } else { [EOL]         this.indent = indent; [EOL]         this.separator = ": "; [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] this.separator = ": "; [LINE] public void setIndent(String indent) { [EOL]     if (indent.length() == 0) { [EOL]         this.indent = null; [EOL]         this.separator = ":"; [EOL]     } else { [EOL]         this.indent = indent; [EOL]         this.separator = ": "; [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] throw new IllegalStateException("Nesting problem: " + stack); [LINE] private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context != nonempty && context != empty) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     stack.remove(stack.size() - 1); [EOL]     if (context == nonempty) { [EOL]         newline(); [EOL]     } [EOL]     out.write(closeBracket); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] throw new NullPointerException("name == null"); [LINE] public JsonWriter name(String name) throws IOException { [EOL]     if (name == null) { [EOL]         throw new NullPointerException("name == null"); [EOL]     } [EOL]     beforeName(); [EOL]     string(name); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] public JsonWriter value(String value) throws IOException { [LINE] public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] if (value == null) { [LINE] public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] beforeValue(false); [LINE] public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] public JsonWriter value(double value) throws IOException { [LINE] public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] if (Double.isNaN(value) || Double.isInfinite(value)) { [LINE] public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] beforeValue(false); [LINE] public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] out.append(Double.toString(value)); [LINE] public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] return this; [LINE] public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] public void close() throws IOException { [LINE] public void close() throws IOException { [EOL]     out.close(); [EOL]     if (peek() != JsonScope.NONEMPTY_DOCUMENT) { [EOL]         throw new IOException("Incomplete document"); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] out.close(); [LINE] public void close() throws IOException { [EOL]     out.close(); [EOL]     if (peek() != JsonScope.NONEMPTY_DOCUMENT) { [EOL]         throw new IOException("Incomplete document"); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] if (peek() != JsonScope.NONEMPTY_DOCUMENT) { [LINE] public void close() throws IOException { [EOL]     out.close(); [EOL]     if (peek() != JsonScope.NONEMPTY_DOCUMENT) { [EOL]         throw new IOException("Incomplete document"); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] out.write("\n"); [LINE] private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] for (int i = 1; i < stack.size(); i++) { [LINE] private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] out.write(indent); [LINE] private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] throw new IllegalStateException( [LINE] private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] case NONEMPTY_ARRAY: // another in array [LINE] private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] out.append(','); [LINE] private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] newline(); [LINE] private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] break; [LINE] private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] } public JsonWriter(Writer out); public void setIndent(String indent); public void setLenient(boolean lenient); public boolean isLenient(); public void setHtmlSafe(boolean htmlSafe); public boolean isHtmlSafe(); public JsonWriter beginArray() throws IOException; public JsonWriter endArray() throws IOException; public JsonWriter beginObject() throws IOException; public JsonWriter endObject() throws IOException; private JsonWriter open(JsonScope empty, String openBracket) throws IOException; private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException; private JsonScope peek(); private void replaceTop(JsonScope topOfStack); public JsonWriter name(String name) throws IOException; public JsonWriter value(String value) throws IOException; public JsonWriter nullValue() throws IOException; public JsonWriter value(boolean value) throws IOException; public JsonWriter value(double value) throws IOException; public JsonWriter value(long value) throws IOException; public JsonWriter value(Number value) throws IOException; public void flush() throws IOException; public void close() throws IOException; private void string(String value) throws IOException; private void newline() throws IOException; private void beforeName() throws IOException; private void beforeValue(boolean root) throws IOException; Writer out; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; String indent; String separator=Optional[":"]; boolean lenient; boolean htmlSafe
 [LINE] public boolean shouldSkipClass(Class<?> clazz) { [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] }  SyntheticFieldExclusionStrategy(boolean skipSyntheticFields); public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f); boolean skipSyntheticFields
 [LINE] return false; [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] }  SyntheticFieldExclusionStrategy(boolean skipSyntheticFields); public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f); boolean skipSyntheticFields
 [LINE] public UpperCamelCaseSeparatorNamingPolicy(String separatorString) { [LINE] public UpperCamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     super(new CamelCaseSeparatorNamingPolicy(separatorString), new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER)); [EOL] } public UpperCamelCaseSeparatorNamingPolicy(String separatorString)
 [LINE] super(new CamelCaseSeparatorNamingPolicy(separatorString), [LINE] public UpperCamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     super(new CamelCaseSeparatorNamingPolicy(separatorString), new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER)); [EOL] } public UpperCamelCaseSeparatorNamingPolicy(String separatorString)
 [LINE] public boolean shouldSkipClass(Class<?> clazz) { [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] } public ModifierBasedExclusionStrategy(int... modifiers); public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); Collection<Integer> modifiers
 [LINE] return false; [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] } public ModifierBasedExclusionStrategy(int... modifiers); public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); Collection<Integer> modifiers
 [LINE] public Class<?> getComponentRawType() { [LINE] public Class<?> getComponentRawType() { [EOL]     return componentRawType; [EOL] }  TypeInfoArray(Type type); private static Type extractSecondLevelType(Type actualType, Class<?> rawClass); public Type getSecondLevelType(); public Class<?> getComponentRawType(); Class<?> componentRawType; Type secondLevel
 [LINE] return componentRawType; [LINE] public Class<?> getComponentRawType() { [EOL]     return componentRawType; [EOL] }  TypeInfoArray(Type type); private static Type extractSecondLevelType(Type actualType, Class<?> rawClass); public Type getSecondLevelType(); public Class<?> getComponentRawType(); Class<?> componentRawType; Type secondLevel
 [LINE] Escaper(boolean escapeHtmlCharacters) { [LINE] Escaper(boolean escapeHtmlCharacters) { [EOL]     this.escapeHtmlCharacters = escapeHtmlCharacters; [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }]; Set<Character> JS_ESCAPE_CHARS; Set<Character> HTML_ESCAPE_CHARS; boolean escapeHtmlCharacters
 [LINE] this.escapeHtmlCharacters = escapeHtmlCharacters; [LINE] Escaper(boolean escapeHtmlCharacters) { [EOL]     this.escapeHtmlCharacters = escapeHtmlCharacters; [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }]; Set<Character> JS_ESCAPE_CHARS; Set<Character> HTML_ESCAPE_CHARS; boolean escapeHtmlCharacters
 [LINE] Pair(FIRST first, SECOND second) { [LINE] Pair(FIRST first, SECOND second) { [EOL]     this.first = first; [EOL]     this.second = second; [EOL] }  Pair(FIRST first, SECOND second); public int hashCode(); public boolean equals(Object o); private static boolean equal(Object a, Object b); public String toString(); FIRST first; SECOND second
 [LINE] this.first = first; [LINE] Pair(FIRST first, SECOND second) { [EOL]     this.first = first; [EOL]     this.second = second; [EOL] }  Pair(FIRST first, SECOND second); public int hashCode(); public boolean equals(Object o); private static boolean equal(Object a, Object b); public String toString(); FIRST first; SECOND second
 [LINE] this.second = second; [LINE] Pair(FIRST first, SECOND second) { [EOL]     this.first = first; [EOL]     this.second = second; [EOL] }  Pair(FIRST first, SECOND second); public int hashCode(); public boolean equals(Object o); private static boolean equal(Object a, Object b); public String toString(); FIRST first; SECOND second
 [LINE] public JsonToken peek() throws IOException { [LINE] public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] quickPeek(); [LINE] public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] if (token == null) { [LINE] public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] decodeLiteral(); [LINE] public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] return token; [LINE] public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] pos += NON_EXECUTE_PREFIX.length; [LINE] private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] public String nextName() throws IOException { [LINE] public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] quickPeek(); [LINE] public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] public String nextString() throws IOException { [LINE] public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] peek(); [LINE] public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [LINE] public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] throw new IllegalStateException("Expected a string but was " + peek()); [LINE] public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] public void skipValue() throws IOException { [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] skipping = true; [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] try { [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] int count = 0; [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] do { [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] JsonToken token = advance(); [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] count++; [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] count--; [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] } while (count != 0); [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] skipping = false; [LINE] public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] pop(); [LINE] private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] hasToken = true; [LINE] private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] return token = JsonToken.END_ARRAY; [LINE] private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] default: [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] pos--; [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case '}': [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] pop(); [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] hasToken = true; [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] return token = JsonToken.END_OBJECT; [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case ';': [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] int quote = nextNonWhitespace(); [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] switch (quote) { [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case '\'': [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] checkLenient(); // fall-through [LINE] private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] default: [LINE] private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] throw syntaxError("Expected ':'"); [LINE] private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case '"': [LINE] private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] value = nextString((char) c); [LINE] private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] hasToken = true; [LINE] private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] return token = JsonToken.STRING; [LINE] private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case '\t': [LINE] private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case ' ': [LINE] private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case '\n': [LINE] private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] case '\r': [LINE] private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] continue; [LINE] private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] return "skipped!"; [LINE] private String nextString(char quote) throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             if (c == quote) { [EOL]                 if (skipping) { [EOL]                     return "skipped!"; [EOL]                 } else if (builder == null) { [EOL]                     return new String(buffer, start, pos - start - 1); [EOL]                 } else { [EOL]                     builder.append(buffer, start, pos - start - 1); [EOL]                     return builder.toString(); [EOL]                 } [EOL]             } else if (c == '\\') { [EOL]                 if (builder == null) { [EOL]                     builder = new StringBuilder(); [EOL]                 } [EOL]                 builder.append(buffer, start, pos - start - 1); [EOL]                 builder.append(readEscapeCharacter()); [EOL]                 start = pos; [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     throw syntaxError("Unterminated string"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] return "skipped!"; [LINE] private String nextLiteral() throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             switch(c) { [EOL]                 case '/': [EOL]                 case '\\': [EOL]                 case ';': [EOL]                 case '#': [EOL]                 case '=': [EOL]                     checkLenient(); [EOL]                 case '{': [EOL]                 case '}': [EOL]                 case '[': [EOL]                 case ']': [EOL]                 case ':': [EOL]                 case ',': [EOL]                 case ' ': [EOL]                 case '\t': [EOL]                 case '\f': [EOL]                 case '\r': [EOL]                 case '\n': [EOL]                     pos--; [EOL]                     if (skipping) { [EOL]                         return "skipped!"; [EOL]                     } else if (builder == null) { [EOL]                         return new String(buffer, start, pos - start); [EOL]                     } else { [EOL]                         builder.append(buffer, start, pos - start); [EOL]                         return builder.toString(); [EOL]                     } [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     return builder.toString(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] default: [LINE] private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] private void decodeLiteral() throws IOException { [LINE] private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] if (value.equalsIgnoreCase("null")) { [LINE] private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] token = JsonToken.NULL; [LINE] private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}'\n".toCharArray()]; Reader in; boolean lenient=Optional[false]; char[] buffer=Optional[new char[1024]]; int pos=Optional[0]; int limit=Optional[0]; List<JsonScope> stack=Optional[new ArrayList<JsonScope>()]; boolean hasToken; JsonToken token; String name; String value; boolean skipping=Optional[false]
 [LINE] public boolean shouldSkipClass(Class<?> clazz) { [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return isAnonymousOrLocal(clazz); [EOL] } public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); private boolean isAnonymousOrLocal(Class<?> clazz)
 [LINE] return isAnonymousOrLocal(clazz); [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return isAnonymousOrLocal(clazz); [EOL] } public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); private boolean isAnonymousOrLocal(Class<?> clazz)
 [LINE] private boolean isAnonymousOrLocal(Class<?> clazz) { [LINE] private boolean isAnonymousOrLocal(Class<?> clazz) { [EOL]     return !Enum.class.isAssignableFrom(clazz) && (clazz.isAnonymousClass() || clazz.isLocalClass()); [EOL] } public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); private boolean isAnonymousOrLocal(Class<?> clazz)
 [LINE] return !Enum.class.isAssignableFrom(clazz) [LINE] private boolean isAnonymousOrLocal(Class<?> clazz) { [EOL]     return !Enum.class.isAssignableFrom(clazz) && (clazz.isAnonymousClass() || clazz.isLocalClass()); [EOL] } public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); private boolean isAnonymousOrLocal(Class<?> clazz)
 [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] try { [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] if (!json.isJsonObject()) { [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] JsonObject jsonObject = json.getAsJsonObject(); [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] String fName = getFieldName(f); [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] if (jsonChild != null) { [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] Object array = visitChildAsArray(typeOfF, jsonChild); [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] f.set(obj, array); [LINE] public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] return false; [LINE] public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }  JsonObjectDeserializationVisitor(JsonElement json, Type type, ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, JsonDeserializationContext context); protected T constructTarget(); public void startVisitingObject(Object node); public void visitArray(Object array, Type componentType); public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj); public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); private String getFieldName(FieldAttributes f); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent); public void visitPrimitive(Object primitive)
 [LINE] public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [LINE] public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] } public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy); public ObjectNavigator create(ObjectTypePair objTypePair);  FieldNamingStrategy2 getFieldNamingPolicy(); ExclusionStrategy strategy; FieldNamingStrategy2 fieldNamingPolicy
 [LINE] Preconditions.checkNotNull(fieldNamingPolicy); [LINE] public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] } public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy); public ObjectNavigator create(ObjectTypePair objTypePair);  FieldNamingStrategy2 getFieldNamingPolicy(); ExclusionStrategy strategy; FieldNamingStrategy2 fieldNamingPolicy
 [LINE] this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [LINE] public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] } public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy); public ObjectNavigator create(ObjectTypePair objTypePair);  FieldNamingStrategy2 getFieldNamingPolicy(); ExclusionStrategy strategy; FieldNamingStrategy2 fieldNamingPolicy
 [LINE] this.fieldNamingPolicy = fieldNamingPolicy; [LINE] public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] } public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy); public ObjectNavigator create(ObjectTypePair objTypePair);  FieldNamingStrategy2 getFieldNamingPolicy(); ExclusionStrategy strategy; FieldNamingStrategy2 fieldNamingPolicy
 [LINE] public ObjectNavigator create(ObjectTypePair objTypePair) { [LINE] public ObjectNavigator create(ObjectTypePair objTypePair) { [EOL]     return new ObjectNavigator(objTypePair, strategy); [EOL] } public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy); public ObjectNavigator create(ObjectTypePair objTypePair);  FieldNamingStrategy2 getFieldNamingPolicy(); ExclusionStrategy strategy; FieldNamingStrategy2 fieldNamingPolicy
 [LINE] return new ObjectNavigator(objTypePair, strategy); [LINE] public ObjectNavigator create(ObjectTypePair objTypePair) { [EOL]     return new ObjectNavigator(objTypePair, strategy); [EOL] } public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy); public ObjectNavigator create(ObjectTypePair objTypePair);  FieldNamingStrategy2 getFieldNamingPolicy(); ExclusionStrategy strategy; FieldNamingStrategy2 fieldNamingPolicy
 [LINE] public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) [LINE] public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (!(json instanceof JsonPrimitive)) { [LINE] public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] try { [LINE] public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] synchronized (format) { [LINE] public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return format.parse(json.getAsString()); [LINE] public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public Timestamp deserialize(JsonElement json, Type typeOfT, [LINE] public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Date date = context.deserialize(json, Date.class); [EOL]     return new Timestamp(date.getTime()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] Date date = context.deserialize(json, Date.class); [LINE] public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Date date = context.deserialize(json, Date.class); [EOL]     return new Timestamp(date.getTime()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new Timestamp(date.getTime()); [LINE] public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Date date = context.deserialize(json, Date.class); [EOL]     return new Timestamp(date.getTime()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] JsonObject obj = new JsonObject(); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] obj.addProperty(YEAR, src.get(Calendar.YEAR)); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] obj.addProperty(MONTH, src.get(Calendar.MONTH)); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] obj.addProperty(SECOND, src.get(Calendar.SECOND)); [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return obj; [LINE] public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) { [LINE] public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.name()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new JsonPrimitive(src.name()); [LINE] public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.name()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] @SuppressWarnings("cast") [LINE] @SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [LINE] @SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) [LINE] public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URL(json.getAsString()); [EOL]     } catch (MalformedURLException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] try { [LINE] public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URL(json.getAsString()); [EOL]     } catch (MalformedURLException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new URL(json.getAsString()); [LINE] public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URL(json.getAsString()); [EOL]     } catch (MalformedURLException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) { [LINE] public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new JsonPrimitive(src.toString()); [LINE] public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] String locale = json.getAsString(); [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] String language = null; [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] String country = null; [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] String variant = null; [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (tokenizer.hasMoreElements()) { [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] language = tokenizer.nextToken(); [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (tokenizer.hasMoreElements()) { [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (tokenizer.hasMoreElements()) { [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] variant = tokenizer.nextToken(); [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (country == null && variant == null) { [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new Locale(language); [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new Locale(language, country, variant); [LINE] public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [LINE] public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] array.add(JsonNull.createJsonNull()); [LINE] public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public Collection deserialize(JsonElement json, Type typeOfT, [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (json.isJsonNull()) { [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] Collection collection = constructCollectionType(typeOfT, context); [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] Type childType = new TypeInfoCollection(typeOfT).getElementType(); [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] for (JsonElement childElement : json.getAsJsonArray()) { [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] if (childElement == null || childElement.isJsonNull()) { [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] Object value = context.deserialize(childElement, childType); [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] collection.add(value); [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return collection; [LINE] public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] private Collection constructCollectionType(Type collectionType, [LINE] private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [LINE] private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [LINE] private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return (Collection) objectConstructor.construct(collectionType); [LINE] private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [LINE] public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public Map createInstance(Type type) { [LINE] public Map createInstance(Type type) { [EOL]     return new LinkedHashMap(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new LinkedHashMap(); [LINE] public Map createInstance(Type type) { [EOL]     return new LinkedHashMap(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) { [LINE] public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new JsonPrimitive(src); [LINE] public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) [LINE] public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsInt(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return json.getAsInt(); [LINE] public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsInt(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) [LINE] public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsDouble(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return json.getAsDouble(); [LINE] public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsDouble(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public TreeSet<?> createInstance(Type type) { [LINE] public TreeSet<?> createInstance(Type type) { [EOL]     return new TreeSet<Object>(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new TreeSet<Object>(); [LINE] public TreeSet<?> createInstance(Type type) { [EOL]     return new TreeSet<Object>(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public HashSet<?> createInstance(Type type) { [LINE] public HashSet<?> createInstance(Type type) { [EOL]     return new HashSet<Object>(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] return new HashSet<Object>(); [LINE] public HashSet<?> createInstance(Type type) { [EOL]     return new HashSet<Object>(); [EOL] }  DefaultDateTypeAdapter();  DefaultDateTypeAdapter(final String datePattern);  DefaultDateTypeAdapter(final int style); public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle);  DefaultJavaSqlDateTypeAdapter();  DefaultTimeTypeAdapter(); private LongSerializer(LongSerializationPolicy longSerializationPolicy);  FloatSerializer(boolean serializeSpecialDoubleValues);  DoubleSerializer(boolean serializeSpecialDoubleValues); private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers(); private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers(); private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators(); private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer);  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers();  static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy);  static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers();  static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators(); public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context); public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context); public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context); public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context); public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context); public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context); public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context); public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context); public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context); public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context); public Collection createInstance(Type type); public Properties createInstance(Type type); public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context); public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; private Map constructMapType(Type mapType, JsonDeserializationContext context); public Map createInstance(Type type); public String toString(); public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context); public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context); public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context); public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context); public String toString(); public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context); public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context); public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context); public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context); public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context); public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context); public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context); public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context); public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; public String toString(); public TreeSet<?> createInstance(Type type); public String toString(); public HashSet<?> createInstance(Type type); public String toString(); DefaultDateTypeAdapter DATE_TYPE_ADAPTER=Optional[new DefaultDateTypeAdapter()]; DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER=Optional[new DefaultJavaSqlDateTypeAdapter()]; DefaultTimeTypeAdapter TIME_TYPE_ADAPTER=Optional[new DefaultTimeTypeAdapter()]; DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER=Optional[new DefaultTimestampDeserializer()]; EnumTypeAdapter ENUM_TYPE_ADAPTER=Optional[new EnumTypeAdapter()]; UrlTypeAdapter URL_TYPE_ADAPTER=Optional[new UrlTypeAdapter()]; UriTypeAdapter URI_TYPE_ADAPTER=Optional[new UriTypeAdapter()]; UuidTypeAdapter UUUID_TYPE_ADAPTER=Optional[new UuidTypeAdapter()]; LocaleTypeAdapter LOCALE_TYPE_ADAPTER=Optional[new LocaleTypeAdapter()]; CollectionTypeAdapter COLLECTION_TYPE_ADAPTER=Optional[new CollectionTypeAdapter()]; MapTypeAdapter MAP_TYPE_ADAPTER=Optional[new MapTypeAdapter()]; BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER=Optional[new BigDecimalTypeAdapter()]; BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER=Optional[new BigIntegerTypeAdapter()]; BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER=Optional[new BooleanTypeAdapter()]; ByteTypeAdapter BYTE_TYPE_ADAPTER=Optional[new ByteTypeAdapter()]; CharacterTypeAdapter CHARACTER_TYPE_ADAPTER=Optional[new CharacterTypeAdapter()]; DoubleDeserializer DOUBLE_TYPE_ADAPTER=Optional[new DoubleDeserializer()]; FloatDeserializer FLOAT_TYPE_ADAPTER=Optional[new FloatDeserializer()]; IntegerTypeAdapter INTEGER_TYPE_ADAPTER=Optional[new IntegerTypeAdapter()]; LongDeserializer LONG_DESERIALIZER=Optional[new LongDeserializer()]; NumberTypeAdapter NUMBER_TYPE_ADAPTER=Optional[new NumberTypeAdapter()]; ShortTypeAdapter SHORT_TYPE_ADAPTER=Optional[new ShortTypeAdapter()]; StringTypeAdapter STRING_TYPE_ADAPTER=Optional[new StringTypeAdapter()]; PropertiesCreator PROPERTIES_CREATOR=Optional[new PropertiesCreator()]; TreeSetCreator TREE_SET_CREATOR=Optional[new TreeSetCreator()]; HashSetCreator HASH_SET_CREATOR=Optional[new HashSetCreator()]; GregorianCalendarTypeAdapter GREGORIAN_CALENDAR_TYPE_ADAPTER=Optional[new GregorianCalendarTypeAdapter()]; ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS=Optional[createDefaultSerializers()]; ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS=Optional[createDefaultDeserializers()]; ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS=Optional[createDefaultInstanceCreators()]
 [LINE] public boolean shouldSkipClass(Class<?> clazz) { [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] } public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f)
 [LINE] return false; [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] } public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f)
 [LINE] ParameterizedType paramType = (ParameterizedType) mapType; [LINE] public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] keyType = paramType.getActualTypeArguments()[0]; [LINE] public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] valueType = paramType.getActualTypeArguments()[1]; [LINE] public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] public Type getKeyType() { [LINE] public Type getKeyType() { [EOL]     return keyType; [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] return keyType; [LINE] public Type getKeyType() { [EOL]     return keyType; [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] public Type getValueType() { [LINE] public Type getValueType() { [EOL]     return valueType; [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] return valueType; [LINE] public Type getValueType() { [EOL]     return valueType; [EOL] } public TypeInfoMap(Type mapType); public Type getKeyType(); public Type getValueType(); Type keyType; Type valueType
 [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] try { [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] switch (reader.peek()) { [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] case STRING: [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] return new JsonPrimitive(reader.nextString()); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] case BEGIN_ARRAY: [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] JsonArray array = new JsonArray(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] reader.beginArray(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] while (reader.hasNext()) { [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] array.add(parse(reader)); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] reader.endArray(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] return array; [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] case BEGIN_OBJECT: [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] JsonObject object = new JsonObject(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] reader.beginObject(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] while (reader.hasNext()) { [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] object.add(reader.nextName(), parse(reader)); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] reader.endObject(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] return object; [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] case NAME: [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] throw new IllegalArgumentException(); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] throw new JsonSyntaxException(e); [LINE] static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] if (element == null || element.isJsonNull()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] } else if (element.isJsonPrimitive()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] JsonPrimitive primitive = element.getAsJsonPrimitive(); [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] if (primitive.isNumber()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] } else if (primitive.isBoolean()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] writer.value(primitive.getAsString()); [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] } else if (element.isJsonArray()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] writer.beginArray(); [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] for (JsonElement e : element.getAsJsonArray()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] if (e.isJsonNull()) { [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] write(e, serializeNulls, writer); [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] writer.endArray(); [LINE] static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] static Writer writerForAppendable(Appendable appendable) { [LINE] static Writer writerForAppendable(Appendable appendable) { [EOL]     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable); [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable); [LINE] static Writer writerForAppendable(Appendable appendable) { [EOL]     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable); [EOL] } private AppendableWriter(Appendable appendable);  static JsonElement parse(JsonReader reader) throws JsonParseException;  static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException;  static Writer writerForAppendable(Appendable appendable); public void write(char[] chars, int offset, int length) throws IOException; public void write(int i) throws IOException; public void flush() throws IOException; public void close() throws IOException; public int length(); public char charAt(int i); public CharSequence subSequence(int start, int end)
 [LINE] public static void checkNotNull(Object obj) { [LINE] public static void checkNotNull(Object obj) { [EOL]     checkArgument(obj != null); [EOL] } public static void checkNotNull(Object obj); public static void checkArgument(boolean condition); public static void checkState(boolean condition)
 [LINE] checkArgument(obj != null); [LINE] public static void checkNotNull(Object obj) { [EOL]     checkArgument(obj != null); [EOL] } public static void checkNotNull(Object obj); public static void checkArgument(boolean condition); public static void checkState(boolean condition)
 [LINE] @Override [LINE] @Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigDecimal(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] } public JsonArray(); public void add(JsonElement element); public void addAll(JsonArray array);  void reverse(); public int size(); public Iterator<JsonElement> iterator(); public JsonElement get(int i); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public short getAsShort(); public boolean getAsBoolean();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; List<JsonElement> elements
 [LINE] if (elements.size() == 1) { [LINE] @Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigDecimal(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] } public JsonArray(); public void add(JsonElement element); public void addAll(JsonArray array);  void reverse(); public int size(); public Iterator<JsonElement> iterator(); public JsonElement get(int i); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public short getAsShort(); public boolean getAsBoolean();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; List<JsonElement> elements
 [LINE] return elements.get(0).getAsBigDecimal(); [LINE] @Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigDecimal(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] } public JsonArray(); public void add(JsonElement element); public void addAll(JsonArray array);  void reverse(); public int size(); public Iterator<JsonElement> iterator(); public JsonElement get(int i); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public short getAsShort(); public boolean getAsBoolean();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; List<JsonElement> elements
 [LINE] private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy) { [LINE] private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy) { [EOL]     this.namingPolicy = namingPolicy; [EOL] } private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy);  FieldNamingStrategy2 getFieldNamingPolicy(); FieldNamingStrategy2 namingPolicy
 [LINE] this.namingPolicy = namingPolicy; [LINE] private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy) { [EOL]     this.namingPolicy = namingPolicy; [EOL] } private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy);  FieldNamingStrategy2 getFieldNamingPolicy(); FieldNamingStrategy2 namingPolicy
 [LINE] FieldNamingStrategy2 getFieldNamingPolicy() { [LINE] FieldNamingStrategy2 getFieldNamingPolicy() { [EOL]     return namingPolicy; [EOL] } private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy);  FieldNamingStrategy2 getFieldNamingPolicy(); FieldNamingStrategy2 namingPolicy
 [LINE] return namingPolicy; [LINE] FieldNamingStrategy2 getFieldNamingPolicy() { [EOL]     return namingPolicy; [EOL] } private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy);  FieldNamingStrategy2 getFieldNamingPolicy(); FieldNamingStrategy2 namingPolicy
 [LINE] public Type getRawType() { [LINE] public Type getRawType() { [EOL]     return rawType; [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] return rawType; [LINE] public Type getRawType() { [EOL]     return rawType; [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] public Type[] getActualTypeArguments() { [LINE] public Type[] getActualTypeArguments() { [EOL]     return actualTypeArguments; [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] return actualTypeArguments; [LINE] public Type[] getActualTypeArguments() { [EOL]     return actualTypeArguments; [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] public Type getOwnerType() { [LINE] public Type getOwnerType() { [EOL]     return owner; [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] return owner; [LINE] public Type getOwnerType() { [EOL]     return owner; [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] @Override [LINE] @Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] return Arrays.hashCode(actualTypeArguments) [LINE] @Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] ^ (owner == null ? 0 : owner.hashCode()) [LINE] @Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] } public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner); public Type getRawType(); public Type[] getActualTypeArguments(); public Type getOwnerType(); public boolean equals(Object o); public int hashCode(); Type rawType; Type[] actualTypeArguments; Type owner
 [LINE] } else if (type instanceof GenericArrayType) { [LINE] static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] } private TypeUtils();  static Type getActualTypeForFirstTypeVariable(Type type);  static boolean isArray(Type type);  static Class<?> toRawClass(Type type);  static Class<?> wrapWithArray(Class<?> rawClass)
 [LINE] return getActualTypeForFirstTypeVariable(((GenericArrayType)type).getGenericComponentType()); [LINE] static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] } private TypeUtils();  static Type getActualTypeForFirstTypeVariable(Type type);  static boolean isArray(Type type);  static Class<?> toRawClass(Type type);  static Class<?> wrapWithArray(Class<?> rawClass)
 [LINE] } else if (type instanceof GenericArrayType) { [LINE] static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } private TypeUtils();  static Type getActualTypeForFirstTypeVariable(Type type);  static boolean isArray(Type type);  static Class<?> toRawClass(Type type);  static Class<?> wrapWithArray(Class<?> rawClass)
 [LINE] return false; [LINE] static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } private TypeUtils();  static Type getActualTypeForFirstTypeVariable(Type type);  static boolean isArray(Type type);  static Class<?> toRawClass(Type type);  static Class<?> wrapWithArray(Class<?> rawClass)
 [LINE] public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) { [LINE] public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) { [EOL]     this.delegate = delegate; [EOL] } public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate); public String translateName(FieldAttributes f); JsonFieldNameValidator fieldNameValidator=Optional[new JsonFieldNameValidator()]; FieldNamingStrategy2 delegate
 [LINE] this.delegate = delegate; [LINE] public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) { [EOL]     this.delegate = delegate; [EOL] } public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate); public String translateName(FieldAttributes f); JsonFieldNameValidator fieldNameValidator=Optional[new JsonFieldNameValidator()]; FieldNamingStrategy2 delegate
 [LINE] public void toJson(Object src, Appendable writer) { [LINE] public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] try { [LINE] public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] if (src != null) { [LINE] public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] toJson(src, src.getClass(), writer); [LINE] public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] public void toJson(Object src, Type typeOfSrc, Appendable writer) { [LINE] public void toJson(Object src, Type typeOfSrc, Appendable writer) { [EOL]     JsonElement jsonElement = toJsonTree(src, typeOfSrc); [EOL]     toJson(jsonElement, writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] JsonElement jsonElement = toJsonTree(src, typeOfSrc); [LINE] public void toJson(Object src, Type typeOfSrc, Appendable writer) { [EOL]     JsonElement jsonElement = toJsonTree(src, typeOfSrc); [EOL]     toJson(jsonElement, writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] toJson(jsonElement, writer); [LINE] public void toJson(Object src, Type typeOfSrc, Appendable writer) { [EOL]     JsonElement jsonElement = toJsonTree(src, typeOfSrc); [EOL]     toJson(jsonElement, writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] public String toJson(JsonElement jsonElement) { [LINE] public String toJson(JsonElement jsonElement) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(jsonElement, writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] StringWriter writer = new StringWriter(); [LINE] public String toJson(JsonElement jsonElement) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(jsonElement, writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] toJson(jsonElement, writer); [LINE] public String toJson(JsonElement jsonElement) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(jsonElement, writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] return writer.toString(); [LINE] public String toJson(JsonElement jsonElement) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(jsonElement, writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException { [LINE] public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(new JsonReader(json), classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] Object object = fromJson(new JsonReader(json), classOfT); [LINE] public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(new JsonReader(json), classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] return Primitives.wrap(classOfT).cast(object); [LINE] public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(new JsonReader(json), classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}'\n"]; ExclusionStrategy serializationStrategy; ExclusionStrategy deserializationStrategy; FieldNamingStrategy2 fieldNamingPolicy; MappedObjectConstructor objectConstructor; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; boolean htmlSafe; boolean generateNonExecutableJson; boolean prettyPrinting
 [LINE] JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, [LINE] JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] this.factory = factory; [LINE] JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] this.serializeNulls = serializeNulls; [LINE] JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] this.serializers = serializers; [LINE] JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] this.ancestors = new MemoryRefStack(); [LINE] JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] public JsonElement serialize(Object src) { [LINE] public JsonElement serialize(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return serialize(src, src.getClass(), true); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] if (src == null) { [LINE] public JsonElement serialize(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return serialize(src, src.getClass(), true); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] return JsonNull.createJsonNull(); [LINE] public JsonElement serialize(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return serialize(src, src.getClass(), true); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] return serialize(src, src.getClass(), true); [LINE] public JsonElement serialize(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return serialize(src, src.getClass(), true); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] public JsonElement serialize(Object src, Type typeOfSrc) { [LINE] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL]     return serialize(src, typeOfSrc, true); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] return serialize(src, typeOfSrc, true); [LINE] public JsonElement serialize(Object src, Type typeOfSrc) { [EOL]     return serialize(src, typeOfSrc, true); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [LINE] public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [LINE] public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] JsonSerializationVisitor visitor = [LINE] public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] on.accept(visitor); [LINE] public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] return visitor.getJsonElement(); [LINE] public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers); public JsonElement serialize(Object src); public JsonElement serialize(Object src, Type typeOfSrc); public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType); ObjectNavigatorFactory factory; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; boolean serializeNulls; MemoryRefStack ancestors
 [LINE] public JsonNull() { [LINE] public JsonNull() { [EOL] } public JsonNull(); protected void toString(Appendable sb, Escaper escaper) throws IOException; public int hashCode(); public boolean equals(Object other);  static JsonNull createJsonNull(); JsonNull INSTANCE=Optional[new JsonNull()]
 [LINE] return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [LINE] @SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor
 [LINE] private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, [LINE] private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor
 [LINE] JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>( [LINE] private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor
 [LINE] ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [LINE] private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor
 [LINE] on.accept(visitor); [LINE] private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor
 [LINE] return visitor.getTarget(); [LINE] private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, MappedObjectConstructor objectConstructor);  ObjectConstructor getObjectConstructor(); public T deserialize(JsonElement json, Type typeOfT) throws JsonParseException; private T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException; private T fromJsonObject(Type typeOfT, JsonObject jsonObject, JsonDeserializationContext context) throws JsonParseException; private T fromJsonPrimitive(Type typeOfT, JsonPrimitive json, JsonDeserializationContext context) throws JsonParseException; ObjectNavigatorFactory navigatorFactory; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; MappedObjectConstructor objectConstructor
 [LINE] public Type getGenericComponentType() { [LINE] public Type getGenericComponentType() { [EOL]     return genericComponentType; [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] return genericComponentType; [LINE] public Type getGenericComponentType() { [EOL]     return genericComponentType; [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] @Override [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] if (!(o instanceof  GenericArrayType)) { [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] GenericArrayType that = (GenericArrayType) o; [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] Type thatComponentType = that.getGenericComponentType(); [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] return genericComponentType == null ? [LINE] @Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] } public GenericArrayTypeImpl(Type genericComponentType); public Type getGenericComponentType(); public boolean equals(Object o); public int hashCode(); Type genericComponentType
 [LINE] LruCache(int maxCapacity) { [LINE] LruCache(int maxCapacity) { [EOL]     super(maxCapacity, 0.7F, true); [EOL]     this.maxCapacity = maxCapacity; [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] super(maxCapacity, 0.7F, true); [LINE] LruCache(int maxCapacity) { [EOL]     super(maxCapacity, 0.7F, true); [EOL]     this.maxCapacity = maxCapacity; [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] this.maxCapacity = maxCapacity; [LINE] LruCache(int maxCapacity) { [EOL]     super(maxCapacity, 0.7F, true); [EOL]     this.maxCapacity = maxCapacity; [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] public void addElement(K key, V value) { [LINE] public void addElement(K key, V value) { [EOL]     put(key, value); [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] put(key, value); [LINE] public void addElement(K key, V value) { [EOL]     put(key, value); [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] public V getElement(K key) { [LINE] public V getElement(K key) { [EOL]     return get(key); [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] return get(key); [LINE] public V getElement(K key) { [EOL]     return get(key); [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] public int size() { [LINE] public int size() { [EOL]     return super.size(); [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] return super.size(); [LINE] public int size() { [EOL]     return super.size(); [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] @Override [LINE] @Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> entry) { [EOL]     return size() > maxCapacity; [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] return size() > maxCapacity; [LINE] @Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> entry) { [EOL]     return size() > maxCapacity; [EOL] }  LruCache(int maxCapacity); public void addElement(K key, V value); public void clear(); public V getElement(K key); public V removeElement(K key); public int size(); protected boolean removeEldestEntry(Map.Entry<K, V> entry); long serialVersionUID=Optional[1L]; int maxCapacity
 [LINE] ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [LINE] ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [EOL]     Preconditions.checkNotNull(exclusionStrategy); [EOL]     this.objTypePair = objTypePair; [EOL]     this.exclusionStrategy = exclusionStrategy; [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] Preconditions.checkNotNull(exclusionStrategy); [LINE] ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [EOL]     Preconditions.checkNotNull(exclusionStrategy); [EOL]     this.objTypePair = objTypePair; [EOL]     this.exclusionStrategy = exclusionStrategy; [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] this.objTypePair = objTypePair; [LINE] ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [EOL]     Preconditions.checkNotNull(exclusionStrategy); [EOL]     this.objTypePair = objTypePair; [EOL]     this.exclusionStrategy = exclusionStrategy; [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] this.exclusionStrategy = exclusionStrategy; [LINE] ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [EOL]     Preconditions.checkNotNull(exclusionStrategy); [EOL]     this.objTypePair = objTypePair; [EOL]     this.exclusionStrategy = exclusionStrategy; [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] public void accept(Visitor visitor) { [LINE] public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [LINE] public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [LINE] public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [LINE] public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] if (!visitedWithCustomHandler) { [LINE] public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy); public void start(ObjectTypePair node); public void end(ObjectTypePair node);  void startVisitingObject(Object node);  void visitArray(Object array, Type componentType);  void visitObjectField(FieldAttributes f, Type typeOfF, Object obj);  void visitArrayField(FieldAttributes f, Type typeOfF, Object obj); public boolean visitUsingCustomHandler(ObjectTypePair objTypePair); public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent);  Object getTarget();  void visitPrimitive(Object primitive); public void accept(Visitor visitor); private boolean isPrimitiveOrString(Object objectToVisit); private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor); ExclusionStrategy exclusionStrategy; ObjectTypePair objTypePair
 [LINE] public GsonBuilder generateNonExecutableJson() { [LINE] public GsonBuilder generateNonExecutableJson() { [EOL]     this.generateNonExecutableJson = true; [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] this.generateNonExecutableJson = true; [LINE] public GsonBuilder generateNonExecutableJson() { [EOL]     this.generateNonExecutableJson = true; [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] return this; [LINE] public GsonBuilder generateNonExecutableJson() { [EOL]     this.generateNonExecutableJson = true; [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) { [LINE] public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) { [EOL]     this.longSerializationPolicy = serializationPolicy; [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] this.longSerializationPolicy = serializationPolicy; [LINE] public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) { [EOL]     this.longSerializationPolicy = serializationPolicy; [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] return this; [LINE] public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) { [EOL]     this.longSerializationPolicy = serializationPolicy; [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [LINE] public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [LINE] public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) { [LINE] public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) { [EOL]     return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy)); [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy)); [LINE] public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) { [EOL]     return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy)); [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) { [LINE] GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) { [EOL]     this.fieldNamingPolicy = new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy); [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] this.fieldNamingPolicy = [LINE] GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) { [EOL]     this.fieldNamingPolicy = new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy); [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] return this; [LINE] GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) { [EOL]     this.fieldNamingPolicy = new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy); [EOL]     return this; [EOL] } public GsonBuilder(); public GsonBuilder setVersion(double ignoreVersionsAfter); public GsonBuilder excludeFieldsWithModifiers(int... modifiers); public GsonBuilder generateNonExecutableJson(); public GsonBuilder excludeFieldsWithoutExposeAnnotation(); public GsonBuilder serializeNulls(); public GsonBuilder disableInnerClassSerialization(); public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy); public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention); public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy);  GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy); public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies); public GsonBuilder setPrettyPrinting(); public GsonBuilder disableHtmlEscaping(); public GsonBuilder setDateFormat(String pattern); public GsonBuilder setDateFormat(int style); public GsonBuilder setDateFormat(int dateStyle, int timeStyle); public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter); private GsonBuilder registerInstanceCreator(Type typeOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer); public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter); private GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT, InstanceCreator<? extends T> instanceCreator); private GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT, final JsonSerializer<T> serializer); private GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT, JsonDeserializer<T> deserializer); public GsonBuilder serializeSpecialFloatingPointValues(); public Gson create(); private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers); InnerClassExclusionStrategy innerClassExclusionStrategy=Optional[new InnerClassExclusionStrategy()]; ExposeAnnotationSerializationExclusionStrategy exposeAnnotationSerializationExclusionStrategy=Optional[new ExposeAnnotationSerializationExclusionStrategy()]; ExposeAnnotationDeserializationExclusionStrategy exposeAnnotationDeserializationExclusionStrategy=Optional[new ExposeAnnotationDeserializationExclusionStrategy()]; Collection<ExclusionStrategy> exclusionStrategies=Optional[new HashSet<ExclusionStrategy>()]; double ignoreVersionsAfter; ModifierBasedExclusionStrategy modifierBasedExclusionStrategy; boolean serializeInnerClasses; boolean excludeFieldsWithoutExposeAnnotation; LongSerializationPolicy longSerializationPolicy; FieldNamingStrategy2 fieldNamingPolicy; ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators; ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers; ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers; boolean serializeNulls; String datePattern; int dateStyle; int timeStyle; boolean serializeSpecialFloatingPointValues; boolean escapeHtmlChars; boolean prettyPrinting; boolean generateNonExecutableJson
 [LINE] return false; [LINE] private boolean isValidSince(Since annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion > version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } public VersionExclusionStrategy(double version); public boolean shouldSkipField(FieldAttributes f); public boolean shouldSkipClass(Class<?> clazz); private boolean isValidVersion(Since since, Until until); private boolean isValidSince(Since annotation); private boolean isValidUntil(Until annotation); double version
 [LINE] public boolean hasModifier(int modifier) { [LINE] public boolean hasModifier(int modifier) { [EOL]     return (modifiers & modifier) != 0; [EOL] }  FieldAttributes(final Class<?> declaringClazz, final Field f); private static int getMaxCacheSize(); public Class<?> getDeclaringClass(); public String getName(); public Type getDeclaredType(); public Class<?> getDeclaredClass(); public T getAnnotation(Class<T> annotation); public Collection<Annotation> getAnnotations(); public boolean hasModifier(int modifier);  void set(Object instance, Object value) throws IllegalAccessException;  Object get(Object instance) throws IllegalAccessException;  boolean isSynthetic();  Field getFieldObject(); private static T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation); String MAX_CACHE_PROPERTY_NAME=Optional["com.google.gson.annotation_cache_size_hint"]; Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE=Optional[new LruCache<Pair<Class<?>, String>, Collection<Annotation>>(getMaxCacheSize())]; Class<?> declaringClazz; Field field; Class<?> declaredType; boolean isSynthetic; int modifiers; String name; Type genericType; Collection<Annotation> annotations
 [LINE] return (modifiers & modifier) != 0; [LINE] public boolean hasModifier(int modifier) { [EOL]     return (modifiers & modifier) != 0; [EOL] }  FieldAttributes(final Class<?> declaringClazz, final Field f); private static int getMaxCacheSize(); public Class<?> getDeclaringClass(); public String getName(); public Type getDeclaredType(); public Class<?> getDeclaredClass(); public T getAnnotation(Class<T> annotation); public Collection<Annotation> getAnnotations(); public boolean hasModifier(int modifier);  void set(Object instance, Object value) throws IllegalAccessException;  Object get(Object instance) throws IllegalAccessException;  boolean isSynthetic();  Field getFieldObject(); private static T getAnnotationFromArray(Collection<Annotation> annotations, Class<T> annotation); String MAX_CACHE_PROPERTY_NAME=Optional["com.google.gson.annotation_cache_size_hint"]; Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE=Optional[new LruCache<Pair<Class<?>, String>, Collection<Annotation>>(getMaxCacheSize())]; Class<?> declaringClazz; Field field; Class<?> declaredType; boolean isSynthetic; int modifiers; String name; Type genericType; Collection<Annotation> annotations
 [LINE] public JsonPrimitive(String string) { [LINE] public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] setValue(string); [LINE] public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] public boolean isNumber() { [LINE] public boolean isNumber() { [EOL]     return value instanceof Number; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return value instanceof Number; [LINE] public boolean isNumber() { [EOL]     return value instanceof Number; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return longValue; [LINE] static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] @Override [LINE] @Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] if (isNumber()) { [LINE] @Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return getAsNumber().toString(); [LINE] @Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] } else if (isBoolean()) { [LINE] @Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return getAsBooleanWrapper().toString(); [LINE] @Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return (String) value; [LINE] @Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] @Override [LINE] @Override [EOL] public double getAsDouble() { [EOL]     return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [LINE] @Override [EOL] public double getAsDouble() { [EOL]     return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] @Override [LINE] @Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [LINE] @Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] @Override [LINE] @Override [EOL] public int getAsInt() { [EOL]     return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [LINE] @Override [EOL] public int getAsInt() { [EOL]     return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] @Override [LINE] @Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] if (value instanceof BigInteger) { [LINE] @Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return value; [LINE] @Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] return true; [LINE] private static boolean isPrimitiveOrString(Object target) { [EOL]     if (target instanceof String) { [EOL]         return true; [EOL]     } [EOL]     Class<?> classOfPrimitive = target.getClass(); [EOL]     for (Class<?> standardPrimitive : PRIMITIVE_TYPES) { [EOL]         if (standardPrimitive.isAssignableFrom(classOfPrimitive)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }]; BigInteger INTEGER_MAX=Optional[BigInteger.valueOf(Integer.MAX_VALUE)]; BigInteger LONG_MAX=Optional[BigInteger.valueOf(Long.MAX_VALUE)]; Object value
 [LINE] private LongSerializationPolicy(Strategy strategy) { [LINE] private LongSerializationPolicy(Strategy strategy) { [EOL]     this.strategy = strategy; [EOL] } private LongSerializationPolicy(Strategy strategy); public JsonElement serialize(Long value);  JsonElement serialize(Long value); public JsonElement serialize(Long value); public JsonElement serialize(Long value); Strategy strategy
 [LINE] this.strategy = strategy; [LINE] private LongSerializationPolicy(Strategy strategy) { [EOL]     this.strategy = strategy; [EOL] } private LongSerializationPolicy(Strategy strategy); public JsonElement serialize(Long value);  JsonElement serialize(Long value); public JsonElement serialize(Long value); public JsonElement serialize(Long value); Strategy strategy
 [LINE] public JsonElement serialize(Long value) { [LINE] public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(value); [EOL] } private LongSerializationPolicy(Strategy strategy); public JsonElement serialize(Long value);  JsonElement serialize(Long value); public JsonElement serialize(Long value); public JsonElement serialize(Long value); Strategy strategy
 [LINE] return new JsonPrimitive(value); [LINE] public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(value); [EOL] } private LongSerializationPolicy(Strategy strategy); public JsonElement serialize(Long value);  JsonElement serialize(Long value); public JsonElement serialize(Long value); public JsonElement serialize(Long value); Strategy strategy
 [LINE] public boolean shouldSkipClass(Class<?> clazz) { [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] } public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f)
 [LINE] return false; [LINE] public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] } public boolean shouldSkipClass(Class<?> clazz); public boolean shouldSkipField(FieldAttributes f)
 [LINE] public boolean isJsonArray() { [LINE] public boolean isJsonArray() { [EOL]     return this instanceof JsonArray; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] return this instanceof JsonArray; [LINE] public boolean isJsonArray() { [EOL]     return this instanceof JsonArray; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] public boolean isJsonObject() { [LINE] public boolean isJsonObject() { [EOL]     return this instanceof JsonObject; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] return this instanceof JsonObject; [LINE] public boolean isJsonObject() { [EOL]     return this instanceof JsonObject; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] public boolean isJsonPrimitive() { [LINE] public boolean isJsonPrimitive() { [EOL]     return this instanceof JsonPrimitive; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] return this instanceof JsonPrimitive; [LINE] public boolean isJsonPrimitive() { [EOL]     return this instanceof JsonPrimitive; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] public boolean isJsonNull() { [LINE] public boolean isJsonNull() { [EOL]     return this instanceof JsonNull; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] return this instanceof JsonNull; [LINE] public boolean isJsonNull() { [EOL]     return this instanceof JsonNull; [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] public JsonArray getAsJsonArray() { [LINE] public JsonArray getAsJsonArray() { [EOL]     if (isJsonArray()) { [EOL]         return (JsonArray) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Array."); [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] if (isJsonArray()) { [LINE] public JsonArray getAsJsonArray() { [EOL]     if (isJsonArray()) { [EOL]         return (JsonArray) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Array."); [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] return (JsonArray) this; [LINE] public JsonArray getAsJsonArray() { [EOL]     if (isJsonArray()) { [EOL]         return (JsonArray) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Array."); [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] public JsonPrimitive getAsJsonPrimitive() { [LINE] public JsonPrimitive getAsJsonPrimitive() { [EOL]     if (isJsonPrimitive()) { [EOL]         return (JsonPrimitive) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Primitive."); [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] if (isJsonPrimitive()) { [LINE] public JsonPrimitive getAsJsonPrimitive() { [EOL]     if (isJsonPrimitive()) { [EOL]         return (JsonPrimitive) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Primitive."); [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] return (JsonPrimitive) this; [LINE] public JsonPrimitive getAsJsonPrimitive() { [EOL]     if (isJsonPrimitive()) { [EOL]         return (JsonPrimitive) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Primitive."); [EOL] } public boolean isJsonArray(); public boolean isJsonObject(); public boolean isJsonPrimitive(); public boolean isJsonNull(); public JsonObject getAsJsonObject(); public JsonArray getAsJsonArray(); public JsonPrimitive getAsJsonPrimitive(); public JsonNull getAsJsonNull(); public boolean getAsBoolean();  Boolean getAsBooleanWrapper(); public Number getAsNumber(); public String getAsString(); public double getAsDouble(); public float getAsFloat(); public long getAsLong(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public short getAsShort();  Object getAsObject(); public String toString(); protected abstract void toString(Appendable sb, Escaper escaper) throws IOException; Escaper BASIC_ESCAPER=Optional[new Escaper(false)]
 [LINE] ObjectTypePair(Object obj, Type type, boolean preserveType) { [LINE] ObjectTypePair(Object obj, Type type, boolean preserveType) { [EOL]     this.obj = obj; [EOL]     this.type = type; [EOL]     this.preserveType = preserveType; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] this.obj = obj; [LINE] ObjectTypePair(Object obj, Type type, boolean preserveType) { [EOL]     this.obj = obj; [EOL]     this.type = type; [EOL]     this.preserveType = preserveType; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] this.type = type; [LINE] ObjectTypePair(Object obj, Type type, boolean preserveType) { [EOL]     this.obj = obj; [EOL]     this.type = type; [EOL]     this.preserveType = preserveType; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] this.preserveType = preserveType; [LINE] ObjectTypePair(Object obj, Type type, boolean preserveType) { [EOL]     this.obj = obj; [EOL]     this.type = type; [EOL]     this.preserveType = preserveType; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] Object getObject() { [LINE] Object getObject() { [EOL]     return obj; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] return obj; [LINE] Object getObject() { [EOL]     return obj; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] Type getType() { [LINE] Type getType() { [EOL]     return type; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] return type; [LINE] Type getType() { [EOL]     return type; [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] @Override [LINE] @Override [EOL] public String toString() { [EOL]     return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [LINE] @Override [EOL] public String toString() { [EOL]     return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler( [LINE] <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] HANDLER handler = null; [LINE] <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] if (!preserveType && obj != null) { [LINE] <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] handler = handlers.getHandlerFor(type); [LINE] <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [LINE] <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }  ObjectTypePair(Object obj, Type type, boolean preserveType);  Object getObject();  void setObject(Object obj);  Type getType(); public String toString();  Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers);  ObjectTypePair toMoreSpecificType();  static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass); public int hashCode(); public boolean equals(Object obj); public boolean isPreserveType(); Object obj; Type type; boolean preserveType
 [LINE] public void addProperty(String property, String value) { [LINE] public void addProperty(String property, String value) { [EOL]     add(property, createJsonElement(value)); [EOL] } public JsonObject(); public void add(String property, JsonElement value); public JsonElement remove(String property); public void addProperty(String property, String value); public void addProperty(String property, Number value); public void addProperty(String property, Boolean value); public void addProperty(String property, Character value); private JsonElement createJsonElement(Object value); public Set<Map.Entry<String, JsonElement>> entrySet(); public boolean has(String memberName); public JsonElement get(String memberName); public JsonPrimitive getAsJsonPrimitive(String memberName); public JsonArray getAsJsonArray(String memberName); public JsonObject getAsJsonObject(String memberName); protected void toString(Appendable sb, Escaper escaper) throws IOException; Map<String, JsonElement> members
 [LINE] add(property, createJsonElement(value)); [LINE] public void addProperty(String property, String value) { [EOL]     add(property, createJsonElement(value)); [EOL] } public JsonObject(); public void add(String property, JsonElement value); public JsonElement remove(String property); public void addProperty(String property, String value); public void addProperty(String property, Number value); public void addProperty(String property, Boolean value); public void addProperty(String property, Character value); private JsonElement createJsonElement(Object value); public Set<Map.Entry<String, JsonElement>> entrySet(); public boolean has(String memberName); public JsonElement get(String memberName); public JsonPrimitive getAsJsonPrimitive(String memberName); public JsonArray getAsJsonArray(String memberName); public JsonObject getAsJsonObject(String memberName); protected void toString(Appendable sb, Escaper escaper) throws IOException; Map<String, JsonElement> members
 [LINE] public void addProperty(String property, Character value) { [LINE] public void addProperty(String property, Character value) { [EOL]     add(property, createJsonElement(value)); [EOL] } public JsonObject(); public void add(String property, JsonElement value); public JsonElement remove(String property); public void addProperty(String property, String value); public void addProperty(String property, Number value); public void addProperty(String property, Boolean value); public void addProperty(String property, Character value); private JsonElement createJsonElement(Object value); public Set<Map.Entry<String, JsonElement>> entrySet(); public boolean has(String memberName); public JsonElement get(String memberName); public JsonPrimitive getAsJsonPrimitive(String memberName); public JsonArray getAsJsonArray(String memberName); public JsonObject getAsJsonObject(String memberName); protected void toString(Appendable sb, Escaper escaper) throws IOException; Map<String, JsonElement> members
 [LINE] add(property, createJsonElement(value)); [LINE] public void addProperty(String property, Character value) { [EOL]     add(property, createJsonElement(value)); [EOL] } public JsonObject(); public void add(String property, JsonElement value); public JsonElement remove(String property); public void addProperty(String property, String value); public void addProperty(String property, Number value); public void addProperty(String property, Boolean value); public void addProperty(String property, Character value); private JsonElement createJsonElement(Object value); public Set<Map.Entry<String, JsonElement>> entrySet(); public boolean has(String memberName); public JsonElement get(String memberName); public JsonPrimitive getAsJsonPrimitive(String memberName); public JsonArray getAsJsonArray(String memberName); public JsonObject getAsJsonObject(String memberName); protected void toString(Appendable sb, Escaper escaper) throws IOException; Map<String, JsonElement> members
 [LINE] sb.append(','); [LINE] @Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] } public JsonObject(); public void add(String property, JsonElement value); public JsonElement remove(String property); public void addProperty(String property, String value); public void addProperty(String property, Number value); public void addProperty(String property, Boolean value); public void addProperty(String property, Character value); private JsonElement createJsonElement(Object value); public Set<Map.Entry<String, JsonElement>> entrySet(); public boolean has(String memberName); public JsonElement get(String memberName); public JsonPrimitive getAsJsonPrimitive(String memberName); public JsonArray getAsJsonArray(String memberName); public JsonObject getAsJsonObject(String memberName); protected void toString(Appendable sb, Escaper escaper) throws IOException; Map<String, JsonElement> members
