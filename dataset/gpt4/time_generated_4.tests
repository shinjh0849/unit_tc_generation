public void testGetFieldTypeWithValidIndex() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = dateTime.getFieldType(0); [EOL] assertNotNull(fieldType); [EOL] assertEquals(DateTimeFieldType.year(), fieldType); [EOL] }
public void testGetFieldTypeWithInvalidIndex() { [EOL] DateTime dateTime = new DateTime(); [EOL] try { [EOL] dateTime.getFieldType(-1); [EOL] fail("Should have thrown an exception for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] try { [EOL] dateTime.getFieldType(100); [EOL] fail("Should have thrown an exception for index too large"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testIndexOfSupportedWithSupportedType() { [EOL] DateTimeFieldType supportedType = DateTimeFieldType.year(); [EOL] int index = instance.indexOfSupported(supportedType); [EOL] assertTrue(index >= 0); [EOL] }
public void testIndexOfSupportedWithUnsupportedType() { [EOL] DateTimeFieldType unsupportedType = DateTimeFieldType.hourOfDay(); [EOL] try { [EOL] instance.indexOfSupported(unsupportedType); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field 'hourOfDay' is not supported", ex.getMessage()); [EOL] } [EOL] }
public void testEquals_SameObject() { [EOL] ReadablePartial partial = createReadablePartial(); [EOL] assertTrue(partial.equals(partial)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadablePartial partial = createReadablePartial(); [EOL] assertFalse(partial.equals(new Object())); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadablePartial partial = createReadablePartial(); [EOL] assertFalse(partial.equals(null)); [EOL] } [EOL] public void testEquals_DifferentSize() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentSize(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_DifferentValues() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentValues(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_DifferentFieldTypes() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentFieldTypes(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_DifferentChronology() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartialWithDifferentChronology(); [EOL] assertFalse(partial1.equals(partial2)); [EOL] } [EOL] public void testEquals_EqualObjects() { [EOL] ReadablePartial partial1 = createReadablePartial(); [EOL] ReadablePartial partial2 = createReadablePartial(); [EOL] assertTrue(partial1.equals(partial2)); [EOL] }
public void testHashCode_Empty() { [EOL] initializeEmptyInstance(); [EOL] int expected = 157 + getChronology().hashCode(); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCode_SingleField() { [EOL] initializeSingleFieldInstance(); [EOL] int expected = 157; [EOL] expected = 23 * expected + getValue(0); [EOL] expected = 23 * expected + getFieldType(0).hashCode(); [EOL] expected += getChronology().hashCode(); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCode_MultipleFields() { [EOL] initializeMultipleFieldsInstance(); [EOL] int expected = 157; [EOL] for (int i = 0, isize = size(); i < isize; i++) { [EOL] expected = 23 * expected + getValue(i); [EOL] expected = 23 * expected + getFieldType(i).hashCode(); [EOL] } [EOL] expected += getChronology().hashCode(); [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial mockPartial = createMockPartial(); [EOL] int result = mockPartial.compareTo(mockPartial); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_DifferentSize() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithSize(2); [EOL] ReadablePartial mockPartial2 = createMockPartialWithSize(3); [EOL] try { [EOL] mockPartial1.compareTo(mockPartial2); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testCompareTo_DifferentFieldTypes() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithFieldTypes(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithFieldTypes(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth()}); [EOL] try { [EOL] mockPartial1.compareTo(mockPartial2); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] } [EOL] public void testCompareTo_GreaterValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{5, 10}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{5, 9}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCompareTo_LesserValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{5, 8}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{5, 10}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_EqualValue() { [EOL] ReadablePartial mockPartial1 = createMockPartialWithValues(new int[]{5, 10}); [EOL] ReadablePartial mockPartial2 = createMockPartialWithValues(new int[]{5, 10}); [EOL] int result = mockPartial1.compareTo(mockPartial2); [EOL] assertEquals(0, result); [EOL] }
public void testIsBefore_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] LocalTime time = new LocalTime(); [EOL] time.isBefore(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsBefore_PartialBefore_ReturnsTrue() { [EOL] LocalTime time = new LocalTime(10, 0); // Assuming LocalTime is the class where isBefore is defined [EOL] LocalTime earlier = new LocalTime(9, 0); [EOL] assertTrue(time.isBefore(earlier)); [EOL] }
public void testIsBefore_PartialAfter_ReturnsFalse() { [EOL] LocalTime time = new LocalTime(10, 0); [EOL] LocalTime later = new LocalTime(11, 0); [EOL] assertFalse(time.isBefore(later)); [EOL] }
public void testIsEqual_NullPartial_ThrowsIllegalArgumentException() { [EOL] try { [EOL] boolean result = isEqual(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Partial cannot be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testIsEqual_EqualPartials_ReturnsTrue() { [EOL] ReadablePartial partialMock = mock(ReadablePartial.class); [EOL] when(compareTo(partialMock)).thenReturn(0); [EOL] boolean result = isEqual(partialMock); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsEqual_NonEqualPartials_ReturnsFalse() { [EOL] ReadablePartial partialMock = mock(ReadablePartial.class); [EOL] when(compareTo(partialMock)).thenReturn(1); [EOL] boolean result = isEqual(partialMock); [EOL] assertFalse(result); [EOL] }
public void testToStringWithNullFormatter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] String result = testDateTime.toString(null); [EOL] assertNotNull(result); [EOL] assertEquals(testDateTime.toString(), result); [EOL] }
public void testToStringWithNonNullFormatter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] String result = testDateTime.toString(formatter); [EOL] assertNotNull(result); [EOL] assertEquals(formatter.print(testDateTime), result); [EOL] }
public void testYearMonthDay_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] } [EOL] public void testYearMonthDay_NoArgs() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] } [EOL] public void testYearMonthDay_DateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonthDay ymd = new YearMonthDay(zone); [EOL] assertNotNull(ymd); [EOL] assertEquals(zone, ymd.getChronology().getZone()); [EOL] } [EOL] public void testYearMonthDay_Long() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] } [EOL] public void testYearMonthDay_LongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] } [EOL] public void testYearMonthDay_Object() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertNotNull(ymd); [EOL] } [EOL] public void testYearMonthDay_ObjectChronology() { [EOL] Date date = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(date, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] } [EOL] public void testYearMonthDay_Ints() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] } [EOL] public void testYearMonthDay_IntsChronology() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] } [EOL] public void testYearMonthDay_YearMonthDayInts() { [EOL] YearMonthDay base = new YearMonthDay(); [EOL] int[] values = new int[] {2023, 4, 1}; [EOL] YearMonthDay ymd = new YearMonthDay(base, values); [EOL] assertNotNull(ymd); [EOL] } [EOL] public void testYearMonthDay_YearMonthDayChronology() { [EOL] YearMonthDay base = new YearMonthDay(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(base, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] } [EOL] public void testYearMonthDay_Property() { [EOL] YearMonthDay base = new YearMonthDay(); [EOL] int fieldIndex = 0; [EOL] YearMonthDay.Property property = new YearMonthDay.Property(base, fieldIndex); [EOL] assertNotNull(property); [EOL] } [EOL] public void testYearMonthDay_fromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(ymd); [EOL] } [EOL] public void testYearMonthDay_fromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = YearMonthDay.fromDateFields(date); [EOL] assertNotNull(ymd); [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case YEAR: [EOL] return chrono.year(); [EOL] case MONTH_OF_YEAR: [EOL] return chrono.monthOfYear(); [EOL] case DAY_OF_MONTH: [EOL] return chrono.dayOfMonth(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public void testGetFieldTypes() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTimeFieldType[] fieldTypes = ymd.getFieldTypes(); [EOL] assertNotNull(fieldTypes); [EOL] assertEquals(3, fieldTypes.length); [EOL] assertEquals(DateTimeFieldType.year(), fieldTypes[0]); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), fieldTypes[1]); [EOL] assertEquals(DateTimeFieldType.dayOfMonth(), fieldTypes[2]); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayChronologyConstructor() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertNotNull(ymd); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayObjectConstructor() { [EOL] Instant instant = new Instant(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayObjectChronologyConstructor() { [EOL] Instant instant = new Instant(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayIntIntIntConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntIntIntChronologyConstructor() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] assertSame(chrono, ymd.getChronology()); [EOL] }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (value == getValue(index)) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).set(this, index, newValues, value); [EOL] return new YearMonthDay(this, newValues); [EOL] }
public void testPlus_withNullPeriod() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay result = ymd.plus(null); [EOL] assertEquals(ymd, result); [EOL] }
public void testPlus_withValidPeriod() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] YearMonthDay result = ymd.plus(period); [EOL] YearMonthDay expected = ymd.withPeriodAdded(period, 1); [EOL] assertEquals(expected, result); [EOL] }
public void testWithYear_ValidYear() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay updatedYMD = ymd.withYear(2021); [EOL] assertEquals(2021, updatedYMD.getYear()); [EOL] assertEquals(1, updatedYMD.getMonthOfYear()); [EOL] assertEquals(1, updatedYMD.getDayOfMonth()); [EOL] }
public void testWithYear_SameYear() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay updatedYMD = ymd.withYear(2020); [EOL] assertSame(ymd, updatedYMD); [EOL] }
public YearMonthDay withMonthOfYear(int monthOfYear) { [EOL] int[] newValues = getValues(); [EOL] newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL] return new YearMonthDay(this, newValues); [EOL] } [EOL] public YearMonthDay() { } [EOL] public YearMonthDay(DateTimeZone zone) { } [EOL] public YearMonthDay(Chronology chronology) { } [EOL] public YearMonthDay(long instant) { } [EOL] public YearMonthDay(long instant, Chronology chronology) { } [EOL] public YearMonthDay(Object instant) { } [EOL] public YearMonthDay(Object instant, Chronology chronology) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { } [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { } [EOL] YearMonthDay(YearMonthDay partial, int[] values) { } [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono) { } [EOL] Property(YearMonthDay partial, int fieldIndex) { } [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar) { } [EOL] public static YearMonthDay fromDateFields(Date date) { } [EOL] public int size() { } [EOL] protected DateTimeField getField(int index, Chronology chrono) { } [EOL] public DateTimeFieldType getFieldType(int index) { } [EOL] public DateTimeFieldType[] getFieldTypes() { } [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology) { } [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value) { } [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) { } [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) { } [EOL] public YearMonthDay plus(ReadablePeriod period) { } [EOL] public YearMonthDay plusYears(int years) { } [EOL] public YearMonthDay plusMonths(int months) { } [EOL] public YearMonthDay plusDays(int days) { } [EOL] public YearMonthDay minus(ReadablePeriod period) { } [EOL] public YearMonthDay minusYears(int years) { } [EOL] public YearMonthDay minusMonths(int months) { } [EOL] public YearMonthDay minusDays(int days) { } [EOL] public Property property(DateTimeFieldType type) { } [EOL] public LocalDate toLocalDate() { } [EOL] public DateTime toDateTimeAtMidnight() { } [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone) { } [EOL] public DateTime toDateTimeAtCurrentTime() { } [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { } [EOL] public DateMidnight toDateMidnight() { } [EOL] public DateMidnight toDateMidnight(DateTimeZone zone) { } [EOL] public DateTime toDateTime(TimeOfDay time) { } [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone) { } [EOL] public Interval toInterval() { } [EOL] public Interval toInterval(DateTimeZone zone) { } [EOL] public int getYear() { } [EOL] public int getMonthOfYear() { } [EOL] public int getDayOfMonth() { } [EOL] public YearMonthDay withYear(int year) { } [EOL] public YearMonthDay withMonthOfYear(int monthOfYear) { } [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth) { } [EOL] public Property year() { } [EOL] public Property monthOfYear() { } [EOL] public Property dayOfMonth() { } [EOL] public String toString() { } [EOL] public DateTimeField getField() { } [EOL] protected ReadablePartial getReadablePartial() { } [EOL] public YearMonthDay getYearMonthDay() { } [EOL] public int get() { } [EOL] public YearMonthDay addToCopy(int valueToAdd) { } [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd) { } [EOL] public YearMonthDay setCopy(int value) { } [EOL] public YearMonthDay setCopy(String text, Locale locale) { } [EOL] public YearMonthDay setCopy(String text) { } [EOL] public YearMonthDay withMaximumValue() { } [EOL] public YearMonthDay withMinimumValue() { } [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testWithDayOfMonth_ValidDay() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 3, 1); [EOL] YearMonthDay updatedYMD = ymd.withDayOfMonth(15); [EOL] assertEquals(15, updatedYMD.getDayOfMonth()); [EOL] }
public void testWithDayOfMonth_InvalidDay() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 3, 1); [EOL] try { [EOL] ymd.withDayOfMonth(32); [EOL] fail("Should have thrown an exception for invalid day of month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfMonth_MinDay() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 3, 1); [EOL] YearMonthDay updatedYMD = ymd.withDayOfMonth(1); [EOL] assertEquals(1, updatedYMD.getDayOfMonth()); [EOL] }
public void testWithDayOfMonth_MaxDay() { [EOL] YearMonthDay ymd = new YearMonthDay(2023, 3, 31); [EOL] YearMonthDay updatedYMD = ymd.withDayOfMonth(31); [EOL] assertEquals(31, updatedYMD.getDayOfMonth()); [EOL] }
public void testGetChronology_WithNullChrono() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] Chronology expectedChrono = ISOChronology.getInstance(); [EOL] when(mockPartial.getChronology()).thenReturn(null); [EOL] when(DateTimeUtils.getChronology(null)).thenReturn(expectedChrono); [EOL] Chronology actualChrono = getChronology(mockPartial, null); [EOL] assertSame(expectedChrono, actualChrono); [EOL] }
public void testGetChronology_WithNonNullChrono() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] Chronology nonNullChrono = ISOChronology.getInstance(); [EOL] Chronology actualChrono = getChronology(mockPartial, nonNullChrono); [EOL] assertSame(nonNullChrono, actualChrono); [EOL] }
public void testPeriodConstructorWithStartAndEndInstant() { [EOL] ReadableInstant startInstant = new Instant(0); [EOL] ReadableInstant endInstant = new Instant(1000); [EOL] Period period = new Period(startInstant, endInstant); [EOL] assertNotNull(period); [EOL] assertEquals(startInstant, period.getStart()); [EOL] assertEquals(endInstant, period.getEnd()); [EOL] }
public void testPeriodWithNonNullArguments() { [EOL] ReadableInstant startInstant = new DateTime(); [EOL] ReadableDuration duration = new Duration(1000L); [EOL] Period period = new Period(startInstant, duration); [EOL] assertNotNull(period); [EOL] }
public void testPeriodWithNullType() { [EOL] Object period = new Object(); [EOL] PeriodType type = null; [EOL] Period result = new Period(period, type); [EOL] assertNotNull(result); [EOL] }
public void testPeriodWithNonNullType() { [EOL] Object period = new Object(); [EOL] PeriodType type = PeriodType.standard(); [EOL] Period result = new Period(period, type); [EOL] assertNotNull(result); [EOL] assertEquals(type, result.getPeriodType()); [EOL] }
public Period toPeriod() { [EOL] return this; [EOL] }
public void testWithField_NullField_ThrowsIllegalArgumentException() { [EOL] Period period = new Period(); [EOL] try { [EOL] period.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidField_ReturnsNewPeriod() { [EOL] Period period = new Period(); [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); [EOL] int newValue = 10; [EOL] Period newPeriod = period.withField(fieldType, newValue); [EOL] assertNotNull(newPeriod); [EOL] assertEquals(newValue, newPeriod.get(fieldType)); [EOL] }
public void testPlusWithNullPeriod() { [EOL] Period testPeriod = new Period(); [EOL] Period result = testPeriod.plus(null); [EOL] assertSame("Period should be the same when adding null", testPeriod, result); [EOL] }
public void testPlusWithNonEmptyPeriod() { [EOL] Period testPeriod = new Period(); [EOL] ReadablePeriod nonEmptyPeriod = new MockPeriod(); [EOL] Period result = testPeriod.plus(nonEmptyPeriod); [EOL] assertNotNull("Result should not be null", result); [EOL] assertNotSame("Result should not be the same object as testPeriod", testPeriod, result); [EOL] assertEquals("Years should be added correctly", nonEmptyPeriod.get(DurationFieldType.YEARS_TYPE), result.getYears()); [EOL] assertEquals("Months should be added correctly", nonEmptyPeriod.get(DurationFieldType.MONTHS_TYPE), result.getMonths()); [EOL] assertEquals("Weeks should be added correctly", nonEmptyPeriod.get(DurationFieldType.WEEKS_TYPE), result.getWeeks()); [EOL] assertEquals("Days should be added correctly", nonEmptyPeriod.get(DurationFieldType.DAYS_TYPE), result.getDays()); [EOL] assertEquals("Hours should be added correctly", nonEmptyPeriod.get(DurationFieldType.HOURS_TYPE), result.getHours()); [EOL] assertEquals("Minutes should be added correctly", nonEmptyPeriod.get(DurationFieldType.MINUTES_TYPE), result.getMinutes()); [EOL] assertEquals("Seconds should be added correctly", nonEmptyPeriod.get(DurationFieldType.SECONDS_TYPE), result.getSeconds()); [EOL] assertEquals("Millis should be added correctly", nonEmptyPeriod.get(DurationFieldType.MILLIS_TYPE), result.getMillis()); [EOL] }
public void testToStandardSecondsWithNoYearsAndMonths() { [EOL] TimePeriod period = new TimePeriod(); [EOL] period.setMillis(1000); // 1 second in milliseconds [EOL] period.setSeconds(1); [EOL] period.setMinutes(1); [EOL] period.setHours(1); [EOL] period.setDays(1); [EOL] period.setWeeks(1); [EOL] Seconds result = period.toStandardSeconds(); [EOL] long expectedSeconds = 1 // from millis [EOL] + 1 // set seconds [EOL] + 60 // 1 minute [EOL] + 3600 // 1 hour [EOL] + 86400 // 1 day [EOL] + 604800; // 1 week [EOL] assertEquals(expectedSeconds, result.getSeconds()); [EOL] }
public void testToStandardSecondsWithMaxIntValues() { [EOL] TimePeriod period = new TimePeriod(); [EOL] period.setMillis(Long.MAX_VALUE); [EOL] period.setSeconds(Integer.MAX_VALUE); [EOL] period.setMinutes(Integer.MAX_VALUE); [EOL] period.setHours(Integer.MAX_VALUE); [EOL] period.setDays(Integer.MAX_VALUE); [EOL] period.setWeeks(Integer.MAX_VALUE); [EOL] Seconds result = period.toStandardSeconds(); [EOL] assertEquals(Integer.MAX_VALUE, result.getSeconds()); [EOL] }
public void testToStandardDurationWithAllFields() { [EOL] Duration testDuration = new Duration(1, 1, 1, 1, 1, 1, 1, 1); [EOL] Duration result = testDuration.toStandardDuration(); [EOL] long expectedMillis = 1; // Assuming getMillis() returns 1 [EOL] expectedMillis += 1 * DateTimeConstants.MILLIS_PER_SECOND; [EOL] expectedMillis += 1 * DateTimeConstants.MILLIS_PER_MINUTE; [EOL] expectedMillis += 1 * DateTimeConstants.MILLIS_PER_HOUR; [EOL] expectedMillis += 1 * DateTimeConstants.MILLIS_PER_DAY; [EOL] expectedMillis += 1 * DateTimeConstants.MILLIS_PER_WEEK; [EOL] assertEquals(new Duration(expectedMillis), result); [EOL] }
public void testToStandardDurationWithZeroValues() { [EOL] Duration testDuration = new Duration(0, 0, 0, 0, 0, 0, 0, 0); [EOL] Duration result = testDuration.toStandardDuration(); [EOL] assertEquals(new Duration(0), result); [EOL] }
public void testToStandardDurationWithNegativeValues() { [EOL] Duration testDuration = new Duration(-1, -1, -1, -1, -1, -1, -1, -1); [EOL] Duration result = testDuration.toStandardDuration(); [EOL] long expectedMillis = -1; // Assuming getMillis() returns -1 [EOL] expectedMillis += -1 * DateTimeConstants.MILLIS_PER_SECOND; [EOL] expectedMillis += -1 * DateTimeConstants.MILLIS_PER_MINUTE; [EOL] expectedMillis += -1 * DateTimeConstants.MILLIS_PER_HOUR; [EOL] expectedMillis += -1 * DateTimeConstants.MILLIS_PER_DAY; [EOL] expectedMillis += -1 * DateTimeConstants.MILLIS_PER_WEEK; [EOL] assertEquals(new Duration(expectedMillis), result); [EOL] }
public void testCheckYearsAndMonths_WithMonths() { [EOL] TimePeriod period = new TimePeriod(0, 1, 0); // Assuming TimePeriod is a class with a constructor that takes years, months, and days [EOL] try { [EOL] period.checkYearsAndMonths("Days"); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Cannot convert to Days as this period contains months and months vary in length", e.getMessage()); [EOL] } [EOL] }
public void testCheckYearsAndMonths_WithYears() { [EOL] TimePeriod period = new TimePeriod(1, 0, 0); // Assuming TimePeriod is a class with a constructor that takes years, months, and days [EOL] try { [EOL] period.checkYearsAndMonths("Days"); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Cannot convert to Days as this period contains years and years vary in length", e.getMessage()); [EOL] } [EOL] }
public void testCheckYearsAndMonths_WithNeitherYearsNorMonths() { [EOL] TimePeriod period = new TimePeriod(0, 0, 10); // Assuming TimePeriod is a class with a constructor that takes years, months, and days [EOL] period.checkYearsAndMonths("Days"); // This should pass without exception [EOL] }
public void testGetYear_AtStartOfCycle() { [EOL] long instant = MILLIS_YEAR_1; // Start of cycle [EOL] int expectedYear = 1; // Expected year at the start of cycle [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_WithinCycleNonLeapYear() { [EOL] long instant = MILLIS_YEAR_1 + (10 * MILLIS_PER_SHORT_YEAR); // 10 years into the cycle [EOL] int expectedYear = 11; // Year should be 11 since we start counting from year 1 [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_WithinCycleLeapYear() { [EOL] long instant = MILLIS_YEAR_1 + ((CYCLE / 2) * MILLIS_PER_LONG_YEAR); // Halfway through the cycle [EOL] int expectedYear = (CYCLE / 2) + 1; // Year should be halfway through the cycle plus one [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_AtEndOfCycle() { [EOL] long instant = MILLIS_YEAR_1 + (MILLIS_PER_CYCLE - MILLIS_PER_SHORT_YEAR); // Just before the end of the cycle [EOL] int expectedYear = CYCLE; // Year should be the last year of the cycle [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYear_AtStartOfNextCycle() { [EOL] long instant = MILLIS_YEAR_1 + MILLIS_PER_CYCLE; // Start of the next cycle [EOL] int expectedYear = CYCLE + 1; // Year should be the first year of the next cycle [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetDayOfMonthAtEndOfYear() { [EOL] long millis = /* value representing the last day of a 354-day year */; [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(30, result); [EOL] } [EOL] public void testGetDayOfMonthAtBeginningOfYear() { [EOL] long millis = /* value representing the first day of a year */; [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testGetDayOfMonthAtEndOfLongMonth() { [EOL] long millis = /* value representing the last day of a long month */; [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(30, result); [EOL] } [EOL] public void testGetDayOfMonthAtEndOfShortMonth() { [EOL] long millis = /* value representing the last day of a short month */; [EOL] int result = getDayOfMonth(millis); [EOL] assertEquals(29, result); [EOL] }
public void testIsLeapYear_LeapYear() { [EOL] assertTrue(isLeapYear(2020)); [EOL] }
public void testIsLeapYear_NotLeapYear() { [EOL] assertFalse(isLeapYear(2019)); [EOL] }
public void testGetDaysInYearMonth_DecemberLeapYear() { [EOL] int year = 2020; // Example leap year [EOL] int month = 12; [EOL] int expectedDays = LONG_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_DecemberNonLeapYear() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 12; [EOL] int expectedDays = SHORT_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_LongMonth() { [EOL] int year = 2021; [EOL] int month = 7; // Example of a long month that is not December [EOL] int expectedDays = LONG_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_ShortMonth() { [EOL] int year = 2021; [EOL] int month = 6; // Example of a short month [EOL] int expectedDays = SHORT_MONTH_LENGTH; [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetMonthOfYearAtYearStart() { [EOL] long millisAtYearStart = getYearMillis(2021); // Assume this method exists and returns millis for the start of the year [EOL] int expectedMonth = 1; [EOL] int actualMonth = getMonthOfYear(millisAtYearStart, 2021); [EOL] assertEquals(expectedMonth, actualMonth); [EOL] }
public void testGetMonthOfYearAtYearEnd() { [EOL] long millisAtYearEnd = getYearMillis(2021) + (DateTimeConstants.MILLIS_PER_DAY * 354); // Assume this method exists and returns millis for the end of the year [EOL] int expectedMonth = 12; [EOL] int actualMonth = getMonthOfYear(millisAtYearEnd, 2021); [EOL] assertEquals(expectedMonth, actualMonth); [EOL] }
public void testGetMonthOfYearMidYear() { [EOL] long millisMidYear = getYearMillis(2021) + (DateTimeConstants.MILLIS_PER_DAY * 177); // Assume this method exists and returns millis for the middle of the year [EOL] int expectedMonth = ((177 * 2) / MONTH_PAIR_LENGTH) + 1; // MONTH_PAIR_LENGTH should be defined somewhere in the code [EOL] int actualMonth = getMonthOfYear(millisMidYear, 2021); [EOL] assertEquals(expectedMonth, actualMonth); [EOL] }
public void testIsLeapYear_LeapYear() { [EOL] Time time = new Time(); [EOL] int year = 2024; // Assuming 2024 is a leap year in the pattern [EOL] boolean result = time.isLeapYear(year); [EOL] assertTrue(result); [EOL] }
public void testIsLeapYear_NonLeapYear() { [EOL] Time time = new Time(); [EOL] int year = 2023; // Assuming 2023 is not a leap year in the pattern [EOL] boolean result = time.isLeapYear(year); [EOL] assertFalse(result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNotNull() { [EOL] Chronology mockBaseChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockBaseChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iChronology.getBase()).thenReturn(mockBaseChronology); [EOL] long result = iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNull_GregorianBeforeCutover() { [EOL] Mockito.when(iChronology.getBase()).thenReturn(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt())).thenReturn(1234567890L); [EOL] iChronology.iCutoverMillis = 1234567900L; [EOL] long result = iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNull_GregorianAfterCutover() { [EOL] Mockito.when(iChronology.getBase()).thenReturn(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt())).thenReturn(1234567890L); [EOL] iChronology.iCutoverMillis = 1234567880L; [EOL] long result = iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_BaseChronologyNull_JulianBeforeCutover_IllegalArgumentException() { [EOL] Mockito.when(iChronology.getBase()).thenReturn(null); [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(anyInt(), anyInt(), anyInt(), anyInt())).thenReturn(1234567890L); [EOL] iChronology.iCutoverMillis = 1234567880L; [EOL] try { [EOL] iChronology.getDateTimeMillis(2020, 1, 1, 0); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Specified date does not exist", e.getMessage()); [EOL] } [EOL] }
public void testGetDateTimeMillis_BaseChronologyNotNull() { [EOL] Chronology mockBaseChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(mockBaseChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] setBase(mockBaseChronology); // Assuming there is a method to set the base chronology [EOL] long result = getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_GregorianChronologyWithoutException() { [EOL] setBase(null); // Assuming there is a method to set the base chronology to null [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] long result = getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_GregorianChronologyWithExceptionNotFebruary29() { [EOL] setBase(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenThrow(new IllegalFieldValueException("field", "value")); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] }); [EOL] }
public void testGetDateTimeMillis_GregorianChronologyWithExceptionFebruary29() { [EOL] setBase(null); [EOL] IllegalFieldValueException ex = new IllegalFieldValueException("field", "value"); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.eq(29), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenThrow(ex); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.eq(28), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iCutoverMillis).thenReturn(1234567891L); [EOL] long result = getDateTimeMillis(2021, 2, 29, 0, 0, 0, 0); [EOL] assertEquals(1234567890L, result); [EOL] }
public void testGetDateTimeMillis_JulianChronologyBeforeCutover() { [EOL] setBase(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567889L); [EOL] Mockito.when(iCutoverMillis).thenReturn(1234567890L); [EOL] long result = getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] assertEquals(1234567889L, result); [EOL] }
public void testGetDateTimeMillis_JulianChronologyAfterCutover() { [EOL] setBase(null); [EOL] Mockito.when(iGregorianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iJulianChronology.getDateTimeMillis(Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt(), Mockito.anyInt())).thenReturn(1234567890L); [EOL] Mockito.when(iCutoverMillis).thenReturn(1234567889L); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] getDateTimeMillis(2021, 1, 1, 0, 0, 0, 0); [EOL] }); [EOL] }
public void testEquals_Reflexive() { [EOL] GJChronology chrono = GJChronology.getInstance(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] }
public void testEquals_SameValues() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentCutover() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.UTC, 87654321L, 4); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentMinimumDays() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 2); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentZone() { [EOL] GJChronology chrono1 = GJChronology.getInstance(DateTimeZone.UTC, 12345678L, 4); [EOL] GJChronology chrono2 = GJChronology.getInstance(DateTimeZone.forID("Europe/Paris"), 12345678L, 4); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_Null() { [EOL] GJChronology chrono = GJChronology.getInstance(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_NonGJChronology() { [EOL] GJChronology chrono = GJChronology.getInstance(); [EOL] Object obj = new Object(); [EOL] assertFalse(chrono.equals(obj)); [EOL] }
protected void assemble(Fields fields) { [EOL] Object[] params = (Object[]) getParam(); [EOL] JulianChronology julian = (JulianChronology) params[0]; [EOL] GregorianChronology gregorian = (GregorianChronology) params[1]; [EOL] Instant cutoverInstant = (Instant) params[2]; [EOL] iCutoverMillis = cutoverInstant.getMillis(); [EOL] iJulianChronology = julian; [EOL] iGregorianChronology = gregorian; [EOL] iCutoverInstant = cutoverInstant; [EOL] if (getBase() != null) { [EOL] return; [EOL] } [EOL] if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis); [EOL] fields.copyFieldsFrom(gregorian); [EOL] if (gregorian.millisOfDay().get(iCutoverMillis) == 0) { [EOL] fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis); [EOL] fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis); [EOL] fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis); [EOL] fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis); [EOL] fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis); [EOL] fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis); [EOL] fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis); [EOL] fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis); [EOL] fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis); [EOL] fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(), fields.clockhourOfHalfday, iCutoverMillis); [EOL] fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis); [EOL] } [EOL] { [EOL] fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis); [EOL] } [EOL] { [EOL] fields.year = new ImpreciseCutoverField(julian.year(), fields.year, iCutoverMillis); [EOL] fields.years = fields.year.getDurationField(); [EOL] fields.yearOfEra = new ImpreciseCutoverField(julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis); [EOL] fields.centuryOfEra = new ImpreciseCutoverField(julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis); [EOL] fields.centuries = fields.centuryOfEra.getDurationField(); [EOL] fields.yearOfCentury = new ImpreciseCutoverField(julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis); [EOL] fields.monthOfYear = new ImpreciseCutoverField(julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis); [EOL] fields.months = fields.monthOfYear.getDurationField(); [EOL] fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, null, iCutoverMillis, true); [EOL] fields.weekyears = fields.weekyear.getDurationField(); [EOL] fields.weekyearOfCentury = new ImpreciseCutoverField(julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis); [EOL] } [EOL] { [EOL] long cutover = gregorian.year().roundCeiling(iCutoverMillis); [EOL] fields.dayOfYear = new CutoverField(julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false); [EOL] } [EOL] { [EOL] long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis); [EOL] fields.weekOfWeekyear = new CutoverField(julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true); [EOL] } [EOL] { [EOL] CutoverField cf = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis); [EOL] cf.iRangeDurationField = fields.months; [EOL] fields.dayOfMonth = cf; [EOL] } [EOL] }
public void testJulianToGregorianByWeekyear() { [EOL] long instant = SOME_JULIAN_DATE_AS_INSTANT; [EOL] long expectedGregorian = EXPECTED_GREGORIAN_DATE_AS_INSTANT; [EOL] long actualGregorian = julianToGregorianByWeekyear(instant); [EOL] assertEquals(expectedGregorian, actualGregorian); [EOL] }
public void testGetAsTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] String expected = "Five"; // Assuming iGregorianField.getAsText(5, Locale.ENGLISH) returns "Five" [EOL] String actual = getAsText(fieldValue, locale); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAsShortTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] String result = instance.getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetAsShortTextWithValidFieldValueAndDifferentLocale() { [EOL] int fieldValue = 5; [EOL] Locale locale = new Locale("es", "ES"); [EOL] String result = instance.getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testJulianToGregorianWithConvertByWeekyearTrue() { [EOL] setConvertByWeekyear(true); [EOL] long instant = SOME_JULIAN_INSTANT; [EOL] long expected = EXPECTED_GREGORIAN_INSTANT; [EOL] long actual = julianToGregorian(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testJulianToGregorianWithConvertByWeekyearFalse() { [EOL] setConvertByWeekyear(false); [EOL] long instant = SOME_JULIAN_INSTANT; [EOL] long expected = EXPECTED_GREGORIAN_INSTANT; [EOL] long actual = julianToGregorian(instant); [EOL] assertEquals(expected, actual); [EOL] }
public long add(long instant, int value) { [EOL] if (instant >= iCutover) { [EOL] instant = iGregorianField.add(instant, value); [EOL] if (instant < iCutover) { [EOL] if (instant + iGapDuration < iCutover) { [EOL] if (iConvertByWeekyear) { [EOL] int wyear = iGregorianChronology.weekyear().get(instant); [EOL] if (wyear <= 0) { [EOL] instant = iGregorianChronology.weekyear().add(instant, -1); [EOL] } [EOL] } else { [EOL] int year = iGregorianChronology.year().get(instant); [EOL] if (year <= 0) { [EOL] instant = iGregorianChronology.year().add(instant, -1); [EOL] } [EOL] } [EOL] instant = gregorianToJulian(instant); [EOL] } [EOL] } [EOL] } else { [EOL] instant = iJulianField.add(instant, value); [EOL] if (instant >= iCutover) { [EOL] if (instant - iGapDuration >= iCutover) { [EOL] instant = julianToGregorian(instant); [EOL] } [EOL] } [EOL] } [EOL] return instant; [EOL] }
public long add(long instant, long value) { [EOL] if (instant >= iCutover) { [EOL] instant = iGregorianField.add(instant, value); [EOL] if (instant < iCutover) { [EOL] if (instant + iGapDuration < iCutover) { [EOL] if (iConvertByWeekyear) { [EOL] int wyear = iGregorianChronology.weekyear().get(instant); [EOL] if (wyear <= 0) { [EOL] instant = iGregorianChronology.weekyear().add(instant, -1); [EOL] } [EOL] } else { [EOL] int year = iGregorianChronology.year().get(instant); [EOL] if (year <= 0) { [EOL] instant = iGregorianChronology.year().add(instant, -1); [EOL] } [EOL] } [EOL] instant = gregorianToJulian(instant); [EOL] } [EOL] } [EOL] } else { [EOL] instant = iJulianField.add(instant, value); [EOL] if (instant >= iCutover) { [EOL] if (instant - iGapDuration >= iCutover) { [EOL] instant = julianToGregorian(instant); [EOL] } [EOL] } [EOL] } [EOL] return instant; [EOL] }
public void testAdd() { [EOL] long instant = 1L; [EOL] long value = 1L; [EOL] long expected = 2L; // Assuming that iField.add(1L, 1L) should return 2L [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetChronologyWithNullChrono() { [EOL] Chronology result = getChronology(new Object(), null); [EOL] assertNotNull(result); [EOL] assertEquals(result, ISOChronology.getInstance()); [EOL] }
public void testGetChronologyWithNonNullChrono() { [EOL] Chronology inputChrono = GregorianChronology.getInstance(); [EOL] Chronology result = getChronology(new Object(), inputChrono); [EOL] assertNotNull(result); [EOL] assertSame(inputChrono, result); [EOL] }
public void testGet_WithMillisLessThanSkip() { [EOL] long millis = 10; // Assuming iSkip is greater than 10 [EOL] int expected = 11; // Assuming super.get(10) returns 10 [EOL] int actual = get(millis); [EOL] assertEquals(expected, actual); [EOL] }
public void testGet_WithMillisEqualToSkip() { [EOL] long millis = iSkip; // Assuming iSkip is a specific value [EOL] int expected = iSkip + 1; // Assuming super.get(iSkip) returns iSkip [EOL] int actual = get(millis); [EOL] assertEquals(expected, actual); [EOL] }
public void testGet_WithMillisGreaterThanSkip() { [EOL] long millis = 20; // Assuming iSkip is less than 20 [EOL] int expected = 20; // Assuming super.get(20) returns 20 [EOL] int actual = get(millis); [EOL] assertEquals(expected, actual); [EOL] }
public void testPeriodFormatterBuilderConstructor() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] assertNotNull(builder); [EOL] }
public void testToPrinter_WhenNotPrinter() { [EOL] PeriodType type = new PeriodType(); [EOL] type.iNotPrinter = true; [EOL] assertNull(type.toPrinter()); [EOL] }
public void testToPrinter_WhenIsPrinter() { [EOL] PeriodType type = new PeriodType(); [EOL] type.iNotPrinter = false; [EOL] assertNotNull(type.toPrinter()); [EOL] }
public void testToParser_WhenNotParser_ShouldReturnNull() { [EOL] PeriodFormatter period = new PeriodFormatterBuilder().toFormatter(); [EOL] period.iNotParser = true; [EOL] PeriodParser result = period.toParser(); [EOL] assertNull(result); [EOL] }
public void testToParser_WhenIsParser_ShouldReturnParser() { [EOL] PeriodFormatter period = new PeriodFormatterBuilder().toFormatter(); [EOL] period.iNotParser = false; [EOL] PeriodFormatter mockFormatter = mock(PeriodFormatter.class); [EOL] PeriodParser mockParser = mock(PeriodParser.class); [EOL] when(period.toFormatter()).thenReturn(mockFormatter); [EOL] when(mockFormatter.getParser()).thenReturn(mockParser); [EOL] PeriodParser result = period.toParser(); [EOL] assertSame(mockParser, result); [EOL] }
public void testClear_WithNullElementPairs() { [EOL] TimeFormatter formatter = new TimeFormatter(); [EOL] formatter.clear(); [EOL] assertEquals(1, formatter.iMinPrintedDigits); [EOL] assertEquals(TimeFormatter.PRINT_ZERO_RARELY_LAST, formatter.iPrintZeroSetting); [EOL] assertEquals(10, formatter.iMaxParsedDigits); [EOL] assertFalse(formatter.iRejectSignedValues); [EOL] assertNull(formatter.iPrefix); [EOL] assertNotNull(formatter.iElementPairs); [EOL] assertFalse(formatter.iNotPrinter); [EOL] assertFalse(formatter.iNotParser); [EOL] assertEquals(10, formatter.iFieldFormatters.length); [EOL] }
public void testClear_WithNonNullElementPairs() { [EOL] TimeFormatter formatter = new TimeFormatter(); [EOL] formatter.iElementPairs = new ArrayList<Object>(); [EOL] formatter.iElementPairs.add(new Object()); // Add an object to ensure clear() is called on a non-empty list [EOL] formatter.clear(); [EOL] assertEquals(1, formatter.iMinPrintedDigits); [EOL] assertEquals(TimeFormatter.PRINT_ZERO_RARELY_LAST, formatter.iPrintZeroSetting); [EOL] assertEquals(10, formatter.iMaxParsedDigits); [EOL] assertFalse(formatter.iRejectSignedValues); [EOL] assertNull(formatter.iPrefix); [EOL] assertNotNull(formatter.iElementPairs); [EOL] assertTrue(formatter.iElementPairs.isEmpty()); // Check that clear() was called on the list [EOL] assertFalse(formatter.iNotPrinter); [EOL] assertFalse(formatter.iNotParser); [EOL] assertEquals(10, formatter.iFieldFormatters.length); [EOL] }
public void testAppend_BothPrinterAndParserNull_ThrowsIllegalArgumentException() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.append(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No printer or parser supplied", e.getMessage()); [EOL] } [EOL] } [EOL] public void testAppend_OnlyPrinterNull_DoesNotThrowException() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] builder.append(null, parser); [EOL] } [EOL] public void testAppend_OnlyParserNull_DoesNotThrowException() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] builder.append(printer, null); [EOL] } [EOL] public void testAppend_NeitherPrinterNorParserNull_DoesNotThrowException() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodPrinter printer = mock(PeriodPrinter.class); [EOL] PeriodParser parser = mock(PeriodParser.class); [EOL] builder.append(printer, parser); [EOL] }
public void testAppendLiteralWithNonNull() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String literalText = "Text"; [EOL] builder.appendLiteral(literalText); [EOL] assertTrue(builder.hasLiteral(literalText)); [EOL] }
public void testAppendLiteralWithNull() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendLiteral(null); [EOL] fail("Should have thrown IllegalArgumentException for null literal"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Literal must not be null", e.getMessage()); [EOL] } [EOL] }
public void testPrintZeroIfSupported() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder returnedBuilder = builder.printZeroIfSupported(); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendPrefixWithNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.appendPrefix(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendPrefixWithNonNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String text = "Prefix"; [EOL] builder.appendPrefix(text); [EOL] }
public void testAppendPrefix_WithNonNullArguments() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendPrefix("Day", "Days"); [EOL] } [EOL] public void testAppendPrefix_WithNullSingularText() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendPrefix(null, "Days"); [EOL] fail("Expected IllegalArgumentException for null singularText"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAppendPrefix_WithNullPluralText() { [EOL] try { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendPrefix("Day", null); [EOL] fail("Expected IllegalArgumentException for null pluralText"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWeeks() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendWeeks(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isFieldAppended(PeriodType.weeks())); [EOL] }
public void testAppendSecondsWithMillis() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendSecondsWithMillis(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testAppendMillis() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendMillis(); [EOL] assertTrue(builder.hasFieldAppended(PeriodFieldType.millis())); [EOL] }
public void testAppendMillis3Digit() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendMillis3Digit(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testAppendSeparatorWithNonNullParameters() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String text = ","; [EOL] String finalText = ";"; [EOL] String[] variants = new String[] {"-", "--"}; [EOL] builder.appendSeparator(text, finalText, variants); [EOL] }
public void testAppendSeparatorWithNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String text = null; [EOL] String finalText = ";"; [EOL] String[] variants = new String[] {"-", "--"}; [EOL] builder.appendSeparator(text, finalText, variants); [EOL] }
public void testAppendSeparatorWithNullFinalText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String text = ","; [EOL] String finalText = null; [EOL] String[] variants = new String[] {"-", "--"}; [EOL] builder.appendSeparator(text, finalText, variants); [EOL] }
public void testAppendSeparatorWithNullVariants() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String text = ","; [EOL] String finalText = ";"; [EOL] String[] variants = null; [EOL] builder.appendSeparator(text, finalText, variants); [EOL] }
public void testAppendSeparatorWithEmptyVariants() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String text = ","; [EOL] String finalText = ";"; [EOL] String[] variants = new String[] {}; [EOL] builder.appendSeparator(text, finalText, variants); [EOL] }
public void testToFormatter_ThrowsIllegalStateException() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] boolean notPrinter = true; [EOL] boolean notParser = true; [EOL] try { [EOL] toFormatter(elementPairs, notPrinter, notParser); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Builder has created neither a printer nor a parser", e.getMessage()); [EOL] } [EOL] }
public void testToFormatter_WithSeparatorAndNullAfterParserPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Separator(null, null)); [EOL] boolean notPrinter = false; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertTrue(result.getPrinter() instanceof Separator); [EOL] assertTrue(result.getParser() instanceof Separator); [EOL] }
public void testToFormatter_WithNotPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] boolean notPrinter = true; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void testToFormatter_WithNotParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] boolean notPrinter = false; [EOL] boolean notParser = true; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNull(result.getParser()); [EOL] }
public void testToFormatter_WithPrinterAndParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); [EOL] elementPairs.add(new Object()); [EOL] boolean notPrinter = false; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void printToTest_withValidWriterAndValue() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] int value = 123; [EOL] printTo(writer, value); [EOL] assertEquals("Expected output text", writer.toString()); [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL] long valueLong = getFieldValue(period); [EOL] if (valueLong == Long.MAX_VALUE) { [EOL] return 0; [EOL] } [EOL] int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL] if (iFieldType >= SECONDS_MILLIS) { [EOL] sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL] sum++; [EOL] if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL] sum -= 4; [EOL] } [EOL] valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL] } [EOL] int value = (int) valueLong; [EOL] if (iPrefix != null) { [EOL] sum += iPrefix.calculatePrintedLength(value); [EOL] } [EOL] if (iSuffix != null) { [EOL] sum += iSuffix.calculatePrintedLength(value); [EOL] } [EOL] return sum; [EOL] }
public void testPrintToWithMaxValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(Long.MAX_VALUE); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithSecondsMillis() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123456789L); [EOL] when(iFieldType).thenReturn(SECONDS_MILLIS); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().contains(".789")); [EOL] }
public void testPrintToWithPrefix() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iPrefix = mock(Prefix.class); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] verify(iPrefix).printTo(buf, 123); [EOL] }
public void testPrintToWithMinDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iMinPrintedDigits = 2; [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().startsWith("0123")); [EOL] }
public void testPrintToWithSuffix() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(123L); [EOL] iSuffix = mock(Suffix.class); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] verify(iSuffix).printTo(buf, 123); [EOL] }
public void testPrintToWithNegativeValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] when(getFieldValue(period)).thenReturn(-123L); [EOL] when(iFieldType).thenReturn(SECONDS_MILLIS); [EOL] printTo(buf, period, Locale.ENGLISH); [EOL] assertTrue(buf.toString().startsWith("-0.123")); [EOL] }
public void testPrintTo_MaxValue() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(Long.MAX_VALUE); [EOL] printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockWriter, never()).write(anyString()); [EOL] verify(mockWriter, never()).write(any(char[].class), anyInt(), anyInt()); [EOL] }
public void testPrintTo_WithPrefix() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1234L); [EOL] when(iFieldType).thenReturn(SECONDS_MILLIS + 1); [EOL] Prefix mockPrefix = mock(Prefix.class); [EOL] iPrefix = mockPrefix; [EOL] printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockPrefix).printTo(eq(mockWriter), anyInt()); [EOL] }
public void testPrintTo_WithSuffix() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1234L); [EOL] when(iFieldType).thenReturn(SECONDS_MILLIS + 1); [EOL] Suffix mockSuffix = mock(Suffix.class); [EOL] iSuffix = mockSuffix; [EOL] printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockSuffix).printTo(eq(mockWriter), anyInt()); [EOL] }
public void testPrintTo_MinDigitsLessThanOne() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1234L); [EOL] when(iMinPrintedDigits).thenReturn(0); [EOL] printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockWriter).write(anyString()); [EOL] }
public void testPrintTo_MinDigitsGreaterThanOne() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1234L); [EOL] when(iMinPrintedDigits).thenReturn(2); [EOL] printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockWriter).write(anyString()); [EOL] }
public void testPrintTo_WithSecondsMillisField() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(getFieldValue(mockPeriod)).thenReturn(1234L); [EOL] when(iFieldType).thenReturn(SECONDS_MILLIS); [EOL] printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockWriter).write('.'); [EOL] verify(mockWriter).write(anyString()); [EOL] }
public void testParseInto_PositionGreaterThanTextLength_PrintZeroAlways() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = ""; [EOL] int position = 1; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithPrintZeroAlways(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_PositionGreaterThanTextLength_PrintZeroNever() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = ""; [EOL] int position = 1; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithPrintZeroNever(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] } [EOL] public void testParseInto_PrefixNotNull_PositionNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "prefix"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithPrefix(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result < 0); [EOL] } [EOL] public void testParseInto_PrefixNotNull_PositionPositive_MustParseFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "prefix"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithPrefixAndPrintZeroNever(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result >= 0); [EOL] } [EOL] public void testParseInto_SuffixNotNull_MustParseFalse_SuffixPosNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithSuffixAndPrintZeroNever(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result < 0); [EOL] } [EOL] public void testParseInto_SuffixNotNull_MustParseFalse_SuffixPosPositive() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithSuffixAndPrintZeroNever(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result >= 0); [EOL] } [EOL] public void testParseInto_MustParseFalse_UnsupportedFieldType() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "unsupported"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithUnsupportedFieldType(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] } [EOL] public void testParseInto_HasDigitsFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "nondigit"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatter(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_SuffixPosPositive_LengthNotEqualSuffixPos() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithSuffix(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] } [EOL] public void testParseInto_FieldTypeNotSecondsMillis() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithFieldTypeNotSecondsMillis(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result > 0); [EOL] } [EOL] public void testParseInto_FieldTypeSecondsMillis_FractPosNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithFieldTypeSecondsMillis(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result > 0); [EOL] } [EOL] public void testParseInto_FieldTypeSecondsMillis_FractPosPositive() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123.456"; [EOL] int position = 0; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithFieldTypeSecondsMillis(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result > 0); [EOL] } [EOL] public void testParseInto_SuffixNotNull_PositionPositive() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123suffix"; [EOL] int position = 3; [EOL] Locale locale = Locale.ENGLISH; [EOL] PeriodFormatter formatter = createFormatterWithSuffix(); [EOL] int result = formatter.parseInto(mockPeriod, text, position, locale); [EOL] assertTrue(result >= 0); [EOL] }
public void testParseIntWithLengthGreaterThanNine() { [EOL] int result = parseInt("12345678901", 0, 10); [EOL] assertEquals(1234567890, result); [EOL] }
public void testParseIntWithLengthLessThanOne() { [EOL] int result = parseInt("0", 0, 0); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntWithNegativeNumber() { [EOL] int result = parseInt("-123", 0, 4); [EOL] assertEquals(-123, result); [EOL] }
public void testParseIntWithPositiveNumber() { [EOL] int result = parseInt("123", 0, 3); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithLengthDecreasingToLessThanZero() { [EOL] int result = parseInt("-", 0, 1); [EOL] assertEquals(0, result); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeNotSupported() { [EOL] ReadablePeriod period = createPeriodWithUnsupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] setFieldType(UNSUPPORTED_FIELD_TYPE); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeSupported() { [EOL] ReadablePeriod period = createPeriodWithSupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] setFieldType(SUPPORTED_FIELD_TYPE); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_PrintZeroNotAlwaysAndFieldTypeNotSupported() { [EOL] ReadablePeriod period = createPeriodWithUnsupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_NOT_ALWAYS); [EOL] setFieldType(UNSUPPORTED_FIELD_TYPE); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_PrintZeroNotAlwaysAndFieldTypeSupported() { [EOL] ReadablePeriod period = createPeriodWithSupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_NOT_ALWAYS); [EOL] setFieldType(SUPPORTED_FIELD_TYPE); [EOL] long result = getFieldValue(period); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetFieldValue_ValueIsZeroAndPrintZeroNever() { [EOL] ReadablePeriod period = createPeriodWithValueZero(); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyLastAndIsZeroAndFormatterIsThis() { [EOL] ReadablePeriod period = createPeriodWithValueZero(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] setFormatterForFieldType(this); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyFirstAndIsZeroAndFormatterIsThis() { [EOL] ReadablePeriod period = createPeriodWithValueZero(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] setFormatterForFieldType(this); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyLastAndIsNotZeroOrFormatterIsNotThis() { [EOL] ReadablePeriod period = createPeriodWithNonZeroValueOrDifferentFormatter(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_ValueIsZeroAndPrintZeroRarelyFirstAndIsNotZeroOrFormatterIsNotThis() { [EOL] ReadablePeriod period = createPeriodWithNonZeroValueOrDifferentFormatter(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testSetFieldValueWithYears() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = YEARS; [EOL] int value = 10; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setYears(value); [EOL] }
public void testSetFieldValueWithMonths() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MONTHS; [EOL] int value = 5; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMonths(value); [EOL] }
public void testSetFieldValueWithWeeks() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = WEEKS; [EOL] int value = 3; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setWeeks(value); [EOL] }
public void testSetFieldValueWithDays() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = DAYS; [EOL] int value = 7; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setDays(value); [EOL] }
public void testSetFieldValueWithHours() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = HOURS; [EOL] int value = 24; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setHours(value); [EOL] }
public void testSetFieldValueWithMinutes() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MINUTES; [EOL] int value = 45; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMinutes(value); [EOL] }
public void testSetFieldValueWithSeconds() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = SECONDS; [EOL] int value = 30; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setSeconds(value); [EOL] }
public void testSetFieldValueWithMillis() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MILLIS; [EOL] int value = 100; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMillis(value); [EOL] }
public void testSetFieldValueWithInvalidField() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = -1; // Assuming -1 is not a valid field [EOL] int value = 100; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verifyNoInteractions(mockPeriod); [EOL] }
public void testLiteral() { [EOL] String expectedText = "someText"; [EOL] YourClass instance = new YourClass(); [EOL] instance.Literal(expectedText); [EOL] assertEquals(expectedText, instance.iText); [EOL] }
public void printTo_withValidPeriodAndLocale_writesTextToWriter() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = mock(Locale.class); [EOL] PeriodFormatter formatter = new PeriodFormatter(null, "TestText"); [EOL] formatter.printTo(mockWriter, mockPeriod, mockLocale); [EOL] verify(mockWriter).write("TestText"); [EOL] }
public void testParseInto_MatchAtPosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "prefixMatchSuffix"; [EOL] int position = 6; [EOL] Locale mockLocale = createMockLocale(); [EOL] int result = parseInto(mockPeriod, periodStr, position, mockLocale); [EOL] assertEquals(position + "Match".length(), result); [EOL] } [EOL] public void testParseInto_NoMatch() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "prefixMismatchSuffix"; [EOL] int position = 6; [EOL] Locale mockLocale = createMockLocale(); [EOL] int result = parseInto(mockPeriod, periodStr, position, mockLocale); [EOL] assertEquals(~position, result); [EOL] }
public void testSeparatorWithNullFinalTextAndNoVariants() { [EOL] String text = "Text"; [EOL] String finalText = null; [EOL] String[] variants = null; [EOL] PeriodPrinter beforePrinter = null; [EOL] PeriodParser beforeParser = null; [EOL] boolean useBefore = false; [EOL] boolean useAfter = false; [EOL] Separator separator = new Separator(text, finalText, variants, beforePrinter, beforeParser, useBefore, useAfter); [EOL] assertEquals("Text should be set correctly", text, separator.iText); [EOL] assertEquals("Final text should be null", finalText, separator.iFinalText); [EOL] assertNotNull("Parsed forms should not be null", separator.iParsedForms); [EOL] assertEquals("Parsed forms should contain only one element", 1, separator.iParsedForms.length); [EOL] assertEquals("Parsed forms should contain the text", text, separator.iParsedForms[0]); [EOL] assertNull("Before printer should be null", separator.iBeforePrinter); [EOL] assertNull("Before parser should be null", separator.iBeforeParser); [EOL] assertFalse("Use before should be false", separator.iUseBefore); [EOL] assertFalse("Use after should be false", separator.iUseAfter); [EOL] }
public void testSeparatorWithEqualTextAndFinalTextAndNoVariants() { [EOL] String text = "Text"; [EOL] String finalText = "Text"; [EOL] String[] variants = null; [EOL] PeriodPrinter beforePrinter = null; [EOL] PeriodParser beforeParser = null; [EOL] boolean useBefore = true; [EOL] boolean useAfter = true; [EOL] Separator separator = new Separator(text, finalText, variants, beforePrinter, beforeParser, useBefore, useAfter); [EOL] assertEquals("Text should be set correctly", text, separator.iText); [EOL] assertEquals("Final text should be equal to text", text, separator.iFinalText); [EOL] assertNotNull("Parsed forms should not be null", separator.iParsedForms); [EOL] assertEquals("Parsed forms should contain only one element", 1, separator.iParsedForms.length); [EOL] assertEquals("Parsed forms should contain the text", text, separator.iParsedForms[0]); [EOL] assertNull("Before printer should be null", separator.iBeforePrinter); [EOL] assertNull("Before parser should be null", separator.iBeforeParser); [EOL] assertTrue("Use before should be true", separator.iUseBefore); [EOL] assertTrue("Use after should be true", separator.iUseAfter); [EOL] }
public void testSeparatorWithDifferentTextFinalTextAndVariants() { [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] String[] variants = new String[] {"Variant1", "Variant2"}; [EOL] PeriodPrinter beforePrinter = null; [EOL] PeriodParser beforeParser = null; [EOL] boolean useBefore = false; [EOL] boolean useAfter = true; [EOL] Separator separator = new Separator(text, finalText, variants, beforePrinter, beforeParser, useBefore, useAfter); [EOL] assertEquals("Text should be set correctly", text, separator.iText); [EOL] assertEquals("Final text should be set correctly", finalText, separator.iFinalText); [EOL] assertNotNull("Parsed forms should not be null", separator.iParsedForms); [EOL] assertEquals("Parsed forms should contain all elements", 3, separator.iParsedForms.length); [EOL] assertTrue("Parsed forms should contain the text", Arrays.asList(separator.iParsedForms).contains(text)); [EOL] assertTrue("Parsed forms should contain the final text", Arrays.asList(separator.iParsedForms).contains(finalText)); [EOL] assertTrue("Parsed forms should contain variant1", Arrays.asList(separator.iParsedForms).contains("Variant1")); [EOL] assertTrue("Parsed forms should contain variant2", Arrays.asList(separator.iParsedForms).contains("Variant2")); [EOL] assertNull("Before printer should be null", separator.iBeforePrinter); [EOL] assertNull("Before parser should be null", separator.iBeforeParser); [EOL] assertFalse("Use before should be false", separator.iUseBefore); [EOL] assertTrue("Use after should be true", separator.iUseAfter); [EOL] }
public void testPrintToWithBeforeAndAfter() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, Locale.US)).thenReturn(1); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 2, Locale.US)).thenReturn(2); [EOL] TimePrinter timePrinter = new TimePrinter(mockBeforePrinter, mockAfterPrinter, true, true, "Text", "FinalText"); [EOL] timePrinter.printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockBeforePrinter).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockAfterPrinter).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockWriter).write("Text"); [EOL] }
public void testPrintToWithBeforeOnly() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, Locale.US)).thenReturn(1); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 2, Locale.US)).thenReturn(0); [EOL] TimePrinter timePrinter = new TimePrinter(mockBeforePrinter, mockAfterPrinter, true, false, "Text", "FinalText"); [EOL] timePrinter.printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockBeforePrinter).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockAfterPrinter, never()).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockWriter).write("Text"); [EOL] }
public void testPrintToWithAfterOnly() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, Locale.US)).thenReturn(0); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, Locale.US)).thenReturn(1); [EOL] TimePrinter timePrinter = new TimePrinter(mockBeforePrinter, mockAfterPrinter, false, true, "Text", "FinalText"); [EOL] timePrinter.printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockBeforePrinter, never()).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockAfterPrinter).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockWriter).write("Text"); [EOL] }
public void testPrintToWithNeitherBeforeNorAfter() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, Locale.US)).thenReturn(0); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, Locale.US)).thenReturn(0); [EOL] TimePrinter timePrinter = new TimePrinter(mockBeforePrinter, mockAfterPrinter, false, false, "Text", "FinalText"); [EOL] timePrinter.printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockBeforePrinter, never()).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockAfterPrinter, never()).printTo(mockWriter, mockPeriod, Locale.US); [EOL] verify(mockWriter, never()).write(anyString()); [EOL] }
public void testParseInto_PositionNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = -1; [EOL] Locale locale = Locale.getDefault(); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(position, result); [EOL] }
public void testParseInto_BeforeParserMovesPosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Assuming iBeforeParser moves position from 0 to 1 [EOL] setBeforeParserBehaviour(mockPeriod, periodStr, position, locale, newPosition); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(newPosition, result); [EOL] }
public void testParseInto_FoundParsedForm() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Assuming iBeforeParser moves position from 0 to 1 [EOL] setBeforeParserBehaviour(mockPeriod, periodStr, position, locale, newPosition); [EOL] setParsedForms(new String[]{"Form"}); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(newPosition + "Form".length(), result); [EOL] }
public void testParseInto_NotFoundParsedFormAndUseBeforeFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Assuming iBeforeParser moves position from 0 to 1 [EOL] setBeforeParserBehaviour(mockPeriod, periodStr, position, locale, newPosition); [EOL] setParsedForms(new String[]{}); [EOL] setUseBefore(false); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(~newPosition, result); [EOL] }
public void testParseInto_AfterParserNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Assuming iBeforeParser moves position from 0 to 1 [EOL] setBeforeParserBehaviour(mockPeriod, periodStr, position, locale, newPosition); [EOL] setAfterParserBehaviour(mockPeriod, periodStr, newPosition, locale, -1); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(-1, result); [EOL] }
public void testParseInto_FoundAndPositionUnchanged() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] int newPosition = 1; // Assuming iBeforeParser moves position from 0 to 1 [EOL] setBeforeParserBehaviour(mockPeriod, periodStr, position, locale, newPosition); [EOL] setParsedForms(new String[]{"Form"}); [EOL] setAfterParserBehaviour(mockPeriod, periodStr, newPosition + "Form".length(), locale, newPosition + "Form".length()); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals(~(newPosition + "Form".length()), result); [EOL] }
public void testPrintToWithEmptyPrintersArray() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter[] emptyPrinters = new PeriodPrinter[0]; [EOL] PeriodFormatter formatter = new PeriodFormatter(emptyPrinters, null); [EOL] formatter.printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verifyNoInteractions(mockWriter); [EOL] }
public void testPrintToWithSinglePrinter() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockPrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter[] singlePrinter = new PeriodPrinter[] {mockPrinter}; [EOL] PeriodFormatter formatter = new PeriodFormatter(singlePrinter, null); [EOL] formatter.printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockPrinter).printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] }
public void testPrintToWithMultiplePrinters() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] PeriodPrinter mockPrinter1 = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockPrinter2 = mock(PeriodPrinter.class); [EOL] PeriodPrinter[] multiplePrinters = new PeriodPrinter[] {mockPrinter1, mockPrinter2}; [EOL] PeriodFormatter formatter = new PeriodFormatter(multiplePrinters, null); [EOL] formatter.printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockPrinter1).printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] verify(mockPrinter2).printTo(mockWriter, mockPeriod, Locale.ENGLISH); [EOL] }
public void testAdd_WithZeroYears() { [EOL] long instant = System.currentTimeMillis(); [EOL] long result = add(instant, 0); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_WithPositiveYears() { [EOL] long instant = System.currentTimeMillis(); [EOL] int yearsToAdd = 5; [EOL] long expected = set(instant, get(instant) + yearsToAdd); [EOL] long result = add(instant, yearsToAdd); [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithNegativeYears() { [EOL] long instant = System.currentTimeMillis(); [EOL] int yearsToSubtract = -5; [EOL] long expected = set(instant, get(instant) + yearsToSubtract); [EOL] long result = add(instant, yearsToSubtract); [EOL] assertEquals(expected, result); [EOL] }
public long set(long instant, int year) { [EOL] FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL] int thisWeekyear = get(instant); [EOL] if (thisWeekyear == year) { [EOL] return instant; [EOL] } [EOL] int thisDow = iChronology.getDayOfWeek(instant); [EOL] int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL] int weeksInToYear = iChronology.getWeeksInYear(year); [EOL] int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL] int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL] if (setToWeek > maxOutWeeks) { [EOL] setToWeek = maxOutWeeks; [EOL] } [EOL] long workInstant = instant; [EOL] workInstant = iChronology.setYear(workInstant, year); [EOL] int workWoyYear = get(workInstant); [EOL] if (workWoyYear < year) { [EOL] workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL] } else if (workWoyYear > year) { [EOL] workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL] } [EOL] int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL] workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL] workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL] return workInstant; [EOL] }
public void testRoundFloor_AtStartOfWeek() { [EOL] when(iChronology.weekOfWeekyear().roundFloor(anyLong())).thenReturn(START_OF_WEEK_TIMESTAMP); [EOL] when(iChronology.getWeekOfWeekyear(START_OF_WEEK_TIMESTAMP)).thenReturn(1); [EOL] long result = roundFloor(ANY_TIMESTAMP); [EOL] assertEquals(START_OF_WEEK_TIMESTAMP, result); [EOL] }
public void testRoundFloor_NotAtStartOfWeek() { [EOL] when(iChronology.weekOfWeekyear().roundFloor(anyLong())).thenReturn(START_OF_WEEK_TIMESTAMP); [EOL] when(iChronology.getWeekOfWeekyear(START_OF_WEEK_TIMESTAMP)).thenReturn(2); [EOL] long result = roundFloor(ANY_TIMESTAMP); [EOL] assertEquals(START_OF_WEEK_TIMESTAMP - DateTimeConstants.MILLIS_PER_WEEK, result); [EOL] }
public static DateTimeFormatter forStyle(String style) { [EOL] return createFormatterForStyle(style); [EOL] }
public static DateTimeFormatter shortDateTime() { [EOL] return createFormatterForStyleIndex(SHORT, SHORT); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) { [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }]
public static DateTimeFormatter mediumDateTime() { [EOL] return createFormatterForStyleIndex(MEDIUM, MEDIUM); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] int length = pattern.length(); [EOL] int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] String token = parseToken(pattern, indexRef); [EOL] i = indexRef[0]; [EOL] int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] builder.appendEraText(); [EOL] break; [EOL] case 'C': [EOL] builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL] break; [EOL] case 'x': [EOL] case 'y': [EOL] case 'Y': [EOL] if (tokenLen == 2) { [EOL] boolean lenientParse = true; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] lenientParse = false; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL] break; [EOL] case 'y': [EOL] case 'Y': [EOL] default: [EOL] builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL] break; [EOL] } [EOL] } else { [EOL] int maxDigits = 9; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] maxDigits = tokenLen; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendWeekyear(tokenLen, maxDigits); [EOL] break; [EOL] case 'y': [EOL] builder.appendYear(tokenLen, maxDigits); [EOL] break; [EOL] case 'Y': [EOL] builder.appendYearOfEra(tokenLen, maxDigits); [EOL] break; [EOL] } [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 3) { [EOL] if (tokenLen >= 4) { [EOL] builder.appendMonthOfYearText(); [EOL] } else { [EOL] builder.appendMonthOfYearShortText(); [EOL] } [EOL] } else { [EOL] builder.appendMonthOfYear(tokenLen); [EOL] } [EOL] break; [EOL] case 'd': [EOL] builder.appendDayOfMonth(tokenLen); [EOL] break; [EOL] case 'a': [EOL] builder.appendHalfdayOfDayText(); [EOL] break; [EOL] case 'h': [EOL] builder.appendClockhourOfHalfday(tokenLen); [EOL] break; [EOL] case 'H': [EOL] builder.appendHourOfDay(tokenLen); [EOL] break; [EOL] case 'k': [EOL] builder.appendClockhourOfDay(tokenLen); [EOL] break; [EOL] case 'K': [EOL] builder.appendHourOfHalfday(tokenLen); [EOL] break; [EOL] case 'm': [EOL] builder.appendMinuteOfHour(tokenLen); [EOL] break; [EOL] case 's': [EOL] builder.appendSecondOfMinute(tokenLen); [EOL] break; [EOL] case 'S': [EOL] builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL] break; [EOL] case 'e': [EOL] builder.appendDayOfWeek(tokenLen); [EOL] break; [EOL] case 'E': [EOL] if (tokenLen >= 4) { [EOL] builder.appendDayOfWeekText(); [EOL] } else { [EOL] builder.appendDayOfWeekShortText(); [EOL] } [EOL] break; [EOL] case 'D': [EOL] builder.appendDayOfYear(tokenLen); [EOL] break; [EOL] case 'w': [EOL] builder.appendWeekOfWeekyear(tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] builder.appendTimeZoneName(); [EOL] } else { [EOL] builder.appendTimeZoneShortName(null); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL] } else if (tokenLen == 2) { [EOL] builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL] } else { [EOL] builder.appendTimeZoneId(); [EOL] } [EOL] break; [EOL] case '\'': [EOL] String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] builder.appendLiteral(sub.charAt(0)); [EOL] } else { [EOL] builder.appendLiteral(new String(sub)); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] } [EOL] }
public void testCreateFormatterForStyleWithNullStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle(null); [EOL] fail("Should have thrown IllegalArgumentException for null style"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid style specification: null", e.getMessage()); [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidLengthStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("S"); [EOL] fail("Should have thrown IllegalArgumentException for style with invalid length"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid style specification: S", e.getMessage()); [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("--"); [EOL] fail("Should have thrown IllegalArgumentException for style '--'"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Style '--' is invalid", e.getMessage()); [EOL] } [EOL] }
public void testCreateFormatterForStyleWithValidStyle() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.createFormatterForStyle("SS"); [EOL] assertNotNull(formatter); [EOL] }
public void testCreateFormatterForStyleWithValidDateAndInvalidTimeStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("SN"); [EOL] fail("Should have thrown IllegalArgumentException for valid date style and invalid time style"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Style 'SN' is invalid", e.getMessage()); [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidDateAndValidTimeStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("NS"); [EOL] fail("Should have thrown IllegalArgumentException for invalid date style and valid time style"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Style 'NS' is invalid", e.getMessage()); [EOL] } [EOL] }
private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) { [EOL] int index = ((dateStyle << 2) + dateStyle) + timeStyle; [EOL] if (index >= STYLE_CACHE.length) { [EOL] return createDateTimeFormatter(dateStyle, timeStyle); [EOL] } [EOL] DateTimeFormatter f = null; [EOL] synchronized (STYLE_CACHE) { [EOL] f = STYLE_CACHE[index]; [EOL] if (f == null) { [EOL] f = createDateTimeFormatter(dateStyle, timeStyle); [EOL] STYLE_CACHE[index] = f; [EOL] } [EOL] } [EOL] return f; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }]
public void testCreateDateTimeFormatterWithDateNone() { [EOL] DateTimeFormatter formatter = createDateTimeFormatter(NONE, MEDIUM); [EOL] assertNotNull(formatter); [EOL] assertEquals(new DateTimeFormatter(new StyleFormatter(NONE, MEDIUM, TIME), new StyleFormatter(NONE, MEDIUM, TIME)), formatter); [EOL] }
public void testCreateDateTimeFormatterWithTimeNone() { [EOL] DateTimeFormatter formatter = createDateTimeFormatter(MEDIUM, NONE); [EOL] assertNotNull(formatter); [EOL] assertEquals(new DateTimeFormatter(new StyleFormatter(MEDIUM, NONE, DATE), new StyleFormatter(MEDIUM, NONE, DATE)), formatter); [EOL] }
public void testCreateDateTimeFormatterWithDateTime() { [EOL] DateTimeFormatter formatter = createDateTimeFormatter(MEDIUM, MEDIUM); [EOL] assertNotNull(formatter); [EOL] assertEquals(new DateTimeFormatter(new StyleFormatter(MEDIUM, MEDIUM, DATETIME), new StyleFormatter(MEDIUM, MEDIUM, DATETIME)), formatter); [EOL] }
public void testSelectStyleWithShort() { [EOL] int result = selectStyle('S'); [EOL] assertEquals(SHORT, result); [EOL] }
public void testSelectStyleWithMedium() { [EOL] int result = selectStyle('M'); [EOL] assertEquals(MEDIUM, result); [EOL] }
public void testSelectStyleWithLong() { [EOL] int result = selectStyle('L'); [EOL] assertEquals(LONG, result); [EOL] }
public void testSelectStyleWithFull() { [EOL] int result = selectStyle('F'); [EOL] assertEquals(FULL, result); [EOL] }
public void testSelectStyleWithNone() { [EOL] int result = selectStyle('-'); [EOL] assertEquals(NONE, result); [EOL] }
public void testSelectStyleWithInvalidCharacter() { [EOL] try { [EOL] selectStyle('X'); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid style character: X", e.getMessage()); [EOL] } [EOL] }
StyleFormatter(int dateStyle, int timeStyle, int type) { [EOL] super(); [EOL] iDateStyle = dateStyle; [EOL] iTimeStyle = timeStyle; [EOL] iType = type; [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L;; [EOL] @Override; [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {; [EOL] return size() > PATTERN_CACHE_SIZE;; [EOL] }; [EOL] }]
public int estimatePrintedLength() { [EOL] return 40; [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL] DateTimePrinter p = getFormatter(locale).getPrinter(); [EOL] p.printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); [EOL] return p.parseInto(bucket, text, position); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) { [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
private DateTimeFormatter getFormatter(Locale locale) { [EOL] locale = (locale == null ? Locale.getDefault() : locale); [EOL] String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString(); [EOL] DateTimeFormatter f = null; [EOL] synchronized (cCache) { [EOL] f = cCache.get(key); [EOL] if (f == null) { [EOL] String pattern = getPattern(locale); [EOL] f = DateTimeFormat.forPattern(pattern); [EOL] cCache.put(key, f); [EOL] } [EOL] } [EOL] return f; [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) { [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }]
String getPattern(Locale locale) { [EOL] DateFormat f = null; [EOL] switch(iType) { [EOL] case DATE: [EOL] f = DateFormat.getDateInstance(iDateStyle, locale); [EOL] break; [EOL] case TIME: [EOL] f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL] break; [EOL] case DATETIME: [EOL] f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL] break; [EOL] } [EOL] if (f instanceof SimpleDateFormat == false) { [EOL] throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL] } [EOL] return ((SimpleDateFormat) f).toPattern(); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }]
public void testParseValidDuration() { [EOL] String validDurationStr = "PT20.345S"; [EOL] Duration result = Duration.parse(validDurationStr); [EOL] assertNotNull(result); [EOL] assertEquals("PT20.345S", result.toString()); [EOL] }
public void testParseInvalidDuration() { [EOL] String invalidDurationStr = "InvalidDuration"; [EOL] try { [EOL] Duration.parse(invalidDurationStr); [EOL] fail("Should have thrown an exception due to invalid format"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testStandardMinutes_Zero() { [EOL] Duration result = Time.standardMinutes(0); [EOL] assertEquals(Duration.ZERO, result); [EOL] }
public void testStandardMinutes_Positive() { [EOL] long minutes = 1; [EOL] Duration result = Time.standardMinutes(minutes); [EOL] assertEquals(new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE), result); [EOL] }
public void testStandardMinutes_Negative() { [EOL] long minutes = -1; [EOL] Duration result = Time.standardMinutes(minutes); [EOL] assertEquals(new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE), result); [EOL] }
public void testDurationConstructor() { [EOL] long expectedDuration = 1000L; [EOL] Duration duration = new Duration(expectedDuration); [EOL] assertEquals(expectedDuration, duration.toMillis()); [EOL] }
public void testGetStandardHours() { [EOL] Time time = new Time(); [EOL] time.setMillis(DateTimeConstants.MILLIS_PER_HOUR * 5); [EOL] long standardHours = time.getStandardHours(); [EOL] assertEquals(5, standardHours); [EOL] }
public void testGetStandardHoursZero() { [EOL] Time time = new Time(); [EOL] time.setMillis(0); [EOL] long standardHours = time.getStandardHours(); [EOL] assertEquals(0, standardHours); [EOL] }
public void testGetStandardMinutes_ZeroMillis() { [EOL] Time time = new Time(0); [EOL] long minutes = time.getStandardMinutes(); [EOL] assertEquals(0, minutes); [EOL] }
public void testGetStandardMinutes_PositiveMillis() { [EOL] Time time = new Time(DateTimeConstants.MILLIS_PER_MINUTE); [EOL] long minutes = time.getStandardMinutes(); [EOL] assertEquals(1, minutes); [EOL] }
public void testGetStandardMinutes_NegativeMillis() { [EOL] Time time = new Time(-DateTimeConstants.MILLIS_PER_MINUTE); [EOL] long minutes = time.getStandardMinutes(); [EOL] assertEquals(-1, minutes); [EOL] }
public void testToStandardHours() { [EOL] Time time = new Time(5); [EOL] Hours result = time.toStandardHours(); [EOL] assertEquals(5, result.getHours()); [EOL] }
public void testToStandardHoursWithLargeValue() { [EOL] Time time = new Time(Integer.MAX_VALUE); [EOL] Hours result = time.toStandardHours(); [EOL] assertEquals(Integer.MAX_VALUE, result.getHours()); [EOL] }
public void testToStandardHoursWithNegativeValue() { [EOL] Time time = new Time(-5); [EOL] Hours result = time.toStandardHours(); [EOL] assertEquals(-5, result.getHours()); [EOL] }
public void testToStandardMinutes() { [EOL] Time time = new Time(); // Replace with actual constructor if needed [EOL] when(time.getStandardMinutes()).thenReturn(60L); // Mocking the getStandardMinutes method [EOL] Minutes result = time.toStandardMinutes(); [EOL] assertEquals(60, result.getMinutes());
time = new Time(); // Replace with actual constructor if needed [EOL] when(time.getStandardMinutes()).thenReturn((long) Integer.MAX_VALUE); [EOL] result = time.toStandardMinutes(); [EOL] assertEquals(Integer.MAX_VALUE, result.getMinutes());
time = new Time(); // Replace with actual constructor if needed [EOL] when(time.getStandardMinutes()).thenReturn((long) Integer.MAX_VALUE + 1); [EOL] assertThrows(ArithmeticException.class, () -> { [EOL] time.toStandardMinutes(); [EOL] }); [EOL] }
public void testWithDurationAdded_ZeroDurationToAdd() { [EOL] Duration initialDuration = new Duration(1000); [EOL] Duration resultDuration = initialDuration.withDurationAdded(0, 1); [EOL] assertEquals(initialDuration, resultDuration); [EOL] } [EOL] public void testWithDurationAdded_ZeroScalar() { [EOL] Duration initialDuration = new Duration(1000); [EOL] Duration resultDuration = initialDuration.withDurationAdded(10, 0); [EOL] assertEquals(initialDuration, resultDuration); [EOL] } [EOL] public void testWithDurationAdded_NonZeroDurationToAddAndScalar() { [EOL] Duration initialDuration = new Duration(1000); [EOL] Duration resultDuration = initialDuration.withDurationAdded(10, 2); [EOL] long expectedMillis = 1000 + (10 * 2); [EOL] assertEquals(new Duration(expectedMillis), resultDuration); [EOL] } [EOL] public void testWithDurationAdded_MaxValueOverflow() { [EOL] Duration initialDuration = new Duration(Long.MAX_VALUE); [EOL] try { [EOL] initialDuration.withDurationAdded(1, 1); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testWithDurationAdded_MinValueOverflow() { [EOL] Duration initialDuration = new Duration(Long.MIN_VALUE); [EOL] try { [EOL] initialDuration.withDurationAdded(1, -1); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testWithDurationAdded_NullDuration() { [EOL] Duration baseDuration = new Duration(1000L); [EOL] Duration result = baseDuration.withDurationAdded(null, 1); [EOL] assertSame("Duration should be the same as base duration when added duration is null", baseDuration, result); [EOL] } [EOL] public void testWithDurationAdded_ZeroScalar() { [EOL] Duration baseDuration = new Duration(1000L); [EOL] ReadableDuration durationToAdd = new Duration(500L); [EOL] Duration result = baseDuration.withDurationAdded(durationToAdd, 0); [EOL] assertSame("Duration should be the same as base duration when scalar is zero", baseDuration, result); [EOL] } [EOL] public void testWithDurationAdded_NonNullDurationPositiveScalar() { [EOL] Duration baseDuration = new Duration(1000L); [EOL] ReadableDuration durationToAdd = new Duration(500L); [EOL] Duration result = baseDuration.withDurationAdded(durationToAdd, 1); [EOL] assertEquals("Duration should be increased by 500L", 1500L, result.getMillis()); [EOL] } [EOL] public void testWithDurationAdded_NonNullDurationNegativeScalar() { [EOL] Duration baseDuration = new Duration(1000L); [EOL] ReadableDuration durationToAdd = new Duration(500L); [EOL] Duration result = baseDuration.withDurationAdded(durationToAdd, -1); [EOL] assertEquals("Duration should be decreased by 500L", 500L, result.getMillis()); [EOL] }
public void testMinus_withPositiveAmount() { [EOL] Duration duration = Duration.ofHours(2); [EOL] Duration result = duration.minus(1); [EOL] assertEquals(Duration.ofHours(1), result); [EOL] }
public void testMinus_withNegativeAmount() { [EOL] Duration duration = Duration.ofHours(2); [EOL] Duration result = duration.minus(-1); [EOL] assertEquals(Duration.ofHours(3), result); [EOL] }
public void testMinus_withZeroAmount() { [EOL] Duration duration = Duration.ofHours(2); [EOL] Duration result = duration.minus(0); [EOL] assertEquals(Duration.ofHours(2), result); [EOL] }
public void testGetWithNonZeroValue() { [EOL] long instant = SOME_INSTANT_WITH_NON_ZERO_VALUE; // Replace with an actual instant [EOL] int expectedValue = EXPECTED_NON_ZERO_VALUE; // Replace with the expected value for that instant [EOL] int actualValue = get(instant); [EOL] assertNotEquals(0, actualValue); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetWithZeroValue() { [EOL] long instant = SOME_INSTANT_WITH_ZERO_VALUE; // Replace with an actual instant that would result in zero value [EOL] int actualValue = get(instant); [EOL] assertEquals(getMaximumValue(), actualValue); [EOL] }
public void testSetWithMinimumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = 1; [EOL] long expected = getWrappedField().set(instant, value); [EOL] long actual = set(instant, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMaximumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = getMaximumValue(); [EOL] long expected = getWrappedField().set(instant, 0); [EOL] long actual = set(instant, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithOutOfBoundsValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = getMaximumValue() + 1; [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public long roundFloorTestWithValidInstant() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with an actual valid instant [EOL] long expected = EXPECTED_RESULT; // Replace with the expected result [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testReadFrom_WithInputStreamImplementingDataInput() throws IOException { [EOL] InputStream in = new DataInputStream(new ByteArrayInputStream(new byte[0])); [EOL] String id = "testZone"; [EOL] DateTimeZone result = ClassName.readFrom(in, id); [EOL] assertNotNull(result); [EOL] }
public void testReadFrom_WithRegularInputStream() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] String id = "testZone"; [EOL] DateTimeZone result = ClassName.readFrom(in, id); [EOL] assertNotNull(result); [EOL] }
public void testReadFromWithFixedDateTimeZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'F'); [EOL] when(in.readUTF()).thenReturn("UTC"); [EOL] when(in.readLong()).thenReturn(0L); [EOL] DateTimeZone result = Time.readFrom(in, "UTC"); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testReadFromWithCachedDateTimeZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'C'); [EOL] PrecalculatedZone precalculatedZone = mock(PrecalculatedZone.class); [EOL] when(PrecalculatedZone.readFrom(in, "CET")).thenReturn(precalculatedZone); [EOL] DateTimeZone result = Time.readFrom(in, "CET"); [EOL] assertTrue(result instanceof CachedDateTimeZone); [EOL] }
public void testReadFromWithPrecalculatedZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'P'); [EOL] PrecalculatedZone precalculatedZone = mock(PrecalculatedZone.class); [EOL] when(PrecalculatedZone.readFrom(in, "PST")).thenReturn(precalculatedZone); [EOL] DateTimeZone result = Time.readFrom(in, "PST"); [EOL] assertSame(precalculatedZone, result); [EOL] }
public void testReadFromWithInvalidEncoding() { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((byte) 'X'); [EOL] assertThrows(IOException.class, () -> Time.readFrom(in, "Invalid")); [EOL] }
public void testReadMillisCase0() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn(0b00000000); [EOL] long result = Time.readMillis(in); [EOL] assertEquals(0, result); [EOL] }
public void testReadMillisCase1() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()) [EOL] .thenReturn(0b01000000) [EOL] .thenReturn(0b00000001) [EOL] .thenReturn(0b00000010) [EOL] .thenReturn(0b00000011); [EOL] long result = Time.readMillis(in); [EOL] assertEquals(1073741824, result); [EOL] }
public void testReadMillisCase2() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()) [EOL] .thenReturn(0b10000000) [EOL] .thenReturn(0b00000001) [EOL] .thenReturn(0b00000010) [EOL] .thenReturn(0b00000011) [EOL] .thenReturn(0b00000100); [EOL] long result = Time.readMillis(in); [EOL] assertEquals(2147483648000L, result); [EOL] }
public void testReadMillisCase3() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readLong()).thenReturn(123456789L); [EOL] long result = Time.readMillis(in); [EOL] assertEquals(123456789L, result); [EOL] }
public void testReadFrom_ValidDataInput() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenReturn((int) 'A', 1, 3); [EOL] when(in.readByte()).thenReturn((byte) 2); [EOL] when(in.readBoolean()).thenReturn(true); [EOL] when(in.readInt()).thenReturn(1000); [EOL] OfYear result = OfYear.readFrom(in); [EOL] assertEquals('A', result.getCharValue()); [EOL] assertEquals(1, result.getFirstUnsignedByte()); [EOL] assertEquals(2, result.getByteValue()); [EOL] assertEquals(3, result.getSecondUnsignedByte()); [EOL] assertTrue(result.getBooleanValue()); [EOL] assertEquals(1000, result.getMillisValue()); [EOL] }
public void testReadFrom_IOException() { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedByte()).thenThrow(new IOException()); [EOL] assertThrows(IOException.class, () -> { [EOL] OfYear.readFrom(in); [EOL] }); [EOL] }
public void testReadFrom_ValidInput() throws IOException { [EOL] DataInput mockDataInput = mock(DataInput.class); [EOL] OfYear mockOfYear = mock(OfYear.class); [EOL] when(mockOfYear.readFrom(any(DataInput.class))).thenReturn(mockOfYear); [EOL] when(mockDataInput.readUTF()).thenReturn("TestRule"); [EOL] when(mockDataInput.readLong()).thenReturn(1000L); [EOL] Recurrence result = Recurrence.readFrom(mockDataInput); [EOL] assertNotNull(result); [EOL] assertEquals(mockOfYear, result.getOfYear()); [EOL] assertEquals("TestRule", result.getRule()); [EOL] assertEquals(1000, result.getMillis()); [EOL] }
public void testReadFrom_IOException() { [EOL] DataInput mockDataInput = mock(DataInput.class); [EOL] try { [EOL] when(mockDataInput.readUTF()).thenThrow(new IOException()); [EOL] Recurrence.readFrom(mockDataInput); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testReadFrom() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] String id = "testZone"; [EOL] long readMillis = 123456789L; [EOL] Recurrence startRecurrence = mock(Recurrence.class); [EOL] Recurrence endRecurrence = mock(Recurrence.class); [EOL] when(in.readLong()).thenReturn(readMillis); [EOL] when(Recurrence.readFrom(in)).thenReturn(startRecurrence).thenReturn(endRecurrence); [EOL] DSTZone result = DSTZone.readFrom(in, id); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertEquals((int) readMillis, result.getStandardOffset()); [EOL] assertEquals(startRecurrence, result.getStartRecurrence()); [EOL] assertEquals(endRecurrence, result.getEndRecurrence()); [EOL] }
public void testReadFromWithEmptyPool() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedShort()).thenReturn(0); // poolSize = 0 [EOL] when(in.readInt()).thenReturn(0); // size = 0 [EOL] when(in.readBoolean()).thenReturn(false); // no tailZone [EOL] PrecalculatedZone result = PrecalculatedZone.readFrom(in, "testID"); [EOL] assertNotNull(result); [EOL] assertEquals("testID", result.getID()); [EOL] }
public void testReadFromWithNonEmptyPoolAndNoTailZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedShort()).thenReturn(1); // poolSize = 1 [EOL] when(in.readUTF()).thenReturn("UTC"); [EOL] when(in.readInt()).thenReturn(1); // size = 1 [EOL] when(in.readUnsignedByte()).thenReturn(0); // index for nameKeys [EOL] when(in.readBoolean()).thenReturn(false); // no tailZone [EOL] long millis = System.currentTimeMillis(); [EOL] when(in.readLong()).thenReturn(millis); // transitions [EOL] when(in.readInt()).thenReturn((int) millis); // wallOffsets and standardOffsets [EOL] PrecalculatedZone result = PrecalculatedZone.readFrom(in, "testID"); [EOL] assertNotNull(result); [EOL] assertEquals("testID", result.getID()); [EOL] assertEquals(1, result.getTransitions().length); [EOL] assertEquals("UTC", result.getNameKeys()[0]); [EOL] }
public void testReadFromWithNonEmptyPoolAndTailZone() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedShort()).thenReturn(1); // poolSize = 1 [EOL] when(in.readUTF()).thenReturn("UTC"); [EOL] when(in.readInt()).thenReturn(1); // size = 1 [EOL] when(in.readUnsignedByte()).thenReturn(0); // index for nameKeys [EOL] when(in.readBoolean()).thenReturn(true); // has tailZone [EOL] long millis = System.currentTimeMillis(); [EOL] when(in.readLong()).thenReturn(millis); // transitions [EOL] when(in.readInt()).thenReturn((int) millis); // wallOffsets and standardOffsets [EOL] DSTZone tailZone = mock(DSTZone.class); [EOL] when(DSTZone.readFrom(any(DataInput.class), anyString())).thenReturn(tailZone); [EOL] PrecalculatedZone result = PrecalculatedZone.readFrom(in, "testID"); [EOL] assertNotNull(result); [EOL] assertEquals("testID", result.getID()); [EOL] assertEquals(1, result.getTransitions().length); [EOL] assertEquals("UTC", result.getNameKeys()[0]); [EOL] assertNotNull(result.getTailZone()); [EOL] }
public void testReadFromWithInvalidEncoding() throws IOException { [EOL] DataInput in = mock(DataInput.class); [EOL] when(in.readUnsignedShort()).thenReturn(256); // poolSize = 256 [EOL] when(in.readInt()).thenReturn(1); // size = 1 [EOL] when(in.readUnsignedShort()).thenReturn(256); // invalid index [EOL] long millis = System.currentTimeMillis(); [EOL] when(in.readLong()).thenReturn(millis); // transitions [EOL] when(in.readInt()).thenReturn((int) millis); // wallOffsets and standardOffsets [EOL] assertThrows(IOException.class, () -> PrecalculatedZone.readFrom(in, "testID")); [EOL] }
public void testIsFixed() { [EOL] Time time = new Time(); [EOL] boolean result = time.isFixed(); [EOL] assertFalse(result); [EOL] }
public void testForZone_WithCachedDateTimeZone() { [EOL] DateTimeZone cachedZone = CachedDateTimeZone.forZone(DateTimeZone.UTC); [EOL] CachedDateTimeZone result = CachedDateTimeZone.forZone(cachedZone); [EOL] assertSame("Should return the same CachedDateTimeZone instance", cachedZone, result); [EOL] }
public void testForZone_WithNonCachedDateTimeZone() { [EOL] DateTimeZone nonCachedZone = DateTimeZone.forID("Europe/London"); [EOL] CachedDateTimeZone result = CachedDateTimeZone.forZone(nonCachedZone); [EOL] assertNotNull("Should return a new CachedDateTimeZone instance", result); [EOL] assertNotSame("Should not return the original non-cached zone", nonCachedZone, result); [EOL] assertEquals("Cached zone should wrap the original zone", nonCachedZone, result.getUncachedZone()); [EOL] }
public void testCachedDateTimeZoneInitialization() { [EOL] DateTimeZone mockZone = Mockito.mock(DateTimeZone.class); [EOL] Mockito.when(mockZone.getID()).thenReturn("TestZone"); [EOL] CachedDateTimeZone cachedZone = new CachedDateTimeZone(mockZone); [EOL] assertEquals("TestZone", cachedZone.getID()); [EOL] }
public void testIsFixed_True() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] when(mockZone.isFixed()).thenReturn(true); [EOL] DateTimeZone fixedZone = new DateTimeZone("fixed", mockZone); [EOL] assertTrue(fixedZone.isFixed()); [EOL] }
public void testIsFixed_False() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] when(mockZone.isFixed()).thenReturn(false); [EOL] DateTimeZone nonFixedZone = new DateTimeZone("non-fixed", mockZone); [EOL] assertFalse(nonFixedZone.isFixed()); [EOL] }
public int getOffsetTestWithNullNextInfoAndMillisBeforePeriodStart() { [EOL] long millis = 1000L; // Assume this is before iPeriodStart [EOL] TestTime time = new TestTime(); // Assuming TestTime is the class where getOffset is defined [EOL] time.iNextInfo = null; [EOL] time.iPeriodStart = 2000L; // millis is less than iPeriodStart [EOL] time.iOffset = Integer.MIN_VALUE; [EOL] time.iZoneRef = mock(ZoneRef.class); // Assuming ZoneRef is a class and iZoneRef is an instance of it [EOL] when(time.iZoneRef.getOffset(anyLong())).thenReturn(5); // Stubbing getOffset method [EOL] int result = time.getOffset(millis); [EOL] assertEquals(5, result); [EOL] }
public int getOffsetTestWithNonNullNextInfoAndMillisAfterPeriodStart() { [EOL] long millis = 3000L; // Assume this is after iPeriodStart [EOL] TestTime time = new TestTime(); // Assuming TestTime is the class where getOffset is defined [EOL] time.iNextInfo = mock(TestTime.class); // Assuming iNextInfo is an instance of TestTime [EOL] time.iNextInfo.iPeriodStart = 2000L; // millis is greater than iPeriodStart [EOL] when(time.iNextInfo.getOffset(anyLong())).thenReturn(10); // Stubbing getOffset method [EOL] int result = time.getOffset(millis); [EOL] assertEquals(10, result); [EOL] }
public int getOffsetTestWithNonNullNextInfoAndMillisBeforePeriodStart() { [EOL] long millis = 1000L; // Assume this is before iPeriodStart [EOL] TestTime time = new TestTime(); // Assuming TestTime is the class where getOffset is defined [EOL] time.iNextInfo = mock(TestTime.class); // Assuming iNextInfo is an instance of TestTime [EOL] time.iNextInfo.iPeriodStart = 2000L; // millis is less than iPeriodStart [EOL] time.iOffset = 15; [EOL] int result = time.getOffset(millis); [EOL] assertEquals(15, result); [EOL] }
public void testScaledDurationFieldConstructor_InvalidScalarZero() { [EOL] try { [EOL] new ScaledDurationField(mock(DurationField.class), mock(DurationFieldType.class), 0); [EOL] fail("Expected IllegalArgumentException for scalar 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testScaledDurationFieldConstructor_InvalidScalarOne() { [EOL] try { [EOL] new ScaledDurationField(mock(DurationField.class), mock(DurationFieldType.class), 1); [EOL] fail("Expected IllegalArgumentException for scalar 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testScaledDurationFieldConstructor_ValidScalar() { [EOL] ScaledDurationField field = new ScaledDurationField(mock(DurationField.class), mock(DurationFieldType.class), 2); [EOL] assertNotNull(field); [EOL] }
public void testGetMillis_PositiveValue() { [EOL] int value = 10; [EOL] long expected = 10L * iScalar; [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_NegativeValue() { [EOL] int value = -10; [EOL] long expected = -10L * iScalar; [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_ZeroValue() { [EOL] int value = 0; [EOL] long expected = 0L; [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillisWithPositiveValue() { [EOL] int value = 5; [EOL] long instant = 1000L; [EOL] long expected = getWrappedField().getMillis(5L * iScalar, instant); [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithNegativeValue() { [EOL] int value = -5; [EOL] long instant = 1000L; [EOL] long expected = getWrappedField().getMillis(-5L * iScalar, instant); [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithZeroValue() { [EOL] int value = 0; [EOL] long instant = 1000L; [EOL] long expected = getWrappedField().getMillis(0L, instant); [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithMaxIntValue() { [EOL] int value = Integer.MAX_VALUE; [EOL] long instant = 1000L; [EOL] long expected = getWrappedField().getMillis(((long) Integer.MAX_VALUE) * iScalar, instant); [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillisWithMinIntValue() { [EOL] int value = Integer.MIN_VALUE; [EOL] long instant = 1000L; [EOL] long expected = getWrappedField().getMillis(((long) Integer.MIN_VALUE) * iScalar, instant); [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] }
public void testHashCode() { [EOL] long testScalar = 12345L; [EOL] MockType mockType = new MockType(); // MockType should override hashCode [EOL] MockField mockField = new MockField(); // MockField should override hashCode [EOL] Time time = new Time(testScalar, mockType, mockField); // Assuming such a constructor exists [EOL] int expectedHash = (int) (testScalar ^ (testScalar >>> 32)); [EOL] expectedHash += mockType.hashCode(); [EOL] expectedHash += mockField.hashCode(); [EOL] int actualHash = time.hashCode(); [EOL] assertEquals(expectedHash, actualHash); [EOL] }
public void testEquals_SameObject() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] }
public void testEquals_DifferentObjectSameZone() { [EOL] ISOChronology chrono1 = ISOChronology.getInstance(); [EOL] ISOChronology chrono2 = ISOChronology.getInstance(); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentObjectDifferentZone() { [EOL] ISOChronology chrono1 = ISOChronology.getInstance(); [EOL] ISOChronology chrono2 = ISOChronology.getInstance(DateTimeZone.forID("Europe/Paris")); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_Null() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_NonChronologyObject() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] Object obj = new Object(); [EOL] assertFalse(chrono.equals(obj)); [EOL] }
public void testBaseDurationFieldWithNonNullType() { [EOL] DurationFieldType type = DurationFieldType.seconds(); [EOL] BaseDurationField field = new BaseDurationField(type); [EOL] assertNotNull(field); [EOL] assertEquals(type, field.getType()); [EOL] }
public void testBaseDurationFieldWithNullType() { [EOL] try { [EOL] new BaseDurationField(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstantMillisWithValidDate() { [EOL] Date date = new Date(); [EOL] long expected = date.getTime(); [EOL] long actual = getInstantMillis(date, null); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(Date.class, supportedType); [EOL] }
public void testMonthsZero() { [EOL] Months result = Time.months(0); [EOL] assertEquals(Months.ZERO, result); [EOL] }
public void testMonthsOne() { [EOL] Months result = Time.months(1); [EOL] assertEquals(Months.ONE, result); [EOL] }
public void testMonthsTwo() { [EOL] Months result = Time.months(2); [EOL] assertEquals(Months.TWO, result); [EOL] }
public void testMonthsThree() { [EOL] Months result = Time.months(3); [EOL] assertEquals(Months.THREE, result); [EOL] }
public void testMonthsFour() { [EOL] Months result = Time.months(4); [EOL] assertEquals(Months.FOUR, result); [EOL] }
public void testMonthsFive() { [EOL] Months result = Time.months(5); [EOL] assertEquals(Months.FIVE, result); [EOL] }
public void testMonthsSix() { [EOL] Months result = Time.months(6); [EOL] assertEquals(Months.SIX, result); [EOL] }
public void testMonthsSeven() { [EOL] Months result = Time.months(7); [EOL] assertEquals(Months.SEVEN, result); [EOL] }
public void testMonthsEight() { [EOL] Months result = Time.months(8); [EOL] assertEquals(Months.EIGHT, result); [EOL] }
public void testMonthsNine() { [EOL] Months result = Time.months(9); [EOL] assertEquals(Months.NINE, result); [EOL] }
public void testMonthsTen() { [EOL] Months result = Time.months(10); [EOL] assertEquals(Months.TEN, result); [EOL] }
public void testMonthsEleven() { [EOL] Months result = Time.months(11); [EOL] assertEquals(Months.ELEVEN, result); [EOL] }
public void testMonthsTwelve() { [EOL] Months result = Time.months(12); [EOL] assertEquals(Months.TWELVE, result); [EOL] }
public void testMonthsMaxValue() { [EOL] Months result = Time.months(Integer.MAX_VALUE); [EOL] assertEquals(Months.MAX_VALUE, result); [EOL] }
public void testMonthsMinValue() { [EOL] Months result = Time.months(Integer.MIN_VALUE); [EOL] assertEquals(Months.MIN_VALUE, result); [EOL] }
public void testMonthsDefault() { [EOL] int anyOtherValue = 13; // Any value not covered by the cases [EOL] Months result = Time.months(anyOtherValue); [EOL] assertNotNull(result); [EOL] assertEquals(new Months(anyOtherValue), result); [EOL] }
public void testMonthsBetween_SameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Months result = Time.monthsBetween(start, end); [EOL] assertEquals(0, result.getMonths()); [EOL] }
public void testMonthsBetween_DifferentInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusMonths(5); [EOL] Months result = Time.monthsBetween(start, end); [EOL] assertEquals(5, result.getMonths()); [EOL] }
public void testMonthsBetweenWithLocalDates() { [EOL] LocalDate start = new LocalDate(2020, 1, 1); [EOL] LocalDate end = new LocalDate(2020, 4, 1); [EOL] Months result = time.monthsBetween(start, end); [EOL] assertEquals(3, result.getMonths()); [EOL] } [EOL] public void testMonthsBetweenWithNonLocalDates() { [EOL] ReadablePartial start = new YearMonth(2020, 1); [EOL] ReadablePartial end = new YearMonth(2020, 4); [EOL] Months result = time.monthsBetween(start, end); [EOL] assertEquals(3, result.getMonths()); [EOL] }

public void testMonthsInWithNullInterval() { [EOL] ReadableInterval interval = null; [EOL] Months result = Time.monthsIn(interval); [EOL] assertEquals(Months.ZERO, result); [EOL] }
public void testMonthsInWithNonNullInterval() { [EOL] ReadableInterval interval = new MockReadableInterval(); [EOL] Months result = Time.monthsIn(interval); [EOL] int expectedAmount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months()); [EOL] assertEquals(Months.months(expectedAmount), result); [EOL] }
public void testNegated() { [EOL] Months months = Months.months(1); [EOL] Months result = months.negated(); [EOL] assertEquals(-1, result.getValue()); [EOL] }
public void testNegatedWithZero() { [EOL] Months months = Months.months(0); [EOL] Months result = months.negated(); [EOL] assertEquals(0, result.getValue()); [EOL] }
public void testNegatedWithMaxValue() { [EOL] Months months = Months.months(Integer.MAX_VALUE); [EOL] try { [EOL] months.negated(); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testNegatedWithMinValue() { [EOL] Months months = Months.months(Integer.MIN_VALUE); [EOL] try { [EOL] months.negated(); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testIsGreaterThanWithNull() { [EOL] Months testMonths = new Months(1); [EOL] boolean result = testMonths.isGreaterThan(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGreaterThanWithGreaterValue() { [EOL] Months testMonths1 = new Months(2); [EOL] Months testMonths2 = new Months(1); [EOL] boolean result = testMonths1.isGreaterThan(testMonths2); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGreaterThanWithLesserValue() { [EOL] Months testMonths1 = new Months(1); [EOL] Months testMonths2 = new Months(2); [EOL] boolean result = testMonths1.isGreaterThan(testMonths2); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsGreaterThanWithEqualValue() { [EOL] Months testMonths1 = new Months(1); [EOL] Months testMonths2 = new Months(1); [EOL] boolean result = testMonths1.isGreaterThan(testMonths2); [EOL] assertFalse(result); [EOL] }
public void testIntervalWithValidRange() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Interval interval = new Interval(startInstant, endInstant); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] }
public void testIntervalWithEqualStartAndEnd() { [EOL] long instant = 1000L; [EOL] Interval interval = new Interval(instant, instant); [EOL] assertEquals(instant, interval.getStartMillis()); [EOL] assertEquals(instant, interval.getEndMillis()); [EOL] }
public void testIntervalWithInvertedRange() { [EOL] long startInstant = 2000L; [EOL] long endInstant = 1000L; [EOL] try { [EOL] Interval interval = new Interval(startInstant, endInstant); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithValidStartAndEnd() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59); [EOL] Interval interval = new Interval(start, end); [EOL] assertEquals(start, interval.getStart()); [EOL] assertEquals(end, interval.getEnd()); [EOL] }
public void testIntervalWithStartAfterEnd() { [EOL] ReadableInstant start = new DateTime(2021, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59); [EOL] try { [EOL] new Interval(start, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithStartEqualToEnd() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 1, 1, 0, 0); [EOL] Interval interval = new Interval(start, end); [EOL] assertEquals(start, interval.getStart()); [EOL] assertEquals(end, interval.getEnd()); [EOL] }
public void testIntervalWithNullStart() { [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59); [EOL] try { [EOL] new Interval(null, end); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testIntervalWithNullEnd() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] try { [EOL] new Interval(start, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testIntervalWithNullStartAndValidDuration() { [EOL] ReadableDuration duration = new Duration(1000); [EOL] try { [EOL] new Interval(null, duration); [EOL] fail("Should have thrown IllegalArgumentException for null start instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithValidStartAndNullDuration() { [EOL] ReadableInstant start = new DateTime(); [EOL] try { [EOL] new Interval(start, null); [EOL] fail("Should have thrown IllegalArgumentException for null duration"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithValidStartAndDuration() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableDuration duration = new Duration(1000); [EOL] Interval interval = new Interval(start, duration); [EOL] assertNotNull(interval); [EOL] assertEquals(start, interval.getStart()); [EOL] assertEquals(start.plus(duration), interval.getEnd()); [EOL] }
public void testIntervalWithNullDuration() { [EOL] ReadableInstant end = new DateTime(); [EOL] try { [EOL] new Interval(null, end); [EOL] fail("Should have thrown IllegalArgumentException for null duration"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithNullEnd() { [EOL] ReadableDuration duration = new Duration(12345); [EOL] try { [EOL] new Interval(duration, null); [EOL] fail("Should have thrown IllegalArgumentException for null end instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithValidDurationAndEnd() { [EOL] ReadableDuration duration = new Duration(12345); [EOL] ReadableInstant end = new DateTime(); [EOL] Interval interval = new Interval(duration, end); [EOL] assertNotNull(interval); [EOL] assertEquals(duration.getMillis(), interval.toDurationMillis()); [EOL] assertEquals(end, interval.getEnd()); [EOL] }
public void testIntervalWithInstantAndPeriod() { [EOL] DateTime start = new DateTime(2021, 3, 25, 12, 0, 0, 0); [EOL] Period period = new Period(1, 2, 3, 4); [EOL] Interval interval = new Interval(start, period); [EOL] assertNotNull(interval); [EOL] assertEquals(start, interval.getStart()); [EOL] assertEquals(start.plus(period), interval.getEnd()); [EOL] }
public void testIntervalWithInstantAndNullPeriod() { [EOL] DateTime start = new DateTime(2021, 3, 25, 12, 0, 0, 0); [EOL] try { [EOL] Interval interval = new Interval(start, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithValidPeriodAndEnd() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] ReadableInstant end = mock(ReadableInstant.class); [EOL] Interval interval = new Interval(period, end); [EOL] assertNotNull(interval); [EOL] }
public void testIntervalWithNullPeriod() { [EOL] ReadablePeriod period = null; [EOL] ReadableInstant end = mock(ReadableInstant.class); [EOL] try { [EOL] Interval interval = new Interval(period, end); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIntervalWithNullEnd() { [EOL] ReadablePeriod period = mock(ReadablePeriod.class); [EOL] ReadableInstant end = null; [EOL] try { [EOL] Interval interval = new Interval(period, end); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToInterval() { [EOL] Interval interval = new Interval(); [EOL] Interval result = interval.toInterval(); [EOL] assertSame(interval, result); [EOL] }
public void testWithEndMillis_SameEndMillis() { [EOL] long startMillis = 1000L; [EOL] long endMillis = 2000L; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withEndMillis(endMillis); [EOL] assertSame(interval, result); [EOL] } [EOL] public void testWithEndMillis_DifferentEndMillis() { [EOL] long startMillis = 1000L; [EOL] long endMillis = 2000L; [EOL] long newEndMillis = 3000L; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withEndMillis(newEndMillis); [EOL] assertNotNull(result); [EOL] assertEquals(startMillis, result.getStartMillis()); [EOL] assertEquals(newEndMillis, result.getEndMillis()); [EOL] }
public void testWithPeriodBeforeEnd_NullPeriod() { [EOL] Interval interval = new Interval(0, 1000); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] Interval result = interval.withPeriodBeforeEnd(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(1000, result.getEndMillis()); [EOL] }
public void testWithPeriodBeforeEnd_NonNullPeriod() { [EOL] Interval interval = new Interval(0, 1000); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] ReadablePeriod period = new Period(0, 0, 0, 1); // Assuming constructor Period(int hours, int minutes, int seconds, int millis) [EOL] Interval result = interval.withPeriodBeforeEnd(period); [EOL] assertNotNull(result); [EOL] assertEquals(999, result.getStartMillis()); [EOL] assertEquals(1000, result.getEndMillis()); [EOL] }
public void testYearMonthWithPartialAndChronology() { [EOL] YearMonth partial = new YearMonth(2020, 1); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonth result = new YearMonth(partial, chrono); [EOL] assertEquals(2020, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] assertEquals(chrono, result.getChronology()); [EOL] }
public void testYearMonthWithNullPartial() { [EOL] try { [EOL] new YearMonth((YearMonth) null, ISOChronology.getInstanceUTC()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testYearMonthWithNullChronology() { [EOL] YearMonth partial = new YearMonth(2020, 1); [EOL] YearMonth result = new YearMonth(partial, null); [EOL] assertEquals(2020, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); [EOL] assertNotNull(result.getChronology()); [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] Chronology chronology = yearMonth.getChronology(); [EOL] YearMonth result = yearMonth.withChronologyRetainFields(chronology); [EOL] assertSame("Expected same YearMonth as chronology is same", yearMonth, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] Chronology newChronology = ISOChronology.getInstanceUTC(); [EOL] if (newChronology.equals(yearMonth.getChronology())) { [EOL] newChronology = BuddhistChronology.getInstance(); [EOL] } [EOL] YearMonth result = yearMonth.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Expected different YearMonth as chronology is different", yearMonth, result); [EOL] assertEquals("Expected new chronology", newChronology, result.getChronology()); [EOL] }
public void testPropertyWithValidType() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] Property property = yearMonth.property(DateTimeFieldType.monthOfYear()); [EOL] assertNotNull(property); [EOL] }
public void testPropertyWithUnsupportedType() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] try { [EOL] yearMonth.property(DateTimeFieldType.hourOfDay()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] YearMonth yearMonth = new YearMonth(DateTimeZone.UTC); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] YearMonth yearMonth = new YearMonth(ISOChronology.getInstance()); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthInstantConstructor() { [EOL] YearMonth yearMonth = new YearMonth(0L); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthInstantChronologyConstructor() { [EOL] YearMonth yearMonth = new YearMonth(0L, ISOChronology.getInstance()); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] YearMonth yearMonth = new YearMonth(new Instant()); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] YearMonth yearMonth = new YearMonth(new Instant(), ISOChronology.getInstance()); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] YearMonth yearMonth = new YearMonth(original, new int[]{1, 1}); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthYearMonthChronologyConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] YearMonth yearMonth = new YearMonth(original, ISOChronology.getInstance()); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronologyConstructor() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4, ISOChronology.getInstance()); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testToStringWithNullPattern() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] String result = yearMonth.toString(null); [EOL] assertNotNull(result); [EOL] assertEquals(yearMonth.toString(), result); [EOL] }
public void testToStringWithValidPattern() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] String pattern = "yyyy-MM"; [EOL] String result = yearMonth.toString(pattern); [EOL] assertNotNull(result); [EOL] }
public void testAddToCopy_Zero() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.addToCopy(0); [EOL] assertEquals("Adding zero should not change the YearMonth", yearMonth, result); [EOL] }
public void testAddToCopy_Positive() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.addToCopy(1); [EOL] assertNotEquals("Adding a positive value should change the YearMonth", yearMonth, result); [EOL] assertEquals("The new YearMonth should be one month ahead", new YearMonth(2023, 5), result); [EOL] }
public void testAddToCopy_Negative() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] YearMonth result = yearMonth.addToCopy(-1); [EOL] assertNotEquals("Adding a negative value should change the YearMonth", yearMonth, result); [EOL] assertEquals("The new YearMonth should be one month behind", new YearMonth(2023, 3), result); [EOL] }
public void testAddToCopy_Overflow() { [EOL] YearMonth yearMonth = new YearMonth(2023, 12); [EOL] YearMonth result = yearMonth.addToCopy(1); [EOL] assertEquals("Adding one to the last month should result in the next year", new YearMonth(2024, 1), result); [EOL] }
public void testAddToCopy_Underflow() { [EOL] YearMonth yearMonth = new YearMonth(2023, 1); [EOL] YearMonth result = yearMonth.addToCopy(-1); [EOL] assertEquals("Subtracting one from the first month should result in the previous year", new YearMonth(2022, 12), result); [EOL] }
public void testGetType() { [EOL] DateTimeFieldType expectedType = DateTimeFieldType.dayOfMonth(); [EOL] YourClass instance = new YourClass(expectedType); [EOL] DateTimeFieldType actualType = instance.getType(); [EOL] assertEquals(expectedType, actualType); [EOL] }
public String getAsText(long instant, Locale locale) { [EOL] return getAsText(get(instant), locale); [EOL] }
public void testGetAsTextWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] String text = getAsText(instant, null); [EOL] assertNotNull(text); [EOL] }
public void testGetAsTextWithPositiveFieldValue() { [EOL] String result = getAsText(5, Locale.ENGLISH); [EOL] assertEquals("5", result); [EOL] }
public void testGetAsTextWithNegativeFieldValue() { [EOL] String result = getAsText(-5, Locale.ENGLISH); [EOL] assertEquals("-5", result); [EOL] }
public void testGetAsTextWithZeroFieldValue() { [EOL] String result = getAsText(0, Locale.ENGLISH); [EOL] assertEquals("0", result); [EOL] }
public void testGetAsShortText_WithPartial() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] ReadablePartial partial = new LocalDate(); [EOL] int fieldValue = 5; [EOL] Locale locale = Locale.ENGLISH; [EOL] String result = fieldType.getAsShortText(partial, fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetAsShortText_WithPartialAndDifferentLocale() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] ReadablePartial partial = new LocalDate(); [EOL] int fieldValue = 5; [EOL] Locale locale = Locale.FRENCH; [EOL] String result = fieldType.getAsShortText(partial, fieldValue, locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testGetAsShortTextWithNullPartial() { [EOL] try { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] fieldType.getAsShortText(null, Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetAsShortTextWithUnsupportedType() { [EOL] ReadablePartial mockPartial = new MockPartial(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] try { [EOL] fieldType.getAsShortText(mockPartial, Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetAsShortTextWithValidPartial() { [EOL] ReadablePartial mockPartial = new MockPartial(new DateTimeFieldType[]{DateTimeFieldType.hourOfDay()}, new int[]{15}); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] String shortText = fieldType.getAsShortText(mockPartial, Locale.ENGLISH); [EOL] assertNotNull("The short text should not be null", shortText); [EOL] }
public String getAsShortTextTestWithValidLocale() { [EOL] int fieldValue = 5; // Example value, adjust as needed [EOL] Locale locale = Locale.ENGLISH; // Example locale, adjust as needed [EOL] String result = getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] }
public String getAsShortTextTestWithNullLocale() { [EOL] int fieldValue = 5; // Example value, adjust as needed [EOL] Locale locale = null; // Null locale to test null handling [EOL] String result = getAsShortText(fieldValue, locale); [EOL] assertNotNull(result); [EOL] }
public long add(long instant, long value) { [EOL] return getDurationField().add(instant, value); [EOL] }
public void testSetWithNullLocale() { [EOL] long instant = System.currentTimeMillis(); [EOL] String text = "some text"; [EOL] long result = time.set(instant, text); [EOL] }
public void testConvertText_ValidNumber() { [EOL] int result = convertText("123", Locale.ENGLISH); [EOL] assertEquals(123, result); [EOL] }
public void testConvertText_InvalidNumber() { [EOL] try { [EOL] convertText("abc", Locale.ENGLISH); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] assertEquals("abc", ex.getIllegalValue()); [EOL] } [EOL] }
public int getMinimumValueTest() { [EOL] Time time = new Time(); [EOL] long instant = System.currentTimeMillis(); [EOL] int expectedValue = time.getMinimumValue(); // Assuming this method exists and returns the minimum value [EOL] int actualValue = time.getMinimumValue(instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testRoundHalfCeiling_WhenDiffToCeilingIsLessThanDiffFromFloor() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] long expected = SOME_CEILING_VALUE; [EOL] long actual = roundHalfCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfCeiling_WhenDiffToCeilingIsEqualToDiffFromFloor() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] long expected = SOME_CEILING_VALUE; // Assuming that when differences are equal, we choose ceiling [EOL] long actual = roundHalfCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundHalfCeiling_WhenDiffToCeilingIsGreaterThanDiffFromFloor() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] long expected = SOME_FLOOR_VALUE; [EOL] long actual = roundHalfCeiling(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testWritePaddedInteger_NegativeValueNotMinInt() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, -1, 3); [EOL] assertEquals("-01", out.toString()); [EOL] }
public void testWritePaddedInteger_NegativeMinInt() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, Integer.MIN_VALUE, 12); [EOL] assertEquals("-0002147483648", out.toString()); [EOL] }
public void testWritePaddedInteger_SingleDigitPositive() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, 5, 2); [EOL] assertEquals("05", out.toString()); [EOL] }
public void testWritePaddedInteger_TwoDigitPositive() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, 50, 3); [EOL] assertEquals("050", out.toString()); [EOL] }
public void testWritePaddedInteger_ThreeDigitPositive() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, 123, 4); [EOL] assertEquals("0123", out.toString()); [EOL] }
public void testWritePaddedInteger_FourDigitPositive() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, 1234, 5); [EOL] assertEquals("01234", out.toString()); [EOL] }
public void testWritePaddedInteger_LargePositive() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] Time.writePaddedInteger(out, 123456, 7); [EOL] assertEquals("0123456", out.toString()); [EOL] }
public void testWriteUnpaddedInteger_NegativeValue() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int value = -1; [EOL] Time.writeUnpaddedInteger(out, value); [EOL] assertEquals("-1", out.toString()); [EOL] }
public void testWriteUnpaddedInteger_MinValue() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int value = Integer.MIN_VALUE; [EOL] Time.writeUnpaddedInteger(out, value); [EOL] assertEquals("-" + -(long) Integer.MIN_VALUE, out.toString()); [EOL] }
public void testWriteUnpaddedInteger_SingleDigit() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int value = 5; [EOL] Time.writeUnpaddedInteger(out, value); [EOL] assertEquals("5", out.toString()); [EOL] }
public void testWriteUnpaddedInteger_TwoDigits() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int value = 42; [EOL] Time.writeUnpaddedInteger(out, value); [EOL] assertEquals("42", out.toString()); [EOL] }
public void testWriteUnpaddedInteger_ThreeDigits() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] int value = 123; [EOL] Time.writeUnpaddedInteger(out, value); [EOL] assertEquals("123", out.toString()); [EOL] }
public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL] if (zone == null) { [EOL] zone = DateTimeZone.getDefault(); [EOL] } [EOL] JulianChronology chrono; [EOL] synchronized (cCache) { [EOL] JulianChronology[] chronos = cCache.get(zone); [EOL] if (chronos == null) { [EOL] chronos = new JulianChronology[7]; [EOL] cCache.put(zone, chronos); [EOL] } [EOL] try { [EOL] chrono = chronos[minDaysInFirstWeek - 1]; [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL] } [EOL] if (chrono == null) { [EOL] if (zone == DateTimeZone.UTC) { [EOL] chrono = new JulianChronology(null, null, minDaysInFirstWeek); [EOL] } else { [EOL] chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL] chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL] } [EOL] chronos[minDaysInFirstWeek - 1] = chrono; [EOL] } [EOL] } [EOL] return chrono; [EOL] }
public void testReadResolve_BaseIsNull() { [EOL] setBase(null); [EOL] setMinimumDaysInFirstWeek(0); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(DateTimeZone.UTC, ((YourExpectedType) result).getZone()); [EOL] assertEquals(4, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] } [EOL] public void testReadResolve_BaseIsNotNull() { [EOL] Chronology mockChronology = createMockChronology(); [EOL] setBase(mockChronology); [EOL] setMinimumDaysInFirstWeek(3); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(mockChronology.getZone(), ((YourExpectedType) result).getZone()); [EOL] assertEquals(3, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] } [EOL] public void testReadResolve_MinimumDaysIsZero() { [EOL] setBase(null); [EOL] setMinimumDaysInFirstWeek(0); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(DateTimeZone.UTC, ((YourExpectedType) result).getZone()); [EOL] assertEquals(4, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] } [EOL] public void testReadResolve_MinimumDaysIsNotZero() { [EOL] Chronology mockChronology = createMockChronology(); [EOL] setBase(mockChronology); [EOL] setMinimumDaysInFirstWeek(5); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(mockChronology.getZone(), ((YourExpectedType) result).getZone()); [EOL] assertEquals(5, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] }
public void testGetMinYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MIN_YEAR; [EOL] int actual = time.getMinYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMaxYear() { [EOL] Time time = new Time(); [EOL] int expected = Time.MAX_YEAR; [EOL] int actual = time.getMaxYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAverageMillisPerYear() { [EOL] Time time = new Time(); [EOL] long expected = Time.MILLIS_PER_YEAR; [EOL] long actual = time.getAverageMillisPerYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAverageMillisPerMonth() { [EOL] Time time = new Time(); [EOL] long expected = Time.MILLIS_PER_MONTH; [EOL] long actual = time.getAverageMillisPerMonth(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAssembleWithNullBase() { [EOL] Fields fields = new Fields(); [EOL] TestTime testTime = new TestTime(); [EOL] testTime.assemble(fields); [EOL] assertNotNull(fields.year); [EOL] assertNotNull(fields.weekyear); [EOL] } [EOL] public void testAssembleWithNonNullBase() { [EOL] Fields fields = new Fields(); [EOL] TestTime testTime = new TestTime(); [EOL] testTime.setBase(new BaseTime()); [EOL] testTime.assemble(fields); [EOL] assertNull(fields.year); [EOL] assertNull(fields.weekyear); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] BuddhistChronology result = BuddhistChronology.getInstance(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testGetInstanceWithSpecificZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Asia/Tokyo"); [EOL] BuddhistChronology result = BuddhistChronology.getInstance(specificZone); [EOL] assertNotNull(result); [EOL] assertEquals(specificZone, result.getZone()); [EOL] }
public void testBuddhistChronologyInstantiation() { [EOL] Chronology base = ...; // Obtain or mock a Chronology instance [EOL] Object param = ...; // Define the parameter to pass, could be null or a specific object [EOL] BuddhistChronology chronology = ...; // Instantiate BuddhistChronology using the available approach [EOL] }
public void testToStringWithNonNullZone() { [EOL] BuddhistChronology chronology = BuddhistChronology.getInstance(DateTimeZone.forID("Asia/Tokyo")); [EOL] String result = chronology.toString(); [EOL] assertTrue(result.contains("BuddhistChronology[Asia/Tokyo]")); [EOL] }
public void testToStringWithNullZone() { [EOL] BuddhistChronology chronology = BuddhistChronology.getInstance(null); [EOL] String result = chronology.toString(); [EOL] assertEquals("BuddhistChronology", result); [EOL] }
public void testBasicMonthOfYearDateTimeFieldWithNonLeapMonth() { [EOL] BasicChronology mockChronology = Mockito.mock(BasicChronology.class); [EOL] Mockito.when(mockChronology.getAverageMillisPerMonth()).thenReturn(2629746000L); [EOL] Mockito.when(mockChronology.getMaxMonth()).thenReturn(12); [EOL] int nonLeapMonth = 1; [EOL] BasicMonthOfYearDateTimeField field = new BasicMonthOfYearDateTimeField(mockChronology, nonLeapMonth); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), field.getType()); [EOL] assertEquals(mockChronology, field.getChronology()); [EOL] assertEquals(12, field.getMaximumValue()); [EOL] assertEquals(nonLeapMonth, field.getLeapMonth()); [EOL] }
public void testBasicMonthOfYearDateTimeFieldWithLeapMonth() { [EOL] BasicChronology mockChronology = Mockito.mock(BasicChronology.class); [EOL] Mockito.when(mockChronology.getAverageMillisPerMonth()).thenReturn(2629746000L); [EOL] Mockito.when(mockChronology.getMaxMonth()).thenReturn(12); [EOL] int leapMonth = 2; [EOL] BasicMonthOfYearDateTimeField field = new BasicMonthOfYearDateTimeField(mockChronology, leapMonth); [EOL] assertEquals(DateTimeFieldType.monthOfYear(), field.getType()); [EOL] assertEquals(mockChronology, field.getChronology()); [EOL] assertEquals(12, field.getMaximumValue()); [EOL] assertEquals(leapMonth, field.getLeapMonth()); [EOL] }
public void testAdd_ValueToAddIsZero() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] assertArrayEquals(values, result); [EOL] }
public void testAdd_WithMonthOfYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] when(mockPartial.getValue(0)).thenReturn(5); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] {5, 2, 3}; [EOL] int valueToAdd = 1; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = set(mockPartial, 0, values, 6); // Assuming set method returns the expected result [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithContiguousPartial() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(3); [EOL] when(DateTimeUtils.isContiguous(mockPartial)).thenReturn(true); [EOL] when(mockPartial.getFieldType(anyInt())).thenReturn(mock(DateTimeFieldType.class)); [EOL] when(mockPartial.getFieldType(anyInt()).getField(any(Chronology.class))).thenReturn(mock(DateTimeField.class)); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 10; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = iChronology.get(mockPartial, anyLong()); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAdd_WithNonContiguousPartial() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(3); [EOL] when(DateTimeUtils.isContiguous(mockPartial)).thenReturn(false); [EOL] int fieldIndex = 1; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 10; [EOL] int[] result = add(mockPartial, fieldIndex, values, valueToAdd); [EOL] int[] expected = super.add(mockPartial, fieldIndex, values, valueToAdd); // Assuming super.add() returns the expected result [EOL] assertArrayEquals(expected, result); [EOL] }
public void testGetLeapDurationField() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeField field = chronology.hourOfDay(); [EOL] DurationField leapDurationField = field.getLeapDurationField(); [EOL] assertNotNull(leapDurationField); [EOL] assertEquals("days", leapDurationField.getName()); [EOL] }
public void testGetMaximumValue_WithYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.year()); [EOL] int[] values = {2023}; [EOL] int expectedDaysInYear = iChronology.getDaysInYear(2023); [EOL] int actualDays = getMaximumValue(mockPartial, values); [EOL] assertEquals(expectedDaysInYear, actualDays); [EOL] }
public void testGetMaximumValue_WithoutYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] int[] values = {15}; // value does not matter as it's not a year field [EOL] int expectedDaysInYearMax = iChronology.getDaysInYearMax(); [EOL] int actualDays = getMaximumValue(mockPartial, values); [EOL] assertEquals(expectedDaysInYearMax, actualDays); [EOL] }
public void testGetMaximumValue_MultipleFieldsIncludingYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(3); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.monthOfYear()); [EOL] when(mockPartial.getFieldType(1)).thenReturn(DateTimeFieldType.year()); [EOL] when(mockPartial.getFieldType(2)).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] int[] values = {5, 2023, 15}; [EOL] int expectedDaysInYear = iChronology.getDaysInYear(2023); [EOL] int actualDays = getMaximumValue(mockPartial, values); [EOL] assertEquals(expectedDaysInYear, actualDays); [EOL] }
public void testSafeNegateWithPositiveValue() { [EOL] int result = Time.safeNegate(1); [EOL] assertEquals(-1, result); [EOL] }
public void testSafeNegateWithNegativeValue() { [EOL] int result = Time.safeNegate(-1); [EOL] assertEquals(1, result); [EOL] }
public void testSafeNegateWithZero() { [EOL] int result = Time.safeNegate(0); [EOL] assertEquals(0, result); [EOL] }
public void testSafeNegateWithIntegerMinValue() { [EOL] try { [EOL] Time.safeNegate(Integer.MIN_VALUE); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Integer.MIN_VALUE cannot be negated", e.getMessage()); [EOL] } [EOL] }
public void testSafeMultiplyWithMinusOneAndMinValue() { [EOL] try { [EOL] safeMultiply(Long.MIN_VALUE, -1); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Multiplication overflows a long: -9223372036854775808 * -1", e.getMessage()); [EOL] } [EOL] }
public void testSafeMultiplyWithMinusOne() { [EOL] long result = safeMultiply(10L, -1); [EOL] assertEquals(-10L, result); [EOL] }
public void testSafeMultiplyWithZero() { [EOL] long result = safeMultiply(10L, 0); [EOL] assertEquals(0L, result); [EOL] }
public void testSafeMultiplyWithOne() { [EOL] long result = safeMultiply(10L, 1); [EOL] assertEquals(10L, result); [EOL] }
public void testSafeMultiplyWithOverflow() { [EOL] try { [EOL] safeMultiply(Long.MAX_VALUE, 2); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Multiplication overflows a long: 9223372036854775807 * 2", e.getMessage()); [EOL] } [EOL] }
public void testSafeMultiplyWithoutOverflow() { [EOL] long result = safeMultiply(Long.MAX_VALUE / 2, 2); [EOL] assertEquals((Long.MAX_VALUE / 2) * 2, result); [EOL] }
public static int getWrappedValue(int currentValue, int wrapValue, int minValue, int maxValue) { [EOL] if (minValue >= maxValue) { [EOL] throw new IllegalArgumentException("maxValue must be greater than minValue"); [EOL] } [EOL] int range = maxValue - minValue + 1; [EOL] int result = currentValue + wrapValue; [EOL] while (result < minValue) { [EOL] result += range; [EOL] } [EOL] while (result > maxValue) { [EOL] result -= range; [EOL] } [EOL] return result; [EOL] }
public void testGetWrappedValue_MinGreaterThanMax_ThrowsException() { [EOL] try { [EOL] int result = getWrappedValue(5, 10, 5); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("MIN > MAX", e.getMessage()); [EOL] } [EOL] }
public void testGetWrappedValue_ValueWithinRange_ReturnsSameValue() { [EOL] int result = getWrappedValue(5, 0, 10); [EOL] assertEquals(5, result); [EOL] }
public void testGetWrappedValue_ValueEqualsMax_ReturnsMinValue() { [EOL] int result = getWrappedValue(10, 0, 10); [EOL] assertEquals(0, result); [EOL] }
public void testGetWrappedValue_ValueBelowMin_ReturnsWrappedValue() { [EOL] int result = getWrappedValue(-1, 0, 10); [EOL] assertEquals(10, result); [EOL] }
public void testGetWrappedValue_ValueAboveMax_ReturnsWrappedValue() { [EOL] int result = getWrappedValue(11, 0, 10); [EOL] assertEquals(1, result); [EOL] }
public void testGetWrappedValue_ValueNegativeAndMultipleOfRange_ReturnsMinValue() { [EOL] int result = getWrappedValue(-10, 0, 10); [EOL] assertEquals(0, result); [EOL] }
public void testDecoratedDateTimeFieldWithNullField() { [EOL] try { [EOL] new DecoratedDateTimeField(null, DateTimeFieldType.secondOfMinute()); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testDecoratedDateTimeFieldWithUnsupportedField() { [EOL] DateTimeField unsupportedField = new UnsupportedDateTimeField(DateTimeFieldType.secondOfMinute(), DurationFieldType.seconds()); [EOL] try { [EOL] new DecoratedDateTimeField(unsupportedField, DateTimeFieldType.secondOfMinute()); [EOL] fail("Should have thrown IllegalArgumentException for unsupported field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testDecoratedDateTimeFieldWithSupportedField() { [EOL] DateTimeField supportedField = new MockDateTimeField(); [EOL] DecoratedDateTimeField decoratedField = new DecoratedDateTimeField(supportedField, DateTimeFieldType.secondOfMinute()); [EOL] assertNotNull("DecoratedDateTimeField should not be null", decoratedField); [EOL] }
public void testGetPartialConverterWithNull() { [EOL] try { [EOL] getPartialConverter(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No partial converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetPartialConverterWithValidObject() { [EOL] Object validObject = new Object() { [EOL] }; [EOL] iPartialConverters.put(validObject.getClass(), new PartialConverter() { [EOL] }); [EOL] PartialConverter result = getPartialConverter(validObject); [EOL] assertNotNull("Expected a non-null PartialConverter", result); [EOL] }
public void testGetPartialConverterWithInvalidObject() { [EOL] Object invalidObject = new Object(); [EOL] try { [EOL] getPartialConverter(invalidObject); [EOL] fail("Should have thrown IllegalArgumentException for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No partial converter found for type: " + invalidObject.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testRemoveDurationConverter_NullConverter() { [EOL] DurationConverter testConverter = null; [EOL] DurationConverter result = removeDurationConverter(testConverter); [EOL] assertNull(result); [EOL] }
public void testRemoveDurationConverter_ValidConverter() throws SecurityException { [EOL] DurationConverter testConverter = new MockDurationConverter(); [EOL] addDurationConverter(testConverter); // Assuming there is a method to add a converter before removing [EOL] DurationConverter result = removeDurationConverter(testConverter); [EOL] assertNotNull(result); [EOL] assertEquals(testConverter, result); [EOL] }
public void testRemoveDurationConverter_SecurityException() { [EOL] DurationConverter testConverter = new MockDurationConverter(); [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("alterDurationConverters".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] removeDurationConverter(testConverter); [EOL] fail("Expected SecurityException to be thrown"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset security manager [EOL] } [EOL] }
public void testGetIntervalConverterWithNull() { [EOL] try { [EOL] IntervalConverter result = getIntervalConverter(null); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No interval converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetIntervalConverterWithValidObject() { [EOL] Object validObject = new SomeValidClass(); // Replace with a valid class that has a registered converter [EOL] IntervalConverter expectedConverter = new SomeIntervalConverter(); // Replace with the expected converter [EOL] iIntervalConverters.register(validObject.getClass(), expectedConverter); // Assuming there's a method to register converters [EOL] IntervalConverter result = getIntervalConverter(validObject); [EOL] assertNotNull(result); [EOL] assertSame(expectedConverter, result); [EOL] }
public void testGetMinimumValue() { [EOL] int minValue = time.getMinimumValue(); [EOL] int expectedMinValue = /* some expected minimum value */; [EOL] assertEquals(expectedMinValue, minValue); [EOL] }
private Object readResolve() { [EOL] return getInstance(iLowerLimit, iUpperLimit); [EOL] }
protected static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) { [EOL] if (period == null) { [EOL] return 0; [EOL] } [EOL] Chronology iso = ISOChronology.getInstanceUTC(); [EOL] long duration = 0L; [EOL] for (int i = 0; i < period.size(); i++) { [EOL] int value = period.getValue(i); [EOL] if (value != 0) { [EOL] DurationField field = period.getFieldType(i).getField(iso); [EOL] if (field.isPrecise() == false) { [EOL] throw new IllegalArgumentException("Cannot convert period to duration as " + field.getName() + " is not precise in the period " + period); [EOL] } [EOL] duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value)); [EOL] } [EOL] } [EOL] return FieldUtils.safeToInt(duration / millisPerUnit); [EOL] }
public void testWithUTC_AlreadyUTC() { [EOL] Chronology chronology = new StubChronology(DateTimeZone.UTC); [EOL] Chronology withUTC = chronology.withUTC(); [EOL] assertSame("Should be same as the chronology is already UTC", chronology, withUTC); [EOL] }
public void testWithUTC_NotUTC() { [EOL] Chronology chronology = new StubChronology(DateTimeZone.getDefault()); [EOL] Chronology withUTC = chronology.withUTC(); [EOL] assertNotNull("Should not be null as the chronology is not UTC", withUTC); [EOL] assertNotSame("Should not be the same as the chronology is not UTC", chronology, withUTC); [EOL] assertEquals("Should have UTC time zone", DateTimeZone.UTC, withUTC.getZone()); [EOL] }
public void testEquals_Reflexive() { [EOL] StrictChronology chrono = new StrictChronology(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] } [EOL] public void testEquals_Null() { [EOL] StrictChronology chrono = new StrictChronology(); [EOL] assertFalse(chrono.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] StrictChronology chrono = new StrictChronology(); [EOL] assertFalse(chrono.equals(new Object())); [EOL] } [EOL] public void testEquals_EqualChronology() { [EOL] StrictChronology chrono1 = new StrictChronology(); [EOL] StrictChronology chrono2 = new StrictChronology(); [EOL] when(chrono1.getBase()).thenReturn(someBaseChronology); [EOL] when(chrono2.getBase()).thenReturn(someBaseChronology); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] } [EOL] public void testEquals_DifferentChronology() { [EOL] StrictChronology chrono1 = new StrictChronology(); [EOL] StrictChronology chrono2 = new StrictChronology(); [EOL] when(chrono1.getBase()).thenReturn(someBaseChronology); [EOL] when(chrono2.getBase()).thenReturn(differentBaseChronology); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testHashCode() { [EOL] Time time = new Time(); [EOL] time.setBase(new Base()); // Assuming setBase(Base base) is a method to set the base object [EOL] int expectedHashCode = 352831696 + time.getBase().hashCode() * 7; [EOL] int actualHashCode = time.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testBasicGJChronologyConstructor() { [EOL] Chronology base = ISOChronology.getInstanceUTC(); [EOL] int minDaysInFirstWeek = 4; [EOL] BasicGJChronology chronology = new BasicGJChronology(base, null, minDaysInFirstWeek); [EOL] assertNotNull(chronology); [EOL] }
public void testGetMonthOfYear() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] long millis = chronology.setYear(0L, 2000); // Assuming setYear sets the year and returns millis [EOL] int month = chronology.getMonthOfYear(millis, 2000); [EOL] assertEquals(1, month); // Assuming January is represented by 1 [EOL] }
public void testGetDaysInYearMonth() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] int days = chronology.getDaysInYearMonth(2000, 2); // Assuming February in a non-leap year [EOL] assertEquals(28, days); [EOL] }
public void testGetDaysInMonthMax() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] int days = chronology.getDaysInMonthMax(2); // Assuming February [EOL] assertEquals(29, days); // Assuming it returns the maximum days in February for any year [EOL] }
public void testGetDaysInMonthMaxForSet() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] long instant = chronology.setYear(0L, 2000); // Assuming setYear sets the year and returns millis [EOL] int days = chronology.getDaysInMonthMaxForSet(instant, 2); // Assuming February [EOL] assertEquals(29, days); // Assuming it returns the maximum days in February for a leap year [EOL] }
public void testGetTotalMillisByYearMonth() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] long millis = chronology.getTotalMillisByYearMonth(2000, 2); // Assuming February [EOL] assertTrue(millis > 0); // Assuming the method returns a positive number of millis [EOL] }
public void testGetYearDifference() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] long minuendInstant = chronology.setYear(0L, 2002); [EOL] long subtrahendInstant = chronology.setYear(0L, 2000); [EOL] long difference = chronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(2L, difference); [EOL] }
public void testSetYear() { [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 4); [EOL] long instant = 0L; // Assuming this represents the start of the epoch [EOL] long updatedInstant = chronology.setYear(instant, 2000); [EOL] assertTrue(updatedInstant > 0); // Assuming the method updates the year and returns a positive millis value [EOL] }
public void testSecondsZero() { [EOL] Seconds result = Time.seconds(0); [EOL] assertSame(Seconds.ZERO, result); [EOL] }
public void testSecondsOne() { [EOL] Seconds result = Time.seconds(1); [EOL] assertSame(Seconds.ONE, result); [EOL] }
public void testSecondsTwo() { [EOL] Seconds result = Time.seconds(2); [EOL] assertSame(Seconds.TWO, result); [EOL] }
public void testSecondsThree() { [EOL] Seconds result = Time.seconds(3); [EOL] assertSame(Seconds.THREE, result); [EOL] }
public void testSecondsMaxValue() { [EOL] Seconds result = Time.seconds(Integer.MAX_VALUE); [EOL] assertSame(Seconds.MAX_VALUE, result); [EOL] }
public void testSecondsMinValue() { [EOL] Seconds result = Time.seconds(Integer.MIN_VALUE); [EOL] assertSame(Seconds.MIN_VALUE, result); [EOL] }
public void testSecondsArbitrary() { [EOL] int arbitraryValue = 4; // Any value other than 0, 1, 2, 3, Integer.MAX_VALUE, Integer.MIN_VALUE [EOL] Seconds result = Time.seconds(arbitraryValue); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryValue, result.getSeconds()); [EOL] }
public void testSecondsConstructor() { [EOL] int testSeconds = 10; [EOL] Seconds secondsInstance = new Seconds(testSeconds); [EOL] assertNotNull(secondsInstance); [EOL] }
public void testReadResolve() { [EOL] Seconds testSeconds = Seconds.seconds(5); [EOL] Object result = testSeconds.readResolve(); [EOL] assertTrue(result instanceof Seconds); [EOL] assertEquals(testSeconds, result); [EOL] }
public void testToStandardDays_PositiveSeconds() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_DAY * 2); [EOL] Days expectedDays = Days.days(2); [EOL] Days actualDays = seconds.toStandardDays(); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testToStandardDays_NegativeSeconds() { [EOL] Seconds seconds = Seconds.seconds(-DateTimeConstants.SECONDS_PER_DAY * 3); [EOL] Days expectedDays = Days.days(-3); [EOL] Days actualDays = seconds.toStandardDays(); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testToStandardDays_ZeroSeconds() { [EOL] Seconds seconds = Seconds.seconds(0); [EOL] Days expectedDays = Days.days(0); [EOL] Days actualDays = seconds.toStandardDays(); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testToStandardDays_LessThanOneDay() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_DAY - 1); [EOL] Days expectedDays = Days.days(0); [EOL] Days actualDays = seconds.toStandardDays(); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testToStandardHours_zero() { [EOL] Seconds seconds = Seconds.seconds(0); [EOL] Hours result = seconds.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_positive() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_HOUR); [EOL] Hours result = seconds.toStandardHours(); [EOL] assertEquals(1, result.getHours()); [EOL] }
public void testToStandardHours_negative() { [EOL] Seconds seconds = Seconds.seconds(-DateTimeConstants.SECONDS_PER_HOUR); [EOL] Hours result = seconds.toStandardHours(); [EOL] assertEquals(-1, result.getHours()); [EOL] }
public void testToStandardHours_incompleteHourPositive() { [EOL] Seconds seconds = Seconds.seconds(DateTimeConstants.SECONDS_PER_HOUR - 1); [EOL] Hours result = seconds.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_incompleteHourNegative() { [EOL] Seconds seconds = Seconds.seconds(-(DateTimeConstants.SECONDS_PER_HOUR + 1)); [EOL] Hours result = seconds.toStandardHours(); [EOL] assertEquals(-1, result.getHours()); [EOL] }
public void testToStandardMinutes_ZeroSeconds() { [EOL] Seconds seconds = Seconds.seconds(0); [EOL] Minutes result = seconds.toStandardMinutes(); [EOL] assertEquals(0, result.getMinutes()); [EOL] }
public void testToStandardMinutes_PositiveSeconds() { [EOL] Seconds seconds = Seconds.seconds(60); [EOL] Minutes result = seconds.toStandardMinutes(); [EOL] assertEquals(1, result.getMinutes()); [EOL] }
public void testToStandardMinutes_NegativeSeconds() { [EOL] Seconds seconds = Seconds.seconds(-60); [EOL] Minutes result = seconds.toStandardMinutes(); [EOL] assertEquals(-1, result.getMinutes()); [EOL] }
public void testToStandardMinutes_PositiveSecondsNotFullMinute() { [EOL] Seconds seconds = Seconds.seconds(30); [EOL] Minutes result = seconds.toStandardMinutes(); [EOL] assertEquals(0, result.getMinutes()); [EOL] }
public void testToStandardMinutes_NegativeSecondsNotFullMinute() { [EOL] Seconds seconds = Seconds.seconds(-30); [EOL] Minutes result = seconds.toStandardMinutes(); [EOL] assertEquals(0, result.getMinutes()); [EOL] }
public void testToStandardDuration_PositiveSeconds() { [EOL] Period period = new Period().withFieldAdded(DurationFieldType.seconds(), 10); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(10000, duration.getMillis()); [EOL] }
public void testToStandardDuration_NegativeSeconds() { [EOL] Period period = new Period().withFieldAdded(DurationFieldType.seconds(), -10); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(-10000, duration.getMillis()); [EOL] }
public void testToStandardDuration_ZeroSeconds() { [EOL] Period period = new Period().withFieldAdded(DurationFieldType.seconds(), 0); [EOL] Duration duration = period.toStandardDuration(); [EOL] assertEquals(0, duration.getMillis()); [EOL] }
public void testPlus_withNull() { [EOL] Seconds original = new Seconds(5); [EOL] Seconds result = original.plus(null); [EOL] assertEquals("Result should be the same as original when adding null", original, result); [EOL] }
public void testPlus_withValidSeconds() { [EOL] Seconds original = new Seconds(5); [EOL] Seconds toAdd = new Seconds(3); [EOL] Seconds result = original.plus(toAdd); [EOL] assertEquals("Result should be the sum of original and toAdd", 8, result.getValue()); [EOL] }
public void testMultipliedBy_Positive() { [EOL] Seconds seconds = Seconds.seconds(2); [EOL] Seconds result = seconds.multipliedBy(3); [EOL] assertEquals(6, result.getSeconds()); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Seconds seconds = Seconds.seconds(2); [EOL] Seconds result = seconds.multipliedBy(-3); [EOL] assertEquals(-6, result.getSeconds()); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Seconds seconds = Seconds.seconds(2); [EOL] Seconds result = seconds.multipliedBy(0); [EOL] assertEquals(0, result.getSeconds()); [EOL] }
public void testMultipliedBy_One() { [EOL] Seconds seconds = Seconds.seconds(2); [EOL] Seconds result = seconds.multipliedBy(1); [EOL] assertEquals(2, result.getSeconds()); [EOL] }
public void testDividedByOne() { [EOL] Seconds original = Seconds.seconds(10); [EOL] Seconds result = original.dividedBy(1); [EOL] assertSame("Dividing by one should return the same object", original, result); [EOL] }
public void testDividedByPositiveNumber() { [EOL] Seconds original = Seconds.seconds(10); [EOL] Seconds result = original.dividedBy(2); [EOL] assertEquals("Dividing by a positive number should return the correct result", 5, result.getValue()); [EOL] }
public void testDividedByNegativeNumber() { [EOL] Seconds original = Seconds.seconds(10); [EOL] Seconds result = original.dividedBy(-2); [EOL] assertEquals("Dividing by a negative number should return the correct result", -5, result.getValue()); [EOL] }
public void testDividedByZero() { [EOL] Seconds original = Seconds.seconds(10); [EOL] try { [EOL] original.dividedBy(0); [EOL] fail("Dividing by zero should throw an ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testNegated_PositiveSeconds() { [EOL] Seconds seconds = Seconds.seconds(5); [EOL] Seconds result = seconds.negated(); [EOL] assertEquals(-5, result.getValue()); [EOL] }
public void testNegated_NegativeSeconds() { [EOL] Seconds seconds = Seconds.seconds(-5); [EOL] Seconds result = seconds.negated(); [EOL] assertEquals(5, result.getValue()); [EOL] }
public void testNegated_ZeroSeconds() { [EOL] Seconds seconds = Seconds.seconds(0); [EOL] Seconds result = seconds.negated(); [EOL] assertEquals(0, result.getValue()); [EOL] }
public void testIsGreaterThanWithNullOther() { [EOL] Seconds seconds = new Seconds(1); [EOL] boolean result = seconds.isGreaterThan(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGreaterThanWithPositiveOtherLesser() { [EOL] Seconds seconds = new Seconds(5); [EOL] Seconds other = new Seconds(3); [EOL] boolean result = seconds.isGreaterThan(other); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsGreaterThanWithPositiveOtherGreater() { [EOL] Seconds seconds = new Seconds(2); [EOL] Seconds other = new Seconds(4); [EOL] boolean result = seconds.isGreaterThan(other); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsGreaterThanWithPositiveOtherEqual() { [EOL] Seconds seconds = new Seconds(5); [EOL] Seconds other = new Seconds(5); [EOL] boolean result = seconds.isGreaterThan(other); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsGreaterThanWithZeroValue() { [EOL] Seconds seconds = new Seconds(0); [EOL] boolean result = seconds.isGreaterThan(null); [EOL] assertFalse(result); [EOL] }
public void testAssembleWithAllFields() { [EOL] Fields fields = new Fields(); [EOL] fields.eras = new Object(); [EOL] fields.centuries = new Object(); [EOL] fields.years = new Object(); [EOL] fields.months = new Object(); [EOL] fields.weekyears = new Object(); [EOL] fields.weeks = new Object(); [EOL] fields.days = new Object(); [EOL] fields.halfdays = new Object(); [EOL] fields.hours = new Object(); [EOL] fields.minutes = new Object(); [EOL] fields.seconds = new Object(); [EOL] fields.millis = new Object(); [EOL] fields.year = new Object(); [EOL] fields.yearOfEra = new Object(); [EOL] fields.yearOfCentury = new Object(); [EOL] fields.centuryOfEra = new Object(); [EOL] fields.era = new Object(); [EOL] fields.dayOfWeek = new Object(); [EOL] fields.dayOfMonth = new Object(); [EOL] fields.dayOfYear = new Object(); [EOL] fields.monthOfYear = new Object(); [EOL] fields.weekOfWeekyear = new Object(); [EOL] fields.weekyear = new Object(); [EOL] fields.weekyearOfCentury = new Object(); [EOL] fields.millisOfSecond = new Object(); [EOL] fields.millisOfDay = new Object(); [EOL] fields.secondOfMinute = new Object(); [EOL] fields.secondOfDay = new Object(); [EOL] fields.minuteOfHour = new Object(); [EOL] fields.minuteOfDay = new Object(); [EOL] fields.hourOfDay = new Object(); [EOL] fields.hourOfHalfday = new Object(); [EOL] fields.clockhourOfDay = new Object(); [EOL] fields.clockhourOfHalfday = new Object(); [EOL] fields.halfdayOfDay = new Object(); [EOL] Time time = new Time(); [EOL] time.assemble(fields); [EOL] }
public void testConvertFieldWithNullField() { [EOL] DurationField result = convertField(null, new HashMap<>()); [EOL] assertNull(result); [EOL] }
public void testConvertFieldWithUnsupportedField() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.isSupported()).thenReturn(false); [EOL] DurationField result = convertField(field, new HashMap<>()); [EOL] assertSame(field, result); [EOL] }
public void testConvertFieldWithSupportedFieldNotConverted() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.isSupported()).thenReturn(true); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DurationField result = convertField(field, converted); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof LimitDurationField); [EOL] assertSame(result, converted.get(field)); [EOL] }
public void testConvertFieldWithSupportedFieldAlreadyConverted() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.isSupported()).thenReturn(true); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] LimitDurationField limitField = new LimitDurationField(field); [EOL] converted.put(field, limitField); [EOL] DurationField result = convertField(field, converted); [EOL] assertSame(limitField, result); [EOL] }
public void testConvertFieldWithNullField() { [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DateTimeField result = convertField(null, converted); [EOL] assertNull(result); [EOL] }
public void testConvertFieldWithUnsupportedField() { [EOL] DateTimeField unsupportedField = mock(DateTimeField.class); [EOL] when(unsupportedField.isSupported()).thenReturn(false); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DateTimeField result = convertField(unsupportedField, converted); [EOL] assertSame(unsupportedField, result); [EOL] }
public void testConvertFieldWithSupportedFieldAlreadyConverted() { [EOL] DateTimeField supportedField = mock(DateTimeField.class); [EOL] when(supportedField.isSupported()).thenReturn(true); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DateTimeField expectedField = mock(DateTimeField.class); [EOL] converted.put(supportedField, expectedField); [EOL] DateTimeField result = convertField(supportedField, converted); [EOL] assertSame(expectedField, result); [EOL] }
public void testConvertFieldWithSupportedFieldNotYetConverted() { [EOL] DateTimeField supportedField = mock(DateTimeField.class); [EOL] when(supportedField.isSupported()).thenReturn(true); [EOL] when(supportedField.getDurationField()).thenReturn(null); [EOL] when(supportedField.getRangeDurationField()).thenReturn(null); [EOL] when(supportedField.getLeapDurationField()).thenReturn(null); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DateTimeField result = convertField(supportedField, converted); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof LimitDateTimeField); [EOL] assertSame(result, converted.get(supportedField)); [EOL] }
public void testLimitDurationFieldWithNonNullField() { [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); [EOL] DurationField field = new PreciseDurationField(fieldType, 60); [EOL] LimitDurationField limitedField = new LimitDurationField(field); [EOL] assertEquals(fieldType, limitedField.getType()); [EOL] assertEquals(field.getUnitMillis(), limitedField.getUnitMillis()); [EOL] }
public void testLimitDurationFieldWithNullField() { [EOL] try { [EOL] new LimitDurationField(null); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLimitDateTimeFieldWithNonNullFields() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] DurationField mockDurationField = mock(DurationField.class); [EOL] DurationField mockRangeDurationField = mock(DurationField.class); [EOL] DurationField mockLeapDurationField = mock(DurationField.class); [EOL] LimitDateTimeField limitDateTimeField = new LimitDateTimeField( [EOL] mockField, mockDurationField, mockRangeDurationField, mockLeapDurationField); [EOL] assertNotNull(limitDateTimeField); [EOL] assertSame(mockField, limitDateTimeField.getField()); [EOL] assertSame(mockDurationField, limitDateTimeField.getDurationField()); [EOL] assertSame(mockRangeDurationField, limitDateTimeField.getRangeDurationField()); [EOL] assertSame(mockLeapDurationField, limitDateTimeField.getLeapDurationField()); [EOL] }
public String getAsText(long instant, Locale locale) { [EOL] checkLimits(instant, null); [EOL] return getWrappedField().getAsText(instant, locale); [EOL] }
public void testGetDurationField() { [EOL] DurationField durationField = new MockDurationField(); [EOL] Time time = new Time(durationField); [EOL] assertEquals(durationField, time.getDurationField()); [EOL] }
public void testGetRangeDurationField() { [EOL] YourClass instance = new YourClass(); [EOL] DurationField result = instance.getRangeDurationField(); [EOL] assertNotNull(result); [EOL] }
public void testIsLeap_WithLeapInstant() { [EOL] long leapInstant = /* provide a leap year instant */; [EOL] boolean result = isLeap(leapInstant); [EOL] assertTrue(result); [EOL] }
public void testIsLeap_WithNonLeapInstant() { [EOL] long nonLeapInstant = /* provide a non-leap year instant */; [EOL] boolean result = isLeap(nonLeapInstant); [EOL] assertFalse(result); [EOL] }
public void testGetLeapDurationField() { [EOL] MyClass testInstance = new MyClass(expectedLeapDurationField); [EOL] DurationField result = testInstance.getLeapDurationField(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedLeapDurationField, result); [EOL] }
public void testGetMaximumValue_WithValidInstant() { [EOL] long validInstant = 1234567890L; [EOL] int expectedMaxValue = 10; // Assuming getWrappedField().getMaximumValue(validInstant) returns 10 [EOL] int actualMaxValue = getMaximumValue(validInstant); [EOL] assertEquals(expectedMaxValue, actualMaxValue); [EOL] }
public void testToStringWithNullPattern() { [EOL] Time time = new Time(); [EOL] String defaultToString = time.toString(); [EOL] String result = time.toString(null); [EOL] assertEquals(defaultToString, result); [EOL] }
public void testToStringWithValidPattern() { [EOL] Time time = new Time(); [EOL] String pattern = "yyyy-MM-dd"; [EOL] String expected = DateTimeFormat.forPattern(pattern).print(time); [EOL] String result = time.toString(pattern); [EOL] assertEquals(expected, result); [EOL] }
public void testImpreciseDateTimeFieldWithValidTypeAndUnitMillis() { [EOL] DateTimeFieldType type = DateTimeFieldType.secondOfMinute(); [EOL] long unitMillis = 1000L; [EOL] ImpreciseDateTimeField field = new ImpreciseDateTimeField(type, unitMillis); [EOL] assertEquals("The type should be secondOfMinute", DateTimeFieldType.secondOfMinute(), field.getType()); [EOL] assertEquals("The unit millis should be 1000", 1000L, field.getUnitMillis()); [EOL] assertNotNull("The duration field should not be null", field.getDurationField()); [EOL] assertEquals("The duration type should be seconds", DurationFieldType.seconds(), field.getDurationField().getType()); [EOL] }
public void testLinkedDurationFieldInstantiation() { [EOL] DurationFieldType type = DurationFieldType.minutes(); // Assuming DurationFieldType.minutes() is a valid static method for the sake of example [EOL] LinkedDurationField field = new LinkedDurationField(type); [EOL] assertNotNull("The LinkedDurationField should not be null", field); [EOL] }
public void testGetUnitMillis() { [EOL] Time time = new Time(1000); [EOL] long millis = time.getUnitMillis(); [EOL] assertEquals(1000, millis); [EOL] }
public void testMinus_withNull() { [EOL] Weeks initialWeeks = Weeks.weeks(5); [EOL] Weeks result = initialWeeks.minus(null); [EOL] assertEquals(initialWeeks, result); [EOL] }
public void testMinus_withNonNull() { [EOL] Weeks initialWeeks = Weeks.weeks(5); [EOL] Weeks weeksToSubtract = Weeks.weeks(2); [EOL] Weeks result = initialWeeks.minus(weeksToSubtract); [EOL] assertEquals(Weeks.weeks(3), result); [EOL] }
public void testDividedByOne() { [EOL] Weeks weeks = Weeks.weeks(10); [EOL] Weeks result = weeks.dividedBy(1); [EOL] assertEquals(weeks, result); [EOL] }
public void testDividedByPositiveNumber() { [EOL] Weeks weeks = Weeks.weeks(10); [EOL] Weeks result = weeks.dividedBy(2); [EOL] assertEquals(Weeks.weeks(5), result); [EOL] }
public void testDividedByNegativeNumber() { [EOL] Weeks weeks = Weeks.weeks(10); [EOL] Weeks result = weeks.dividedBy(-2); [EOL] assertEquals(Weeks.weeks(-5), result); [EOL] }
public void testDividedByZero() { [EOL] Weeks weeks = Weeks.weeks(10); [EOL] try { [EOL] weeks.dividedBy(0); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testIsLessThanWithNullOther() { [EOL] Weeks testWeeks = new Weeks(-1); [EOL] boolean result = testWeeks.isLessThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithPositiveValueAndNullOther() { [EOL] Weeks testWeeks = new Weeks(1); [EOL] boolean result = testWeeks.isLessThan(null); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithOtherLess() { [EOL] Weeks testWeeks = new Weeks(1); [EOL] Weeks otherWeeks = new Weeks(2); [EOL] boolean result = testWeeks.isLessThan(otherWeeks); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithOtherGreater() { [EOL] Weeks testWeeks = new Weeks(2); [EOL] Weeks otherWeeks = new Weeks(1); [EOL] boolean result = testWeeks.isLessThan(otherWeeks); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithOtherEqual() { [EOL] Weeks testWeeks = new Weeks(1); [EOL] Weeks otherWeeks = new Weeks(1); [EOL] boolean result = testWeeks.isLessThan(otherWeeks); [EOL] assertFalse(result); [EOL] }
public void testGetAsShortTextWithValidMonthAndLocale() { [EOL] String result = getAsShortText(1, Locale.US); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() > 0); [EOL] }
public void testGetAsShortTextWithInvalidMonth() { [EOL] try { [EOL] getAsShortText(13, Locale.US); [EOL] fail("Should have thrown an exception for invalid month value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] try { [EOL] getAsShortText(1, null); [EOL] fail("Should have thrown an exception for null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testConvertTextWithValidMonthEnglishLocale() { [EOL] int result = convertText("January", Locale.ENGLISH); [EOL] assertEquals(1, result); [EOL] }
public void testConvertTextWithValidMonthFrenchLocale() { [EOL] int result = convertText("janvier", Locale.FRENCH); [EOL] assertEquals(1, result); [EOL] }
public void testConvertTextWithInvalidMonth() { [EOL] try { [EOL] convertText("NotAMonth", Locale.ENGLISH); [EOL] fail("Should have thrown an exception for invalid month text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDateTimeWithNullChronology() { [EOL] try { [EOL] new DateTime((Chronology) null); [EOL] fail("Should have thrown IllegalArgumentException for null Chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDateTimeWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTime dateTime = new DateTime(chronology); [EOL] assertNotNull("DateTime object should not be null", dateTime); [EOL] assertEquals("Chronology should match the one passed in constructor", chronology, dateTime.getChronology()); [EOL] }
public void testDateTimeWithValidInstantAndZone() { [EOL] long instant = 1000L; [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime dateTime = new DateTime(instant, zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testDateTimeWithValidInstantAndUTCZone() { [EOL] long instant = 1000L; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(instant, zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testDateTimeWithNullInstantAndNullChronology() { [EOL] DateTime dateTime = new DateTime((Object) null, (Chronology) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] }
public void testDateTimeWithNonNullInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] DateTime dateTime = new DateTime((Object) instant, (Chronology) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] assertEquals(instant.getMillis(), dateTime.getMillis()); [EOL] }
public void testDateTimeWithNullInstantAndNonNullChronology() { [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] DateTime dateTime = new DateTime((Object) null, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testDateTimeWithNonNullInstantAndNonNullChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] DateTime dateTime = new DateTime((Object) instant, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] assertEquals(instant.getMillis(), dateTime.getMillis()); [EOL] }
public DateTime toDateTime() { [EOL] return this; [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] DateTime dateTime = new DateTime(); [EOL] dateTime.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("The same DateTime instance should be returned", dateTime, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("A different DateTime instance should be returned", dateTime, result); [EOL] assertTrue("The new DateTime should have a different millis value", dateTime.getMillis() != result.getMillis()); [EOL] }
public DateTime plus(long duration) { [EOL] return withDurationAdded(duration, 1); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusDays(0); [EOL] assertSame("Expected the same instance when adding zero days", dateTime, result); [EOL] }
public void testPlusDays_PositiveDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusDays(5); [EOL] assertNotSame("Expected a different instance when adding positive days", dateTime, result); [EOL] assertEquals("Expected the days to be added correctly", dateTime.getMillis() + 5 * 24 * 60 * 60 * 1000, result.getMillis()); [EOL] }
public void testPlusDays_NegativeDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusDays(-5); [EOL] assertNotSame("Expected a different instance when adding negative days", dateTime, result); [EOL] assertEquals("Expected the days to be subtracted correctly", dateTime.getMillis() - 5 * 24 * 60 * 60 * 1000, result.getMillis()); [EOL] }
public void testMinusWeeks_ZeroWeeks() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusWeeks(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusWeeks_PositiveWeeks() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusWeeks(1); [EOL] assertNotSame(dateTime, result); [EOL] assertTrue(result.getMillis() < dateTime.getMillis()); [EOL] }
public void testMinusWeeks_NegativeWeeks() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusWeeks(-1); [EOL] assertNotSame(dateTime, result); [EOL] assertTrue(result.getMillis() > dateTime.getMillis()); [EOL] }
public void testMinusSeconds_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusSeconds(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusSeconds_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusSeconds(1); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.getMillis() - 1000, result.getMillis()); [EOL] }
public void testMinusSeconds_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusSeconds(-1); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.getMillis() + 1000, result.getMillis()); [EOL] }
public void testMinusMillis_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusMillis(0); [EOL] assertSame("Expected the same instance when subtracting zero milliseconds", dateTime, result); [EOL] }
public void testMinusMillis_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int millisToSubtract = -1000; [EOL] DateTime result = dateTime.minusMillis(millisToSubtract); [EOL] long expectedMillis = initialMillis - millisToSubtract; [EOL] assertEquals("Expected millis to be subtracted correctly for negative value", expectedMillis, result.getMillis()); [EOL] }
public void testMinusMillis_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int millisToSubtract = 1000; [EOL] DateTime result = dateTime.minusMillis(millisToSubtract); [EOL] long expectedMillis = initialMillis - millisToSubtract; [EOL] assertEquals("Expected millis to be subtracted correctly for positive value", expectedMillis, result.getMillis()); [EOL] }
public void testPropertyWithNullType() { [EOL] try { [EOL] someObject.property(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testPropertyWithUnsupportedType() { [EOL] DateTimeFieldType unsupportedType = //... initialize with an unsupported DateTimeFieldType [EOL] try { [EOL] someObject.property(unsupportedType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testPropertyWithSupportedType() { [EOL] DateTimeFieldType supportedType = //... initialize with a supported DateTimeFieldType [EOL] Property result = someObject.property(supportedType); [EOL] assertNotNull(result); [EOL] }
public void testToYearMonthDay() { [EOL] DateTime dateTime = new DateTime(2023, 4, 15, 0, 0, 0, 0); [EOL] YearMonthDay result = dateTime.toYearMonthDay(); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(15, result.getDayOfMonth()); [EOL] }
public void testToTimeOfDay() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 10, 20, 30, DateTimeZone.UTC); [EOL] TimeOfDay timeOfDay = dateTime.toTimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(dateTime.getChronology(), timeOfDay.getChronology()); [EOL] }
public void testYearOfCentury() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property yearOfCentury = dateTime.yearOfCentury(); [EOL] assertNotNull(yearOfCentury); [EOL] assertEquals(dateTime.getChronology().yearOfCentury().get(), yearOfCentury.get()); [EOL] }
public void testWeekyearProperty() { [EOL] Time time = new Time(); [EOL] Property property = time.weekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().weekyear(), property.getField()); [EOL] }
public void testDayOfYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfYear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfYear(), property.getField()); [EOL] assertEquals(dateTime.get(DateTimeFieldType.dayOfYear()), property.get()); [EOL] }
public void testGetField() { [EOL] DateTimeField expectedField = // initialize with a mock or actual instance [EOL] YourClass instance = new YourClass(expectedField); [EOL] DateTimeField actualField = instance.getField(); [EOL] assertEquals(expectedField, actualField); [EOL] }
protected long getMillis() { [EOL] return iInstant.getMillis(); [EOL] }
public void testGetDateTime() { [EOL] DateTime expected = new DateTime(); [EOL] DateTime actual = expected.getDateTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAddToCopy_PositiveValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTimeField field = dateTime.getField(); [EOL] Instant instant = dateTime.toInstant(); [EOL] int valueToAdd = 5; [EOL] DateTime result = dateTime.addToCopy(valueToAdd); [EOL] long expectedMillis = field.add(instant.getMillis(), valueToAdd); [EOL] assertEquals(new DateTime(expectedMillis), result); [EOL] }
public void testAddToCopy_NegativeValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTimeField field = dateTime.getField(); [EOL] Instant instant = dateTime.toInstant(); [EOL] int valueToAdd = -5; [EOL] DateTime result = dateTime.addToCopy(valueToAdd); [EOL] long expectedMillis = field.add(instant.getMillis(), valueToAdd); [EOL] assertEquals(new DateTime(expectedMillis), result); [EOL] }
public void testAddToCopy_ZeroValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTimeField field = dateTime.getField(); [EOL] Instant instant = dateTime.toInstant(); [EOL] int valueToAdd = 0; [EOL] DateTime result = dateTime.addToCopy(valueToAdd); [EOL] long expectedMillis = field.add(instant.getMillis(), valueToAdd); [EOL] assertEquals(new DateTime(expectedMillis), result); [EOL] }
public void testRoundCeilingCopy() { [EOL] DateTime instant = new DateTime(); [EOL] DateTimeField field = instant.getChronology().secondOfMinute(); [EOL] DateTime rounded = new DateTime(instant.getMillis(), instant.getChronology()).withMillis(field.roundCeiling(instant.getMillis())); [EOL] assertEquals(rounded, instant.roundCeilingCopy()); [EOL] }
public void testPrintTo_withValidPeriod() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] printTo(mockWriter, mockPeriod); [EOL] verify(getPrinter()).printTo(mockWriter, mockPeriod, iLocale); [EOL] }
public void testPrintTo_withNullPeriod() { [EOL] Writer mockWriter = mock(Writer.class); [EOL] try { [EOL] printTo(mockWriter, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintTo_withNullWriter() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] try { [EOL] printTo(null, mockPeriod); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testCheckPeriodWithNull() { [EOL] try { [EOL] checkPeriod(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Period must not be null", e.getMessage()); [EOL] } [EOL] }
public void testCheckPeriodWithNonNull() { [EOL] ReadablePeriod period = new MockReadablePeriod(); [EOL] checkPeriod(period); // Should not throw an exception [EOL] }
public void testParseInto_NullPeriod() { [EOL] try { [EOL] parseInto(null, "text", 0); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testParseInto_NullText() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] try { [EOL] parseInto(mockPeriod, null, 0); [EOL] fail("Should have thrown IllegalArgumentException for null text"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testParseInto_InvalidPosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] int invalidPosition = -1; [EOL] try { [EOL] parseInto(mockPeriod, "text", invalidPosition); [EOL] fail("Should have thrown IndexOutOfBoundsException for invalid position"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testParseInto_ValidInput() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "text"; [EOL] int position = 0; [EOL] int expected = 5; // Assuming the parser returns 5 for this input [EOL] int actual = parseInto(mockPeriod, text, position); [EOL] assertEquals("Parsing should return the correct position", expected, actual); [EOL] }
public void testParseMutablePeriod_ValidInput() { [EOL] String validInput = "P1Y2M3D"; // Assuming this is a valid period format [EOL] MutablePeriod result = parseMutablePeriod(validInput); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getYears()); [EOL] assertEquals(2, result.getMonths()); [EOL] assertEquals(3, result.getDays()); [EOL] }
public void testParseMutablePeriod_EmptyString() { [EOL] String emptyInput = ""; [EOL] try { [EOL] parseMutablePeriod(emptyInput); [EOL] fail("Should have thrown IllegalArgumentException for empty input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMutablePeriod_InvalidFormat() { [EOL] String invalidInput = "InvalidFormat"; [EOL] try { [EOL] parseMutablePeriod(invalidInput); [EOL] fail("Should have thrown IllegalArgumentException for invalid format"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Invalid format")); [EOL] } [EOL] }
public void testPartialConstructorWithNullChronology() { [EOL] DateTimeFieldType type = DateTimeFieldType.year(); [EOL] int value = 2021; [EOL] Partial partial = new Partial(type, value, null); [EOL] assertNotNull(partial); [EOL] assertEquals(type, partial.getFieldType(0)); [EOL] assertEquals(value, partial.getValue(0)); [EOL] }
public void testPartialConstructorWithNonNullChronology() { [EOL] DateTimeFieldType type = DateTimeFieldType.year(); [EOL] int value = 2021; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Partial partial = new Partial(type, value, chronology); [EOL] assertNotNull(partial); [EOL] assertEquals(type, partial.getFieldType(0)); [EOL] assertEquals(value, partial.getValue(0)); [EOL] assertEquals(chronology, partial.getChronology()); [EOL] }
public void testPartialConstructorWithNullType() { [EOL] try { [EOL] new Partial(null, 1, ISOChronology.getInstance()); [EOL] fail("Should have thrown IllegalArgumentException for null type"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testPartialConstructorWithValidTypeAndChronology() { [EOL] DateTimeFieldType type = DateTimeFieldType.year(); [EOL] int value = 2023; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Partial partial = new Partial(type, value, chronology); [EOL] assertEquals("Chronology should be withUTC", chronology.withUTC(), partial.getChronology()); [EOL] assertEquals("Type array should have one element", 1, partial.getTypes().length); [EOL] assertEquals("Value array should have one element", 1, partial.getValues().length); [EOL] assertEquals("Type should be the same as passed", type, partial.getTypes()[0]); [EOL] assertEquals("Value should be the same as passed", value, partial.getValues()[0]); [EOL] }
public void testPartialConstructor_NullTypes() { [EOL] try { [EOL] new Partial(null, new int[]{1, 2, 3}, null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_NullValues() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null values array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_InequalLengthArrays() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types and values array of different lengths"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_EmptyArrays() { [EOL] Partial partial = new Partial(new DateTimeFieldType[]{}, new int[]{}, null); [EOL] assertNotNull("Partial construction should succeed with empty arrays", partial); [EOL] } [EOL] public void testPartialConstructor_NullTypeElement() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{null, DateTimeFieldType.monthOfYear()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for null element in types array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_UnsupportedType() { [EOL] try { [EOL] DateTimeFieldType fakeType = new DateTimeFieldType("fake") { [EOL] public DurationFieldType getDurationType() { [EOL] return DurationFieldType.days(); [EOL] } [EOL] public DurationFieldType getRangeDurationType() { [EOL] return null; [EOL] } [EOL] public DateTimeField getField(Chronology chronology) { [EOL] return UnsupportedDateTimeField.getInstance(getDurationType(), getRangeDurationType()); [EOL] } [EOL] }; [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), fakeType}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for unsupported type following a supported one"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_TypesNotInOrder() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.hourOfDay(), DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types not in order largest-smallest"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_DuplicateTypes() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for duplicate types"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testPartialConstructor_ValidInput() { [EOL] Partial partial = new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, new int[]{1, 2}, null); [EOL] assertNotNull("Partial construction should succeed with valid input", partial); [EOL] }
public void testPartialConstructorWithNullInput() { [EOL] try { [EOL] new Partial(null); [EOL] fail("Should have thrown IllegalArgumentException for null partial input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPartialConstructorWithValidInput() { [EOL] ReadablePartial mockPartial = createMockPartial(); [EOL] Partial result = new Partial(mockPartial); [EOL] assertNotNull("The Partial object should not be null", result); [EOL] assertEquals("Chronology should be withUTC", result.getChronology().getZone(), DateTimeZone.UTC); [EOL] for (int i = 0; i < mockPartial.size(); i++) { [EOL] assertEquals("Field type index " + i + " should match", mockPartial.getFieldType(i), result.getFieldType(i)); [EOL] assertEquals("Field value index " + i + " should match", mockPartial.getValue(i), result.getValue(i)); [EOL] } [EOL] } [EOL] private ReadablePartial createMockPartial() { [EOL] ReadablePartial mockPartial = new MockPartial(); [EOL] return mockPartial; [EOL] }
public void testWithFieldTypeNull() { [EOL] try { [EOL] Partial partial = new Partial(); [EOL] partial.with(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithUnsupportedFieldType() { [EOL] Partial partial = new Partial(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is unsupported in Partial [EOL] try { [EOL] partial.with(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithSupportedFieldTypeNewField() { [EOL] Partial partial = new Partial(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is supported and new [EOL] int value = 10; [EOL] Partial result = partial.with(fieldType, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.get(fieldType)); [EOL] }
public void testWithSupportedFieldTypeExistingFieldSameValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is supported [EOL] int value = 10; [EOL] Partial partial = new Partial(new DateTimeFieldType[]{fieldType}, new int[]{value}); [EOL] Partial result = partial.with(fieldType, value); [EOL] assertSame(partial, result); [EOL] }
public void testWithSupportedFieldTypeExistingFieldDifferentValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is supported [EOL] int value = 10; [EOL] Partial partial = new Partial(new DateTimeFieldType[]{fieldType}, new int[]{5}); [EOL] Partial result = partial.with(fieldType, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.get(fieldType)); [EOL] }
public void testWithField_SameValue() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Use the correct type for your implementation [EOL] int currentValue = partial.getValue(partial.indexOf(fieldType)); [EOL] Partial result = partial.withField(fieldType, currentValue); [EOL] assertSame("Expected same instance when setting the same value", partial, result); [EOL] }
public void testWithField_DifferentValue() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Use the correct type for your implementation [EOL] int currentValue = partial.getValue(partial.indexOf(fieldType)); [EOL] int newValue = currentValue + 1; [EOL] Partial result = partial.withField(fieldType, newValue); [EOL] assertNotNull("Expected new instance when setting a different value", result); [EOL] assertNotSame("Expected different instance when setting a different value", partial, result); [EOL] assertEquals("Expected new value to be set", newValue, result.getValue(partial.indexOf(fieldType))); [EOL] }
public void testWithField_UnsupportedType() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DateTimeFieldType unsupportedFieldType = DateTimeFieldType.hourOfDay(); // Use an unsupported type for your implementation [EOL] try { [EOL] partial.withField(unsupportedFieldType, 1); [EOL] fail("Expected exception when setting an unsupported field type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithFieldAddWrapped_ZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to instantiate Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to get a DurationFieldType [EOL] Partial result = partial.withFieldAddWrapped(fieldType, 0); [EOL] assertEquals(partial, result); [EOL] }
public void testWithFieldAddWrapped_NonZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to instantiate Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to get a DurationFieldType [EOL] int amount = 5; [EOL] Partial result = partial.withFieldAddWrapped(fieldType, amount); [EOL] assertNotEquals(partial, result); [EOL] }
public void testWithFieldAddWrapped_UnsupportedFieldType() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to instantiate Partial [EOL] DurationFieldType fieldType = DurationFieldType.years(); // Assuming years is unsupported, use the correct method [EOL] try { [EOL] partial.withFieldAddWrapped(fieldType, 1); [EOL] fail("Should have thrown an exception for unsupported field type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddWrapFieldToCopy_Zero() { [EOL] Partial partial = createPartial(); // Assume createPartial() properly initializes a Partial object [EOL] Partial result = partial.addWrapFieldToCopy(0); [EOL] assertEquals(partial, result); // Assuming a proper equals method is implemented [EOL] } [EOL] public void testAddWrapFieldToCopy_Positive() { [EOL] Partial partial = createPartial(); [EOL] int valueToAdd = 5; [EOL] Partial result = partial.addWrapFieldToCopy(valueToAdd); [EOL] int expectedValue = getWrappedValue(partial.getField().get(partial), valueToAdd); [EOL] assertEquals(expectedValue, result.getField().get(result)); [EOL] } [EOL] public void testAddWrapFieldToCopy_Negative() { [EOL] Partial partial = createPartial(); [EOL] int valueToAdd = -3; [EOL] Partial result = partial.addWrapFieldToCopy(valueToAdd); [EOL] int expectedValue = getWrappedValue(partial.getField().get(partial), valueToAdd); [EOL] assertEquals(expectedValue, result.getField().get(result)); [EOL] }
protected void setMillis(long duration) { [EOL] iMillis = duration; [EOL] }
public void testToIntervalFromWithNullStartInstant() { [EOL] DateTime endDateTime = new DateTime(); [EOL] try { [EOL] endDateTime.toIntervalFrom(null); [EOL] fail("Should have thrown IllegalArgumentException for null startInstant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToIntervalFromWithNonNullStartInstant() { [EOL] DateTime startDateTime = new DateTime(); [EOL] DateTime endDateTime = new DateTime(startDateTime.getMillis() + 1000); [EOL] Interval interval = endDateTime.toIntervalFrom(startDateTime); [EOL] assertNotNull("Interval should not be null", interval); [EOL] assertEquals("Start time of interval is incorrect", startDateTime, interval.getStart()); [EOL] assertEquals("End time of interval is incorrect", endDateTime, interval.getEnd()); [EOL] }
public void testMinus_withPositiveYears() { [EOL] Years testYears = Years.years(10); [EOL] Years result = testYears.minus(5); [EOL] assertEquals("Minus method should subtract the years", Years.years(5), result); [EOL] }
public void testMinus_withNegativeYears() { [EOL] Years testYears = Years.years(10); [EOL] Years result = testYears.minus(-5); [EOL] assertEquals("Minus method should add the years when negative input", Years.years(15), result); [EOL] }
public void testMinus_withZeroYears() { [EOL] Years testYears = Years.years(10); [EOL] Years result = testYears.minus(0); [EOL] assertEquals("Minus method with zero should return the same years", testYears, result); [EOL] }
public void testDividedByOne() { [EOL] Years years = Years.years(5); [EOL] Years result = years.dividedBy(1); [EOL] assertEquals(years, result); [EOL] }
public void testDividedByPositiveNumber() { [EOL] Years years = Years.years(10); [EOL] Years result = years.dividedBy(2); [EOL] assertEquals(Years.years(5), result); [EOL] }
public void testDividedByNegativeNumber() { [EOL] Years years = Years.years(10); [EOL] Years result = years.dividedBy(-2); [EOL] assertEquals(Years.years(-5), result); [EOL] }
public void testDividedByZero() { [EOL] Years years = Years.years(10); [EOL] try { [EOL] years.dividedBy(0); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testNow() { [EOL] Instant result = Time.now(); [EOL] assertNotNull(result); [EOL] }
public void testInstantConstructorWithZero() { [EOL] long instant = 0L; [EOL] Instant result = new Instant(instant); [EOL] assertEquals("Instant should be initialized with the given millisecond value", 0L, result.getMillis()); [EOL] }
public void testInstantConstructorWithPositiveValue() { [EOL] long instant = 123456789L; [EOL] Instant result = new Instant(instant); [EOL] assertEquals("Instant should be initialized with the given millisecond value", 123456789L, result.getMillis()); [EOL] }
public void testInstantConstructorWithNegativeValue() { [EOL] long instant = -123456789L; [EOL] Instant result = new Instant(instant); [EOL] assertEquals("Instant should be initialized with the given millisecond value", -123456789L, result.getMillis()); [EOL] }
public void testMinus_withPositiveDuration() { [EOL] Instant instant = Instant.ofEpochSecond(1000); [EOL] long duration = 10; [EOL] Instant result = instant.minus(duration); [EOL] assertEquals(Instant.ofEpochSecond(990), result); [EOL] }
public void testMinus_withNegativeDuration() { [EOL] Instant instant = Instant.ofEpochSecond(1000); [EOL] long duration = -10; [EOL] Instant result = instant.minus(duration); [EOL] assertEquals(Instant.ofEpochSecond(1010), result); [EOL] }
public void testMinus_withZeroDuration() { [EOL] Instant instant = Instant.ofEpochSecond(1000); [EOL] long duration = 0; [EOL] Instant result = instant.minus(duration); [EOL] assertEquals(Instant.ofEpochSecond(1000), result); [EOL] }
public void testGetMillis() { [EOL] long expectedMillis = 123456789L; // Replace with an appropriate value [EOL] Time time = new Time(expectedMillis); // Assuming there is a constructor that sets iMillis [EOL] long actualMillis = time.getMillis(); [EOL] assertEquals("The getMillis method should return the correct value", expectedMillis, actualMillis); [EOL] }
public void testGetChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chronology = dateTime.getChronology(); [EOL] assertNotNull(chronology); [EOL] assertTrue(chronology instanceof ISOChronology); [EOL] }
public void testToDateTime() { [EOL] Instant instant = new Instant(); [EOL] DateTime result = instant.toDateTime(); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result.getChronology()); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] }
public void testFromCalendarFieldsWithNullCalendar() { [EOL] try { [EOL] LocalDate.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFieldsWithGregorianCalendarAD() { [EOL] Calendar calendar = new GregorianCalendar(2023, Calendar.MARCH, 25); [EOL] LocalDate result = LocalDate.fromCalendarFields(calendar); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(25, result.getDayOfMonth()); [EOL] }
public void testFromCalendarFieldsWithGregorianCalendarBC() { [EOL] Calendar calendar = new GregorianCalendar(); [EOL] calendar.set(Calendar.ERA, GregorianCalendar.BC); [EOL] calendar.set(Calendar.YEAR, 2023); [EOL] calendar.set(Calendar.MONTH, Calendar.MARCH); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 25); [EOL] LocalDate result = LocalDate.fromCalendarFields(calendar); [EOL] assertEquals(1 - 2023, result.getYear()); [EOL] assertEquals(3 + 1, result.getMonthOfYear()); [EOL] assertEquals(25, result.getDayOfMonth()); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] LocalDate.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithDateBeforeEpoch() { [EOL] Date date = new Date(-1); // Date before epoch [EOL] LocalDate localDate = LocalDate.fromDateFields(date); [EOL] assertNotNull(localDate); [EOL] assertEquals(1969, localDate.getYear()); [EOL] assertEquals(12, localDate.getMonthOfYear()); [EOL] assertEquals(31, localDate.getDayOfMonth()); [EOL] }
public void testFromDateFieldsWithDateAfterEpoch() { [EOL] Date date = new Date(1); // Date after epoch [EOL] LocalDate localDate = LocalDate.fromDateFields(date); [EOL] assertNotNull(localDate); [EOL] assertEquals(1970, localDate.getYear()); [EOL] assertEquals(1, localDate.getMonthOfYear()); [EOL] assertEquals(1, localDate.getDayOfMonth()); [EOL] }
public void testLocalDateWithDefaultTimeZone() { [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] LocalDate localDate = new LocalDate(defaultZone); [EOL] long expectedMillis = DateTimeUtils.currentTimeMillis(); [EOL] Chronology expectedChrono = ISOChronology.getInstance(defaultZone); [EOL] assertEquals(expectedChrono.dayOfMonth().get(expectedMillis), localDate.getDayOfMonth()); [EOL] assertEquals(expectedChrono.monthOfYear().get(expectedMillis), localDate.getMonthOfYear()); [EOL] assertEquals(expectedChrono.year().get(expectedMillis), localDate.getYear()); [EOL] }
public void testLocalDateWithSpecificTimeZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Europe/Paris"); [EOL] LocalDate localDate = new LocalDate(specificZone); [EOL] long expectedMillis = DateTimeUtils.currentTimeMillis(); [EOL] Chronology expectedChrono = ISOChronology.getInstance(specificZone); [EOL] assertEquals(expectedChrono.dayOfMonth().get(expectedMillis), localDate.getDayOfMonth()); [EOL] assertEquals(expectedChrono.monthOfYear().get(expectedMillis), localDate.getMonthOfYear()); [EOL] assertEquals(expectedChrono.year().get(expectedMillis), localDate.getYear()); [EOL] }
public void testGetWithNullFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.get(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithUnsupportedFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = UnsupportedDateTimeFieldType.getInstance(); [EOL] testDateTime.get(fieldType); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testGetWithSupportedFieldType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int year = testDateTime.get(DateTimeFieldType.year()); [EOL] assertEquals(testDateTime.getChronology().year().get(testDateTime.getLocalMillis()), year); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = mock(DurationFieldType.class); [EOL] when(unsupportedType.getField(any(Chronology.class))).thenReturn(mock(DurationField.class)); [EOL] boolean result = instance.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = mock(DurationFieldType.class); [EOL] DurationField supportedField = mock(DurationField.class); [EOL] when(supportedType.getField(any(Chronology.class))).thenReturn(supportedField); [EOL] when(supportedField.getUnitMillis()).thenReturn(instance.getChronology().days().getUnitMillis()); [EOL] when(supportedField.isSupported()).thenReturn(true); [EOL] boolean result = instance.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithDateDurationType() { [EOL] DurationFieldType dateDurationType = DurationFieldType.days(); [EOL] boolean result = instance.isSupported(dateDurationType); [EOL] assertTrue(result); [EOL] }
public void testEquals_SameObject() { [EOL] LocalDate date = new LocalDate(2023, 3, 14); [EOL] assertTrue(date.equals(date)); [EOL] }
public void testEquals_DifferentClass() { [EOL] LocalDate date = new LocalDate(2023, 3, 14); [EOL] Object obj = new Object(); [EOL] assertFalse(date.equals(obj)); [EOL] }
public void testEquals_EqualLocalDate() { [EOL] LocalDate date1 = new LocalDate(2023, 3, 14); [EOL] LocalDate date2 = new LocalDate(2023, 3, 14); [EOL] assertTrue(date1.equals(date2)); [EOL] }
public void testEquals_DifferentChronology() { [EOL] LocalDate date1 = new LocalDate(2023, 3, 14, GregorianChronology.getInstance()); [EOL] LocalDate date2 = new LocalDate(2023, 3, 14, JulianChronology.getInstance()); [EOL] assertFalse(date1.equals(date2)); [EOL] }
public void testEquals_DifferentLocalMillis() { [EOL] LocalDate date1 = new LocalDate(2023, 3, 14); [EOL] LocalDate date2 = new LocalDate(2023, 3, 15); [EOL] assertFalse(date1.equals(date2)); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial sameInstance = this.instance; // Assuming 'this.instance' is an instance of the class containing 'compareTo' [EOL] int result = this.instance.compareTo(sameInstance); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LocalDateWithSameChronologyAndTime() { [EOL] LocalDate sameChronologyAndTime = new LocalDate(this.instance.iChronology, this.instance.iLocalMillis); // Assuming these fields are accessible or getters are available [EOL] int result = this.instance.compareTo(sameChronologyAndTime); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LocalDateWithSameChronologyAndEarlierTime() { [EOL] LocalDate earlierLocalDate = new LocalDate(this.instance.iChronology, this.instance.iLocalMillis - 1); // Assuming these fields are accessible or getters are available [EOL] int result = this.instance.compareTo(earlierLocalDate); [EOL] assertEquals(1, result); [EOL] }
public void testCompareTo_LocalDateWithSameChronologyAndLaterTime() { [EOL] LocalDate laterLocalDate = new LocalDate(this.instance.iChronology, this.instance.iLocalMillis + 1); // Assuming these fields are accessible or getters are available [EOL] int result = this.instance.compareTo(laterLocalDate); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_LocalDateWithDifferentChronology() { [EOL] Chronology differentChronology = // Obtain a different chronology [EOL] LocalDate differentChronologyLocalDate = new LocalDate(differentChronology, this.instance.iLocalMillis); // Assuming these fields are accessible or getters are available [EOL] int result = this.instance.compareTo(differentChronologyLocalDate); [EOL] int expected = // The expected result from super.compareTo() [EOL] assertEquals(expected, result); [EOL] }
public void testCompareTo_NonLocalDateReadablePartial() { [EOL] ReadablePartial nonLocalDatePartial = // Create a mock or a different implementation of ReadablePartial [EOL] int result = this.instance.compareTo(nonLocalDatePartial); [EOL] int expected = // The expected result from super.compareTo() [EOL] assertEquals(expected, result); [EOL] }
public void testToDateBeforeAdjustment() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(3); [EOL] time.setDayOfMonth(14); [EOL] Date result = time.toDate(); [EOL] assertEquals(13, result.getDate()); // Assuming the adjustment sets it to the day before [EOL] }
public void testToDateNoAdjustment() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(1); [EOL] time.setDayOfMonth(1); [EOL] Date result = time.toDate(); [EOL] assertEquals(1, result.getDate()); [EOL] }
public void testToDateWithDSTAdjustment() { [EOL] Time time = new Time(); // Assume Time is the class that contains toDate() [EOL] time.setYear(2021); [EOL] time.setMonthOfYear(11); [EOL] time.setDayOfMonth(7); [EOL] Date result = time.toDate(); [EOL] assertEquals(7, result.getDate()); [EOL] assertEquals(1, result.getHours()); // Assuming DST adjustment moves the hour back by 1 [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] try { [EOL] testDate.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_UnsupportedFieldType() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] DurationFieldType unsupportedType = DurationFieldType.centuries(); // Assuming centuries is not supported [EOL] try { [EOL] testDate.withFieldAdded(unsupportedType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] LocalDate result = testDate.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertEquals("Adding zero should not change the date", testDate, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] LocalDate testDate = LocalDate.now(); [EOL] LocalDate result = testDate.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotEquals("Adding one day should change the date", testDate, result); [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] LocalDate date = new LocalDate(); [EOL] LocalDate result = date.withPeriodAdded(null, 1); [EOL] assertEquals(date, result); [EOL] }
public void testWithPeriodAdded_ZeroScalar() { [EOL] LocalDate date = new LocalDate(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] LocalDate result = date.withPeriodAdded(period, 0); [EOL] assertEquals(date, result); [EOL] }
public void testWithPeriodAdded_SupportedType() { [EOL] LocalDate date = new LocalDate(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] LocalDate result = date.withPeriodAdded(period, 1); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.plusYears(1), result); [EOL] }
public void testWithPeriodAdded_UnsupportedType() { [EOL] LocalDate date = new LocalDate(); [EOL] ReadablePeriod period = new MockPeriod(); [EOL] LocalDate result = date.withPeriodAdded(period, 1); [EOL] assertEquals(date, result); [EOL] }
public LocalDate plus(ReadablePeriod period) { [EOL] return withPeriodAdded(period, 1); [EOL] }
public void testDayOfMonth() { [EOL] LocalDate date = LocalDate.now(); [EOL] Property property = date.dayOfMonth(); [EOL] assertNotNull(property); [EOL] assertEquals(date.getChronology().dayOfMonth(), property.getField()); [EOL] }
public void testPropertyWithValidArguments() { [EOL] LocalDate instant = LocalDate.now(); [EOL] DateTimeField field = DateTimeFieldType.dayOfMonth(); [EOL] Property property = new Property(instant, field); [EOL] assertNotNull(property); [EOL] assertEquals(instant, property.iInstant); [EOL] assertEquals(field, property.iField); [EOL] }
public void testPropertyWithNullInstant() { [EOL] DateTimeField field = DateTimeFieldType.dayOfMonth(); [EOL] try { [EOL] new Property(null, field); [EOL] fail("Should have thrown NullPointerException for null instant"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPropertyWithNullField() { [EOL] LocalDate instant = LocalDate.now(); [EOL] try { [EOL] new Property(instant, null); [EOL] fail("Should have thrown NullPointerException for null field"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] LocalDate initialDate = LocalDate.now(); [EOL] DateTimeField field = initialDate.getField(); [EOL] String validText = field.getAsText(initialDate, Locale.ENGLISH); [EOL] LocalDate updatedDate = initialDate.setCopy(validText, Locale.ENGLISH); [EOL] assertNotSame(initialDate, updatedDate); [EOL] assertEquals(field.get(updatedDate), field.get(initialDate)); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] LocalDate initialDate = LocalDate.now(); [EOL] try { [EOL] initialDate.setCopy("invalidText", Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] LocalDate initialDate = LocalDate.now(); [EOL] DateTimeField field = initialDate.getField(); [EOL] String validText = field.getAsText(initialDate, Locale.ENGLISH); [EOL] LocalDate updatedDate = initialDate.setCopy(validText, null); [EOL] assertNotSame(initialDate, updatedDate); [EOL] assertEquals(field.get(updatedDate), field.get(initialDate)); [EOL] }
public LocalDate setCopy(String text) { [EOL] return setCopy(text, null); [EOL] }
public int getMinimumValue() { [EOL] return DateTimeConstants.BCE; [EOL] }
public int getMaximumValueTest() { [EOL] Time time = new Time(); [EOL] int result = time.getMaximumValue(); [EOL] assertEquals(DateTimeConstants.CE, result); [EOL] }
public void testYearMonthDayTime_WhenTypeIsNull() { [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYMDTime", null); [EOL] PeriodType result = PeriodType.yearMonthDayTime(); [EOL] assertNotNull(result); [EOL] assertEquals("YearMonthDayTime", result.getName()); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.years())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.months())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.days())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.hours())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.minutes())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.seconds())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testYearMonthDayTime_WhenTypeIsNotNull() { [EOL] PeriodType initializedType = new PeriodType("YearMonthDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 }); [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYMDTime", initializedType); [EOL] PeriodType result = PeriodType.yearMonthDayTime(); [EOL] assertSame(initializedType, result); [EOL] }
public void testYearMonthDay_InitialCall() { [EOL] PeriodType result = Time.yearMonthDay(); [EOL] assertNotNull(result); [EOL] assertEquals("YearMonthDay", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.years())); [EOL] assertTrue(result.isSupported(DurationFieldType.months())); [EOL] assertFalse(result.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertFalse(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testYearMonthDay_SubsequentCall() { [EOL] Time.yearMonthDay(); [EOL] PeriodType result = Time.yearMonthDay(); [EOL] assertNotNull(result); [EOL] assertEquals("YearMonthDay", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.years())); [EOL] assertTrue(result.isSupported(DurationFieldType.months())); [EOL] assertFalse(result.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertFalse(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testYearWeekDay_WhenTypeIsNull() { [EOL] PeriodType actual = Time.yearWeekDay(); [EOL] assertNotNull(actual); [EOL] assertEquals("YearWeekDay", actual.getName()); [EOL] assertTrue(Arrays.asList(actual.getFieldTypes()).contains(DurationFieldType.years())); [EOL] assertTrue(Arrays.asList(actual.getFieldTypes()).contains(DurationFieldType.weeks())); [EOL] assertTrue(Arrays.asList(actual.getFieldTypes()).contains(DurationFieldType.days())); [EOL] } [EOL] public void testYearWeekDay_WhenTypeIsNotNull() { [EOL] Time.yearWeekDay(); [EOL] PeriodType actual = Time.yearWeekDay(); [EOL] assertNotNull(actual); [EOL] assertEquals("YearWeekDay", actual.getName()); [EOL] }
public void testYearDayTime_WhenTypeIsNull() { [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYDTime", null); [EOL] PeriodType result = PeriodType.yearDayTime(); [EOL] assertNotNull(result); [EOL] assertEquals("YearDayTime", result.getName()); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.years())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.days())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.hours())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.minutes())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.seconds())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testYearDayTime_WhenTypeIsNotNull() { [EOL] PeriodType initialType = new PeriodType("YearDayTime", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 }); [EOL] ReflectionTestUtils.setField(PeriodType.class, "cYDTime", initialType); [EOL] PeriodType result = PeriodType.yearDayTime(); [EOL] assertSame(initialType, result); [EOL] }
public void testYearDay_InitialCall() { [EOL] PeriodType result = Time.yearDay(); [EOL] assertNotNull(result); [EOL] assertEquals("YearDay", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.years())); [EOL] assertFalse(result.isSupported(DurationFieldType.months())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertFalse(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testYearDay_SubsequentCall() { [EOL] Time.yearDay(); [EOL] PeriodType result = Time.yearDay(); [EOL] assertNotNull(result); [EOL] assertEquals("YearDay", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.years())); [EOL] assertFalse(result.isSupported(DurationFieldType.months())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertFalse(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testDayTime_InitialCall() { [EOL] PeriodType result = Time.dayTime(); [EOL] assertNotNull(result); [EOL] assertEquals("DayTime", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertTrue(result.isSupported(DurationFieldType.hours())); [EOL] assertTrue(result.isSupported(DurationFieldType.minutes())); [EOL] assertTrue(result.isSupported(DurationFieldType.seconds())); [EOL] assertTrue(result.isSupported(DurationFieldType.millis())); [EOL] } [EOL] public void testDayTime_SubsequentCall() { [EOL] PeriodType firstCall = Time.dayTime(); [EOL] PeriodType secondCall = Time.dayTime(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testTime_WhenTypeIsNull() { [EOL] Time.cTime = null; [EOL] PeriodType result = Time.time(); [EOL] assertNotNull(result); [EOL] assertEquals("Time", result.getName()); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.hours())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.minutes())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.seconds())); [EOL] assertTrue(Arrays.asList(result.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testTime_WhenTypeIsNotNull() { [EOL] Time.cTime = new PeriodType("Time", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 }); [EOL] PeriodType result = Time.time(); [EOL] assertNotNull(result); [EOL] assertEquals("Time", result.getName()); [EOL] }
public void testYearsSingleton() { [EOL] PeriodType type1 = PeriodType.years(); [EOL] assertNotNull("The 'years' period type should not be null", type1); [EOL] PeriodType type2 = PeriodType.years(); [EOL] assertSame("The 'years' period type should be a singleton", type1, type2); [EOL] }
public void testHours_Cached() { [EOL] PeriodType type1 = PeriodType.hours(); [EOL] PeriodType type2 = PeriodType.hours(); [EOL] assertSame("Hours type should be cached", type1, type2); [EOL] }
public void testMinutesSingleton() { [EOL] PeriodType type1 = PeriodType.minutes(); [EOL] assertNotNull(type1); [EOL] PeriodType type2 = PeriodType.minutes(); [EOL] assertSame(type1, type2); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL] return (indexOf(type) >= 0); [EOL] }
public void testWithMinutesRemoved() { [EOL] PeriodType type = PeriodType.standard(); [EOL] PeriodType result = type.withMinutesRemoved(); [EOL] assertFalse(result.isSupported(DurationFieldType.minutes())); [EOL] assertTrue(result.isSupported(DurationFieldType.hours())); [EOL] assertTrue(result.isSupported(DurationFieldType.seconds())); [EOL] }
public void testSetCurrentMillisProviderWithNull() { [EOL] try { [EOL] DateTimeUtils.setCurrentMillisProvider(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The MillisProvider must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testSetCurrentMillisProviderWithValidProvider() throws SecurityException { [EOL] MillisProvider mockMillisProvider = new MillisProvider() { [EOL] public long getMillis() { [EOL] return System.currentTimeMillis(); [EOL] } [EOL] }; [EOL] DateTimeUtils.setCurrentMillisProvider(mockMillisProvider); [EOL] assertEquals(mockMillisProvider, DateTimeUtils.getCurrentMillisProvider()); [EOL] } [EOL] public void testSetCurrentMillisProviderWithSecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("setCurrentMillisProvider".equals(perm.getName())) { [EOL] throw new SecurityException("Permission denied"); [EOL] } [EOL] } [EOL] }); [EOL] MillisProvider mockMillisProvider = new MillisProvider() { [EOL] public long getMillis() { [EOL] return System.currentTimeMillis(); [EOL] } [EOL] }; [EOL] try { [EOL] DateTimeUtils.setCurrentMillisProvider(mockMillisProvider); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException ex) { [EOL] assertEquals("Permission denied", ex.getMessage()); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset SecurityManager [EOL] } [EOL] }
public void testGetIntervalChronology_WithNullInterval() { [EOL] Chronology result = Time.getIntervalChronology(null); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetIntervalChronology_WithNonNullIntervalAndNullChronology() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getChronology()).thenReturn(null); [EOL] Chronology result = Time.getIntervalChronology(interval); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ISOChronology); [EOL] }
public void testGetIntervalChronology_WithNonNullIntervalAndNonNullChronology() { [EOL] Chronology expectedChronology = mock(Chronology.class); [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getChronology()).thenReturn(expectedChronology); [EOL] Chronology result = Time.getIntervalChronology(interval); [EOL] assertSame(expectedChronology, result); [EOL] }
public void testGetZoneWithNullInput() { [EOL] DateTimeZone result = ClassName.getZone(null); [EOL] assertEquals(DateTimeZone.getDefault(), result); [EOL] }
public void testGetZoneWithNonNullInput() { [EOL] DateTimeZone expectedZone = DateTimeZone.forID("Europe/London"); [EOL] DateTimeZone result = ClassName.getZone(expectedZone); [EOL] assertSame(expectedZone, result); [EOL] }
public void testBaseIntervalWithValidInterval() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] BaseInterval interval = new BaseInterval(startInstant, endInstant, chrono); [EOL] assertEquals("Chronology should match", chrono, interval.getChronology()); [EOL] assertEquals("Start instant should match", startInstant, interval.getStartMillis()); [EOL] assertEquals("End instant should match", endInstant, interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithNullChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] BaseInterval interval = new BaseInterval(startInstant, endInstant, null); [EOL] assertEquals("Chronology should default to ISOChronology", ISOChronology.getInstanceUTC(), interval.getChronology()); [EOL] assertEquals("Start instant should match", startInstant, interval.getStartMillis()); [EOL] assertEquals("End instant should match", endInstant, interval.getEndMillis()); [EOL] }
public void testBaseIntervalWithInvalidInterval() { [EOL] long startInstant = 2000L; [EOL] long endInstant = 1000L; [EOL] try { [EOL] new BaseInterval(startInstant, endInstant, ISOChronology.getInstanceUTC()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBaseIntervalWithBothNullStartAndEnd() { [EOL] BaseInterval interval = new BaseInterval(null, null); [EOL] long currentMillis = DateTimeUtils.currentTimeMillis(); [EOL] assertEquals(currentMillis, interval.getStartMillis()); [EOL] assertEquals(currentMillis, interval.getEndMillis()); [EOL] assertTrue(interval.getChronology() instanceof ISOChronology); [EOL] }
public void testBaseIntervalWithNonNullStartAndEnd() { [EOL] ReadableInstant start = new Instant(0L); [EOL] ReadableInstant end = new Instant(1000L); [EOL] BaseInterval interval = new BaseInterval(start, end); [EOL] assertEquals(0L, interval.getStartMillis()); [EOL] assertEquals(1000L, interval.getEndMillis()); [EOL] assertTrue(interval.getChronology() instanceof ISOChronology); [EOL] }
public void testBaseIntervalWithStartAfterEnd() { [EOL] ReadableInstant start = new Instant(1000L); [EOL] ReadableInstant end = new Instant(0L); [EOL] try { [EOL] new BaseInterval(start, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
protected BaseInterval(ReadableDuration duration, ReadableInstant end) { [EOL] super(); [EOL] iChronology = DateTimeUtils.getInstantChronology(end); [EOL] iEndMillis = DateTimeUtils.getInstantMillis(end); [EOL] long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL] iStartMillis = FieldUtils.safeAdd(iEndMillis, -durationMillis); [EOL] checkInterval(iStartMillis, iEndMillis); [EOL] }
public void testGetChronology() { [EOL] Chronology expectedChronology = /* initialize with a test Chronology object */; [EOL] Time time = new Time(expectedChronology); [EOL] Chronology actualChronology = time.getChronology(); [EOL] assertEquals(expectedChronology, actualChronology); [EOL] }
public void testGetProvider() { [EOL] Provider result = YourClass.getProvider(); [EOL] assertNotNull("Provider should not be null", result); [EOL] }
public void testSetProvider0WithNullProvider() { [EOL] try { [EOL] Time.setProvider0(null); [EOL] fail("Should have thrown IllegalArgumentException for null provider ids"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The provider doesn't have any available ids", e.getMessage()); [EOL] } [EOL] }
public void testSetProvider0WithEmptyIds() { [EOL] Provider mockProvider = mock(Provider.class); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(new HashSet<>()); [EOL] try { [EOL] Time.setProvider0(mockProvider); [EOL] fail("Should have thrown IllegalArgumentException for empty ids"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The provider doesn't have any available ids", e.getMessage()); [EOL] } [EOL] }
public void testSetProvider0WithoutUTC() { [EOL] Provider mockProvider = mock(Provider.class); [EOL] Set<String> ids = new HashSet<>(Arrays.asList("GMT")); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(ids); [EOL] try { [EOL] Time.setProvider0(mockProvider); [EOL] fail("Should have thrown IllegalArgumentException for missing UTC"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The provider doesn't support UTC", e.getMessage()); [EOL] } [EOL] }
public void testSetProvider0WithInvalidUTCZone() { [EOL] Provider mockProvider = mock(Provider.class); [EOL] Set<String> ids = new HashSet<>(Arrays.asList("UTC")); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(ids); [EOL] when(mockProvider.getZone("UTC")).thenReturn(null); [EOL] try { [EOL] Time.setProvider0(mockProvider); [EOL] fail("Should have thrown IllegalArgumentException for invalid UTC zone"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid UTC zone provided", e.getMessage()); [EOL] } [EOL] }
public void testSetProvider0WithValidProvider() { [EOL] Provider mockProvider = mock(Provider.class); [EOL] Set<String> ids = new HashSet<>(Arrays.asList("UTC")); [EOL] when(mockProvider.getAvailableIDs()).thenReturn(ids); [EOL] when(mockProvider.getZone("UTC")).thenReturn(Time.UTC); [EOL] Time.setProvider0(mockProvider); [EOL] assertEquals(mockProvider, Time.getProvider()); [EOL] assertEquals(ids, Time.getAvailableIDs()); [EOL] }
public void testGetDefaultProviderWithSystemPropertySet() { [EOL] System.setProperty("org.joda.time.DateTimeZone.Provider", "com.example.CustomProvider"); [EOL] try { [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof com.example.CustomProvider); [EOL] } finally { [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] } [EOL] }
public void testGetDefaultProviderWithSecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("org.joda.time.DateTimeZone.Provider".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof ZoneInfoProvider || provider instanceof UTCProvider); [EOL] } finally { [EOL] System.setSecurityManager(null); [EOL] } [EOL] }
public void testGetDefaultProviderWithZoneInfoProvider() { [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof ZoneInfoProvider); [EOL] }
public void testGetDefaultProviderFallbackToUTCProvider() { [EOL] System.clearProperty("org.joda.time.DateTimeZone.Provider"); [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm.getName().startsWith("org.joda.time.DateTimeZone.Provider")) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] Provider provider = getDefaultProvider(); [EOL] assertNotNull(provider); [EOL] assertTrue(provider instanceof UTCProvider); [EOL] } finally { [EOL] System.setSecurityManager(null); [EOL] } [EOL] }
public void testGetNameProvider() { [EOL] NameProvider result = ClassName.getNameProvider(); [EOL] assertNotNull(result); [EOL] }
public void testSetNameProviderWithNoSecurityManager() { [EOL] NameProvider mockNameProvider = mock(NameProvider.class); [EOL] System.setSecurityManager(null); [EOL] try { [EOL] DateTimeZone.setNameProvider(mockNameProvider); [EOL] } catch (SecurityException e) { [EOL] fail("Should not throw SecurityException when SecurityManager is null"); [EOL] } [EOL] }
public void testSetNameProviderWithSecurityManagerAndPermission() { [EOL] NameProvider mockNameProvider = mock(NameProvider.class); [EOL] SecurityManager sm = mock(SecurityManager.class); [EOL] System.setSecurityManager(sm); [EOL] doNothing().when(sm).checkPermission(any(JodaTimePermission.class)); [EOL] try { [EOL] DateTimeZone.setNameProvider(mockNameProvider); [EOL] } catch (SecurityException e) { [EOL] fail("Should not throw SecurityException when SecurityManager allows permission"); [EOL] } [EOL] }
public void testSetNameProviderWithSecurityManagerAndNoPermission() { [EOL] NameProvider mockNameProvider = mock(NameProvider.class); [EOL] SecurityManager sm = mock(SecurityManager.class); [EOL] System.setSecurityManager(sm); [EOL] doThrow(new SecurityException()).when(sm).checkPermission(any(JodaTimePermission.class)); [EOL] try { [EOL] DateTimeZone.setNameProvider(mockNameProvider); [EOL] fail("Should throw SecurityException when SecurityManager denies permission"); [EOL] } catch (SecurityException e) { [EOL] } [EOL] }
public void testSetNameProviderWithNull() { [EOL] NameProvider originalProvider = Time.getNameProvider(); [EOL] Time.setNameProvider0(null); [EOL] NameProvider newProvider = Time.getNameProvider(); [EOL] assertNotNull(newProvider); [EOL] assertNotSame(originalProvider, newProvider); [EOL] }
public void testSetNameProviderWithNonNull() { [EOL] NameProvider originalProvider = Time.getNameProvider(); [EOL] NameProvider customProvider = new CustomNameProvider(); [EOL] Time.setNameProvider0(customProvider); [EOL] NameProvider newProvider = Time.getNameProvider(); [EOL] assertNotNull(newProvider); [EOL] assertSame(customProvider, newProvider); [EOL] }
public void testGetDefaultNameProviderWithSystemPropertySet() { [EOL] System.setProperty("org.joda.time.DateTimeZone.NameProvider", "com.example.CustomNameProvider"); [EOL] NameProvider result = getDefaultNameProvider(); [EOL] assertTrue(result instanceof com.example.CustomNameProvider); [EOL] System.clearProperty("org.joda.time.DateTimeZone.NameProvider"); [EOL] }
public void testGetDefaultNameProviderWithSystemPropertyNotSet() { [EOL] System.clearProperty("org.joda.time.DateTimeZone.NameProvider"); [EOL] NameProvider result = getDefaultNameProvider(); [EOL] assertTrue(result instanceof DefaultNameProvider); [EOL] }
public void testGetDefaultNameProviderWithSecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("org.joda.time.DateTimeZone.NameProvider".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] NameProvider result = getDefaultNameProvider(); [EOL] assertTrue(result instanceof DefaultNameProvider); [EOL] System.setSecurityManager(null); // Reset security manager [EOL] }
public final String getShortName(long instant) { [EOL] return getShortName(instant, null); [EOL] }
public void testGetShortNameWithNullLocale() { [EOL] long instant = System.currentTimeMillis(); [EOL] String result = getShortName(instant, null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetShortNameWithNonNullLocaleAndNameKeyNull() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = new Locale("en"); [EOL] String result = getShortName(instant, locale); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetShortNameWithNonNullLocaleAndNonNullNameKey() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = new Locale("en"); [EOL] String result = getShortName(instant, locale); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetShortNameWithNonNullLocaleAndNonNullNameKeyButNullName() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = new Locale("en"); [EOL] String result = getShortName(instant, locale); [EOL] assertNotNull(result); [EOL] }
public final String getName(long instant) { [EOL] return getName(instant, null); [EOL] }
public void testGetNameWithNullLocale() { [EOL] long instant = System.currentTimeMillis(); [EOL] String expectedID = "expectedID"; [EOL] String expectedName = "expectedName"; [EOL] Time time = new Time(expectedID, null, null) { [EOL] public String getNameKey(long instant) { [EOL] return "nameKey"; [EOL] } [EOL] public String printOffset(int offset) { [EOL] return "offsetString"; [EOL] } [EOL] }; [EOL] String result = time.getName(instant, null); [EOL] assertEquals(expectedName, result); [EOL] }
public void testGetNameWithNonNullLocaleAndNameKeyNull() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = new Locale("en"); [EOL] String expectedID = "expectedID"; [EOL] Time time = new Time(expectedID, null, null) { [EOL] public String getNameKey(long instant) { [EOL] return null; [EOL] } [EOL] public String printOffset(int offset) { [EOL] return "offsetString"; [EOL] } [EOL] }; [EOL] String result = time.getName(instant, locale); [EOL] assertEquals(expectedID, result); [EOL] }
public void testGetNameWithNonNullLocaleAndNonNullNameKey() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = new Locale("en"); [EOL] String expectedID = "expectedID"; [EOL] String expectedName = "expectedName"; [EOL] Time time = new Time(expectedID, null, null) { [EOL] public String getNameKey(long instant) { [EOL] return "nameKey"; [EOL] } [EOL] public String printOffset(int offset) { [EOL] return "offsetString"; [EOL] } [EOL] public String getName(Locale locale, String id, String nameKey) { [EOL] return expectedName; [EOL] } [EOL] }; [EOL] String result = time.getName(instant, locale); [EOL] assertEquals(expectedName, result); [EOL] }
public void testGetNameWithNonNullLocaleAndNonNullNameKeyButNullName() { [EOL] long instant = System.currentTimeMillis(); [EOL] Locale locale = new Locale("en"); [EOL] String expectedID = "expectedID"; [EOL] Time time = new Time(expectedID, null, null) { [EOL] public String getNameKey(long instant) { [EOL] return "nameKey"; [EOL] } [EOL] public String printOffset(int offset) { [EOL] return "offsetString"; [EOL] } [EOL] public String getName(Locale locale, String id, String nameKey) { [EOL] return null; [EOL] } [EOL] }; [EOL] String result = time.getName(instant, locale); [EOL] assertEquals("offsetString", result); [EOL] }
public void testGetOffsetFromLocal_SameOffsets() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(0); [EOL] when(getOffset(instantLocal - 0)).thenReturn(0); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(0, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_PositiveOffsetChange() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(-1); [EOL] when(getOffset(instantLocal + 1)).thenReturn(0); [EOL] when(nextTransition(instantLocal + 1)).thenReturn(1L); [EOL] when(nextTransition(instantLocal)).thenReturn(2L); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(-1, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_NegativeOffsetChange() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(0); [EOL] when(previousTransition(instantLocal - 1)).thenReturn(-1L); [EOL] when(getOffset(-1L)).thenReturn(-1); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(-1, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_PositiveOffsetChange_EqualNextTransition() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(-1); [EOL] when(getOffset(instantLocal + 1)).thenReturn(0); [EOL] when(nextTransition(instantLocal + 1)).thenReturn(1L); [EOL] when(nextTransition(instantLocal)).thenReturn(1L); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(0, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_NegativeOffsetChange_SamePreviousTransition() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(0); [EOL] when(previousTransition(instantLocal - 1)).thenReturn(-1L); [EOL] when(getOffset(-1L)).thenReturn(1); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(1, result); [EOL] }
public void testConvertLocalToUTC_SameOffsetNonStrict() { [EOL] long instantLocal = SOME_INSTANT; [EOL] boolean strict = false; [EOL] long expected = instantLocal - getOffset(instantLocal); [EOL] long actual = convertLocalToUTC(instantLocal, strict); [EOL] assertEquals(expected, actual); [EOL] }
public void testConvertLocalToUTC_DifferentOffsetStrict() { [EOL] long instantLocal = SOME_INSTANT; [EOL] boolean strict = true; [EOL] try { [EOL] convertLocalToUTC(instantLocal, strict); [EOL] fail("Should have thrown IllegalInstantException"); [EOL] } catch (IllegalInstantException e) { [EOL] } [EOL] }
public void testConvertLocalToUTC_DifferentOffsetNonStrict() { [EOL] long instantLocal = SOME_INSTANT; [EOL] boolean strict = false; [EOL] long expected = instantLocal - getOffset(instantLocal); [EOL] long actual = convertLocalToUTC(instantLocal, strict); [EOL] assertEquals(expected, actual); [EOL] }
public void testConvertLocalToUTC_Overflow() { [EOL] long instantLocal = SOME_INSTANT; [EOL] boolean strict = true; [EOL] try { [EOL] convertLocalToUTC(instantLocal, strict); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public String toString() { [EOL] return getID(); [EOL] }
public void testEquals_Reflexive() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] assertTrue(chrono1.equals(chrono1)); [EOL] }
public void testEquals_Null() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] assertFalse(chrono1.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] Object obj = new Object(); [EOL] assertFalse(chrono1.equals(obj)); [EOL] }
public void testEquals_EqualChronology() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] BasicChronology chrono2 = new BasicChronology(); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentMinimumDays() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] BasicChronology chrono2 = new BasicChronology(); [EOL] chrono2.setMinimumDaysInFirstWeek(chrono1.getMinimumDaysInFirstWeek() + 1); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentZone() { [EOL] BasicChronology chrono1 = new BasicChronology(); [EOL] BasicChronology chrono2 = new BasicChronology(); [EOL] chrono2.setZone(DifferentZone); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testHashCode() { [EOL] Time time1 = new Time("Zone1", 7); [EOL] int expectedHashCode1 = time1.getClass().getName().hashCode() * 11 + time1.getZone().hashCode() + time1.getMinimumDaysInFirstWeek(); [EOL] assertEquals(expectedHashCode1, time1.hashCode()); [EOL] }
public void testHashCodeWithDifferentZone() { [EOL] Time time1 = new Time("Zone1", 7); [EOL] Time time2 = new Time("Zone2", 7); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testHashCodeWithDifferentMinimumDays() { [EOL] Time time1 = new Time("Zone1", 7); [EOL] Time time2 = new Time("Zone1", 6); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testAssemble() { [EOL] Fields fields = new Fields(); [EOL] assemble(fields); [EOL] assertNotNull(fields.millis); [EOL] assertNotNull(fields.seconds); [EOL] assertNotNull(fields.minutes); [EOL] assertNotNull(fields.hours); [EOL] assertNotNull(fields.halfdays); [EOL] assertNotNull(fields.days); [EOL] assertNotNull(fields.weeks); [EOL] assertNotNull(fields.millisOfSecond); [EOL] assertNotNull(fields.millisOfDay); [EOL] assertNotNull(fields.secondOfMinute); [EOL] assertNotNull(fields.secondOfDay); [EOL] assertNotNull(fields.minuteOfHour); [EOL] assertNotNull(fields.minuteOfDay); [EOL] assertNotNull(fields.hourOfDay); [EOL] assertNotNull(fields.hourOfHalfday); [EOL] assertNotNull(fields.clockhourOfDay); [EOL] assertNotNull(fields.clockhourOfHalfday); [EOL] assertNotNull(fields.halfdayOfDay); [EOL] assertNotNull(fields.year); [EOL] assertNotNull(fields.yearOfEra); [EOL] assertNotNull(fields.centuryOfEra); [EOL] assertNotNull(fields.centuries); [EOL] assertNotNull(fields.yearOfCentury); [EOL] assertNotNull(fields.era); [EOL] assertNotNull(fields.dayOfWeek); [EOL] assertNotNull(fields.dayOfMonth); [EOL] assertNotNull(fields.dayOfYear); [EOL] assertNotNull(fields.monthOfYear); [EOL] assertNotNull(fields.weekyear); [EOL] assertNotNull(fields.weekOfWeekyear); [EOL] assertNotNull(fields.weekyearOfCentury); [EOL] assertNotNull(fields.years); [EOL] assertNotNull(fields.months); [EOL] assertNotNull(fields.weekyears); [EOL] }
public void testGetWeeksInYear_NormalYear() { [EOL] int year = 2021; // A non-leap year [EOL] int expectedWeeks = 52; [EOL] int actualWeeks = getWeeksInYear(year); [EOL] assertEquals(expectedWeeks, actualWeeks); [EOL] }
public void testGetWeeksInYear_LeapYear() { [EOL] int year = 2020; // A leap year [EOL] int expectedWeeks = 52; [EOL] int actualWeeks = getWeeksInYear(year); [EOL] assertEquals(expectedWeeks, actualWeeks); [EOL] }
public void testGetFirstWeekOfYearMillis_WhenJan1DayOfWeekGreaterThanMinDaysInFirstWeek() { [EOL] int year = 2021; // A year where January 1st is later in the week than iMinDaysInFirstWeek [EOL] long expected = /* calculate expected millis for the first week of the year */; [EOL] long actual = getFirstWeekOfYearMillis(year); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetFirstWeekOfYearMillis_WhenJan1DayOfWeekLessThanOrEqualToMinDaysInFirstWeek() { [EOL] int year = 2020; // A year where January 1st is earlier in the week than or equal to iMinDaysInFirstWeek [EOL] long expected = /* calculate expected millis for the first week of the year */; [EOL] long actual = getFirstWeekOfYearMillis(year); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWeekyear_WeekIsOne() { [EOL] long instant = //... initialize to a time where week of weekyear is 1 [EOL] int expectedYear = //... expected year when week is 1 [EOL] int actualYear = getWeekyear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekyear_WeekGreaterThan51() { [EOL] long instant = //... initialize to a time where week of weekyear is greater than 51 [EOL] int expectedYear = //... expected year when week is greater than 51 [EOL] int actualYear = getWeekyear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekyear_WeekLessThan52AndNotOne() { [EOL] long instant = //... initialize to a time where week of weekyear is less than 52 and not 1 [EOL] int expectedYear = //... expected year for other cases [EOL] int actualYear = getWeekyear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetWeekOfWeekyearWithCurrentInstant() { [EOL] long currentInstant = System.currentTimeMillis(); [EOL] int expectedWeek = DateTime.now().getWeekOfWeekyear(); [EOL] int actualWeek = getWeekOfWeekyear(currentInstant); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyearWithSpecificInstant() { [EOL] long specificInstant = new DateTime(2023, 1, 1, 0, 0).getMillis(); [EOL] int expectedWeek = 1; // Assuming the first week of 2023 starts on January 1st [EOL] int actualWeek = getWeekOfWeekyear(specificInstant); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyearWithYearBoundaryInstant() { [EOL] long yearBoundaryInstant = new DateTime(2022, 12, 31, 23, 59).getMillis(); [EOL] int expectedWeek = new DateTime(2022, 12, 31, 23, 59).getWeekOfWeekyear(); [EOL] int actualWeek = getWeekOfWeekyear(yearBoundaryInstant); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_BeforeFirstWeek() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year) - 1; // One millisecond before the first week of the year [EOL] int expectedWeek = getWeeksInYear(year - 1); [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_FirstWeek() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year); // Exactly the first week of the year [EOL] int expectedWeek = 1; [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_LastWeek() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year + 1) - DateTimeConstants.MILLIS_PER_WEEK; // Last week of the year [EOL] int expectedWeek = (int) ((instant - getFirstWeekOfYearMillis(year)) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetWeekOfWeekyear_FirstWeekOfNextYear() { [EOL] int year = 2021; [EOL] long instant = getFirstWeekOfYearMillis(year + 1); // Exactly the first week of the next year [EOL] int expectedWeek = 1; [EOL] int actualWeek = getWeekOfWeekyear(instant, year); [EOL] assertEquals(expectedWeek, actualWeek); [EOL] }
public void testGetDayOfWeekForPositiveInstant() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY; // Assuming this is a positive constant [EOL] int expectedDayOfWeek = 1 + (int) ((1 + 3) % 7); [EOL] int actualDayOfWeek = getDayOfWeek(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testGetDayOfWeekForNegativeInstantGreaterThanMinusThree() { [EOL] long instant = -1; // A negative instant just before the epoch [EOL] int expectedDayOfWeek = 1 + (int) ((-1 - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY + 3) % 7; [EOL] int actualDayOfWeek = getDayOfWeek(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testGetDayOfWeekForNegativeInstantLessThanMinusThree() { [EOL] long instant = -4 * DateTimeConstants.MILLIS_PER_DAY; // A negative instant sufficiently before the epoch [EOL] int expectedDayOfWeek = 7 + (int) (((-4 - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY + 4) % 7); [EOL] int actualDayOfWeek = getDayOfWeek(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testGetYearInfo_WithNotCachedYear() { [EOL] int year = 2023; // Choose a year that is not cached [EOL] YearInfo result = getYearInfo(year); [EOL] assertNotNull(result); [EOL] assertEquals(year, result.iYear); [EOL] assertEquals(calculateFirstDayOfYearMillis(year), result.iFirstDayMillis); [EOL] } [EOL] public void testGetYearInfo_WithCachedYear() { [EOL] int year = 2023; // Choose a year that is likely to be cached [EOL] YearInfo cachedInfo = new YearInfo(year, calculateFirstDayOfYearMillis(year)); [EOL] iYearInfoCache[year & CACHE_MASK] = cachedInfo; [EOL] YearInfo result = getYearInfo(year); [EOL] assertSame(cachedInfo, result); [EOL] }
public void testGetAsTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 0; // Assuming 0 represents a valid half-day value [EOL] Locale locale = Locale.US; [EOL] String expected = "AM"; // Assuming "AM" is the text for the half-day value 0 in Locale.US [EOL] String result = getAsText(fieldValue, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAsTextWithInvalidFieldValue() { [EOL] int fieldValue = -1; // Assuming -1 is an invalid half-day value [EOL] Locale locale = Locale.US; [EOL] try { [EOL] getAsText(fieldValue, locale); [EOL] fail("Should have thrown an exception for invalid field value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsTextWithNullLocale() { [EOL] int fieldValue = 0; // Assuming 0 represents a valid half-day value [EOL] Locale locale = null; [EOL] try { [EOL] getAsText(fieldValue, locale); [EOL] fail("Should have thrown an exception for null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testYearInfoConstructor() { [EOL] int year = 2020; [EOL] long firstDayMillis = 1580515200000L; // Assume this is the correct millis for the first day of the year 2020 [EOL] YearInfo yearInfo = new YearInfo(year, firstDayMillis); [EOL] assertEquals(year, yearInfo.iYear); [EOL] assertEquals(firstDayMillis, yearInfo.iFirstDayMillis); [EOL] }
protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL] super(); [EOL] type = checkPeriodType(type); [EOL] if (startInstant == null && endInstant == null) { [EOL] iType = type; [EOL] iValues = new int[size()]; [EOL] } else { [EOL] long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL] long endMillis = DateTimeUtils.getInstantMillis(endInstant); [EOL] Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant); [EOL] iType = type; [EOL] iValues = chrono.get(this, startMillis, endMillis); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
public Duration toDurationFrom(ReadableInstant startInstant) { [EOL] long startMillis = DateTimeUtils.getInstantMillis(startInstant); [EOL] Chronology chrono = DateTimeUtils.getInstantChronology(startInstant); [EOL] long endMillis = chrono.add(this, startMillis, 1); [EOL] return new Duration(startMillis, endMillis); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected void addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void mergePeriod(ReadablePeriod period) { [EOL] if (period != null) { [EOL] setValues(mergePeriodInto(getValues(), period)); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected int[] mergePeriodInto(int[] values, ReadablePeriod period) { [EOL] for (int i = 0, isize = period.size(); i < isize; i++) { [EOL] DurationFieldType type = period.getFieldType(i); [EOL] int value = period.getValue(i); [EOL] checkAndUpdate(type, values, value); [EOL] } [EOL] return values; [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; }]
protected int[] addPeriodInto(int[] values, ReadablePeriod period) { [EOL] for (int i = 0, isize = period.size(); i < isize; i++) { [EOL] DurationFieldType type = period.getFieldType(i); [EOL] int value = period.getValue(i); [EOL] if (value != 0) { [EOL] int index = indexOf(type); [EOL] if (index == -1) { [EOL] throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL] } else { [EOL] values[index] = FieldUtils.safeAdd(getValue(index), value); [EOL] } [EOL] } [EOL] } [EOL] return values; [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
public void testForFieldsWithNullCollection() { [EOL] try { [EOL] DateTimeFormatter.forFields(null, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithEmptyCollection() { [EOL] try { [EOL] DateTimeFormatter.forFields(Collections.emptyList(), true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithMonthOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekOfWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfMonth() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfWeek() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithUnsupportedOperationException() { [EOL] Set<DateTimeFieldType> fields = new HashSet<DateTimeFieldType>() { [EOL] @Override [EOL] public boolean retainAll(Collection<?> c) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithInvalidFields() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); // Assuming hourOfDay is not supported by the method [EOL] try { [EOL] DateTimeFormatter.forFields(fields, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No valid format for fields: " + fields, e.getMessage()); [EOL] } [EOL] }
public void testDateByMonthWithYearMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearMonth() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithYearDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = true; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithMonthDay() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByMonthWithMonthOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByMonthWithDayOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByMonth(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearAndWeekOfWeekyear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearWeekOfWeekyearAndDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearAndDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithWeekOfWeekyear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekOfWeekyearAndDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithStrictISO() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = true; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testTimeWithNoFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] time(bld, fields, false, false, false, false); [EOL] assertTrue(bld.toFormatter().toString().isEmpty()); [EOL] }
public void testTimeWithHourOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] time(bld, fields, false, false, false, false); [EOL] assertEquals("H", bld.toFormatter().toString()); [EOL] }
public void testTimeWithHourAndMinute() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("H:M", bld.toFormatter().toString()); [EOL] }
public void testTimeWithAllFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] fields.add(DateTimeFieldType.millisOfSecond()); [EOL] time(bld, fields, true, false, false, false); [EOL] assertEquals("H:M:S.MMM", bld.toFormatter().toString()); [EOL] }
public void testTimeWithStrictISOAndReducedPrecision() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] try { [EOL] time(bld, fields, false, true, true, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOAndDatePresent() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] try { [EOL] time(bld, fields, false, true, false, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeWithStrictISOAndNoHour() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.minuteOfHour()); [EOL] fields.add(DateTimeFieldType.secondOfMinute()); [EOL] try { [EOL] time(bld, fields, false, true, false, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCheckNotStrictISOWithStrictISOTrue() { [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] try { [EOL] checkNotStrictISO(fields, true); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No valid ISO8601 format for fields: " + fields, e.getMessage()); [EOL] } [EOL] }
public void testCheckNotStrictISOWithStrictISOFalse() { [EOL] Collection<DateTimeFieldType> fields = new ArrayList<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] checkNotStrictISO(fields, false); [EOL] }
public void testDateTimeParser() { [EOL] DateTimeFormatter result = YourClass.dateTimeParser(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.dtp, result); [EOL] }
public static DateTimeFormatter timeNoMillis() { [EOL] return Constants.tx; [EOL] }
public static DateTimeFormatter ordinalDateTime() { [EOL] return Constants.odt; [EOL] }
public void testWeekDateTime() { [EOL] DateTimeFormatter result = ClassName.weekDateTime(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.wdt, result); [EOL] }
public static DateTimeFormatter basicDate() { [EOL] return Constants.bd; [EOL] }
public void testBasicWeekDate() { [EOL] DateTimeFormatter formatter = Time.basicWeekDate(); [EOL] assertNotNull(formatter); [EOL] }
public void testHourFormatter() { [EOL] DateTimeFormatter formatter = ClassName.hour(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter pattern", "hde", formatter.toString()); [EOL] }
public void testDateHour() { [EOL] DateTimeFormatter result = ClassName.dateHour(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.dh, result); [EOL] }
public void testMinutesZero() { [EOL] Minutes result = Time.minutes(0); [EOL] assertSame(Minutes.ZERO, result); [EOL] }
public void testMinutesOne() { [EOL] Minutes result = Time.minutes(1); [EOL] assertSame(Minutes.ONE, result); [EOL] }
public void testMinutesTwo() { [EOL] Minutes result = Time.minutes(2); [EOL] assertSame(Minutes.TWO, result); [EOL] }
public void testMinutesThree() { [EOL] Minutes result = Time.minutes(3); [EOL] assertSame(Minutes.THREE, result); [EOL] }
public void testMinutesMaxValue() { [EOL] Minutes result = Time.minutes(Integer.MAX_VALUE); [EOL] assertSame(Minutes.MAX_VALUE, result); [EOL] }
public void testMinutesMinValue() { [EOL] Minutes result = Time.minutes(Integer.MIN_VALUE); [EOL] assertSame(Minutes.MIN_VALUE, result); [EOL] }
public void testMinutesArbitrary() { [EOL] int arbitraryValue = 42; // Any value other than 0, 1, 2, 3, Integer.MAX_VALUE, Integer.MIN_VALUE [EOL] Minutes result = Time.minutes(arbitraryValue); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryValue, result.getMinutes()); [EOL] }
public void testStandardMinutesIn_NullPeriod() { [EOL] try { [EOL] Time.standardMinutesIn(null); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testStandardMinutesIn_ZeroMinutes() { [EOL] ReadablePeriod period = new Period(0, DateTimeConstants.MILLIS_PER_MINUTE); [EOL] Minutes result = Time.standardMinutesIn(period); [EOL] assertEquals("Expected zero minutes", Minutes.ZERO, result); [EOL] }
public void testStandardMinutesIn_NonZeroMinutes() { [EOL] ReadablePeriod period = new Period(0, 2 * DateTimeConstants.MILLIS_PER_MINUTE); [EOL] Minutes result = Time.standardMinutesIn(period); [EOL] assertEquals("Expected two minutes", Minutes.minutes(2), result); [EOL] }
public void testReadResolve() { [EOL] Minutes testMinutes = Minutes.minutes(5); [EOL] Object result = testMinutes.readResolve(); [EOL] assertTrue(result instanceof Minutes); [EOL] assertEquals(testMinutes, result); [EOL] }
public void testToStandardHours_ZeroMinutes() { [EOL] Minutes minutes = Minutes.minutes(0); [EOL] Hours result = minutes.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_PositiveMinutes() { [EOL] Minutes minutes = Minutes.minutes(60); [EOL] Hours result = minutes.toStandardHours(); [EOL] assertEquals(1, result.getHours()); [EOL] }
public void testToStandardHours_NegativeMinutes() { [EOL] Minutes minutes = Minutes.minutes(-60); [EOL] Hours result = minutes.toStandardHours(); [EOL] assertEquals(-1, result.getHours()); [EOL] }
public void testToStandardHours_PositiveMinutesNotFullHour() { [EOL] Minutes minutes = Minutes.minutes(30); [EOL] Hours result = minutes.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToStandardHours_NegativeMinutesNotFullHour() { [EOL] Minutes minutes = Minutes.minutes(-30); [EOL] Hours result = minutes.toStandardHours(); [EOL] assertEquals(0, result.getHours()); [EOL] }
public int getMinutes() { [EOL] return getValue(); [EOL] }
public void testPlus_ZeroMinutes() { [EOL] Minutes originalMinutes = Minutes.minutes(5); [EOL] Minutes resultMinutes = originalMinutes.plus(0); [EOL] assertEquals("Adding zero should return the same Minutes instance", originalMinutes, resultMinutes); [EOL] }
public void testPlus_PositiveMinutes() { [EOL] Minutes originalMinutes = Minutes.minutes(5); [EOL] Minutes resultMinutes = originalMinutes.plus(10); [EOL] assertEquals("Adding positive minutes should return new Minutes instance with updated minutes", 15, resultMinutes.getValue()); [EOL] }
public void testPlus_NegativeMinutes() { [EOL] Minutes originalMinutes = Minutes.minutes(5); [EOL] Minutes resultMinutes = originalMinutes.plus(-3); [EOL] assertEquals("Adding negative minutes should return new Minutes instance with updated minutes", 2, resultMinutes.getValue()); [EOL] }
public void testPlusWithNullMinutes() { [EOL] Minutes originalMinutes = new Minutes(5); [EOL] Minutes result = originalMinutes.plus(null); [EOL] assertEquals("Result should be the same as original minutes when adding null", 5, result.getValue()); [EOL] }
public void testPlusWithNonNullMinutes() { [EOL] Minutes originalMinutes = new Minutes(5); [EOL] Minutes additionalMinutes = new Minutes(10); [EOL] Minutes result = originalMinutes.plus(additionalMinutes); [EOL] assertEquals("Result should be the sum of original and additional minutes", 15, result.getValue()); [EOL] }
public void testMinus_Zero() { [EOL] Minutes minutes = Minutes.minutes(10); [EOL] Minutes result = minutes.minus(0); [EOL] assertEquals(10, result.getMinutes()); [EOL] }
public void testMinus_Positive() { [EOL] Minutes minutes = Minutes.minutes(10); [EOL] Minutes result = minutes.minus(5); [EOL] assertEquals(5, result.getMinutes()); [EOL] }
public void testMinus_Negative() { [EOL] Minutes minutes = Minutes.minutes(10); [EOL] Minutes result = minutes.minus(-5); [EOL] assertEquals(15, result.getMinutes()); [EOL] }
public void testMinus_MaxInt() { [EOL] Minutes minutes = Minutes.minutes(10); [EOL] Minutes result = minutes.minus(Integer.MAX_VALUE); [EOL] assertTrue(result.getMinutes() < 0); [EOL] }
public void testMinus_MinInt() { [EOL] Minutes minutes = Minutes.minutes(10); [EOL] Minutes result = minutes.minus(Integer.MIN_VALUE); [EOL] assertTrue(result.getMinutes() > 0); [EOL] }
public void testToString() { [EOL] Time time = new Time(10); [EOL] String result = time.toString(); [EOL] assertEquals("PT10M", result); [EOL] }
static int parseMonth(String str) { [EOL] DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear(); [EOL] return field.get(field.set(0, str, Locale.ENGLISH)); [EOL] }
static int parseDayOfWeek(String str) { [EOL] DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek(); [EOL] return field.get(field.set(0, str, Locale.ENGLISH)); [EOL] } public ZoneInfoCompiler();  DateTimeOfYear();  DateTimeOfYear(StringTokenizer st);  Rule(StringTokenizer st);  RuleSet(Rule rule);  Zone(StringTokenizer st); private Zone(String name, StringTokenizer st); protected Boolean initialValue(); public static boolean verbose(); public static void main(String[] args) throws Exception; private static void printUsage();  static DateTimeOfYear getStartOfYear();  static Chronology getLenientISOChronology();  static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException;  static int parseYear(String str, int def);  static int parseMonth(String str);  static int parseDayOfWeek(String str);  static String parseOptional(String str);  static int parseTime(String str);  static char parseZoneChar(char c);  static boolean test(String id, DateTimeZone tz); public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException; public void parseDataFile(BufferedReader in) throws IOException; public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear); public void addCutover(DateTimeZoneBuilder builder, int year); public String toString(); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat); private String formatName(String nameFormat); public String toString();  void addRule(Rule rule); public void addRecurring(DateTimeZoneBuilder builder, String nameFormat);  void chain(StringTokenizer st); public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets); public String toString(); DateTimeOfYear cStartOfYear; Chronology cLenientISO; ThreadLocal<Boolean> cVerbose=Optional[new ThreadLocal<Boolean>() {; ;     protected Boolean initialValue() {;         return Boolean.FALSE;;     }; }]
static char parseZoneChar(char c) { [EOL] switch(c) { [EOL] case 's': [EOL] case 'S': [EOL] return 's'; [EOL] case 'u': [EOL] case 'U': [EOL] case 'g': [EOL] case 'G': [EOL] case 'z': [EOL] case 'Z': [EOL] return 'u'; [EOL] case 'w': [EOL] case 'W': [EOL] default: [EOL] return 'w'; [EOL] } [EOL] }
DateTimeOfYear(StringTokenizer st) { [EOL] int month = 1; [EOL] int day = 1; [EOL] int dayOfWeek = 0; [EOL] int millis = 0; [EOL] boolean advance = false; [EOL] char zoneChar = 'w'; [EOL] if (st.hasMoreTokens()) { [EOL] month = parseMonth(st.nextToken()); [EOL] if (st.hasMoreTokens()) { [EOL] String str = st.nextToken(); [EOL] if (str.startsWith("last")) { [EOL] day = -1; [EOL] dayOfWeek = parseDayOfWeek(str.substring(4)); [EOL] advance = false; [EOL] } else { [EOL] try { [EOL] day = Integer.parseInt(str); [EOL] dayOfWeek = 0; [EOL] advance = false; [EOL] } catch (NumberFormatException e) { [EOL] int index = str.indexOf(">="); [EOL] if (index > 0) { [EOL] day = Integer.parseInt(str.substring(index + 2)); [EOL] dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL] advance = true; [EOL] } else { [EOL] index = str.indexOf("<="); [EOL] if (index > 0) { [EOL] day = Integer.parseInt(str.substring(index + 2)); [EOL] dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL] advance = false; [EOL] } else { [EOL] throw new IllegalArgumentException(str); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (st.hasMoreTokens()) { [EOL] str = st.nextToken(); [EOL] zoneChar = parseZoneChar(str.charAt(str.length() - 1)); [EOL] if (str.equals("24:00")) { [EOL] LocalDate date = (day == -1 ? new LocalDate(2001, month, 1).plusMonths(1) : new LocalDate(2001, month, day).plusDays(1)); [EOL] advance = (day != -1); [EOL] month = date.getMonthOfYear(); [EOL] day = date.getDayOfMonth(); [EOL] dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1; [EOL] } else { [EOL] millis = parseTime(str); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] iMonthOfYear = month; [EOL] iDayOfMonth = day; [EOL] iDayOfWeek = dayOfWeek; [EOL] iAdvanceDayOfWeek = advance; [EOL] iMillisOfDay = millis; [EOL] iZoneChar = zoneChar; [EOL] }
public void testGetInstanceWithNullZoneAndValidMinDays() { [EOL] int minDaysInFirstWeek = 4; // Assuming 4 is a valid number of minimum days [EOL] GregorianChronology chrono = GregorianChronology.getInstance(null, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithNonNullZoneAndValidMinDays() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); // Assuming "Europe/Paris" is a valid time zone [EOL] int minDaysInFirstWeek = 4; // Assuming 4 is a valid number of minimum days [EOL] GregorianChronology chrono = GregorianChronology.getInstance(zone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(zone, chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithInvalidMinDays() { [EOL] int minDaysInFirstWeek = 0; // Assuming 0 is an invalid number of minimum days [EOL] try { [EOL] GregorianChronology.getInstance(null, minDaysInFirstWeek); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstanceWithUTCZoneAndValidMinDays() { [EOL] DateTimeZone utcZone = DateTimeZone.UTC; [EOL] int minDaysInFirstWeek = 4; // Assuming 4 is a valid number of minimum days [EOL] GregorianChronology chrono = GregorianChronology.getInstance(utcZone, minDaysInFirstWeek); [EOL] assertNotNull(chrono); [EOL] assertEquals(utcZone, chrono.getZone()); [EOL] assertEquals(minDaysInFirstWeek, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testCalculateFirstDayOfYearMillisForNegativeNonLeapYear() { [EOL] int year = -3; // A negative non-leap year [EOL] long expectedMillis = ((year * 365L) + ((year + 3) >> 2) - 1 - DAYS_0000_TO_1970) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForNegativeLeapYear() { [EOL] int year = -4; // A negative leap year [EOL] long expectedMillis = ((year * 365L) + ((year + 3) >> 2) - 1 - DAYS_0000_TO_1970) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForPositiveNonLeapYear() { [EOL] int year = 1; // A positive non-leap year [EOL] long expectedMillis = ((year * 365L) + (year >> 2) - (year / 100) + ((year / 100) >> 2) - DAYS_0000_TO_1970) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForPositiveLeapYear() { [EOL] int year = 4; // A positive leap year [EOL] long expectedMillis = ((year * 365L) + (year >> 2) - (year / 100) + ((year / 100) >> 2) - 1 - DAYS_0000_TO_1970) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillisForYearZero() { [EOL] int year = 0; // Year zero, edge case [EOL] long expectedMillis = ((year * 365L) + (year >> 2) - (year / 100) + ((year / 100) >> 2) - DAYS_0000_TO_1970) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testBaseDateTimeWithNullZone() { [EOL] BaseDateTime baseDateTime = new BaseDateTime((DateTimeZone) null); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(DateTimeZone.getDefault(), baseDateTime.getZone()); [EOL] assertEquals(ISOChronology.getInstance(DateTimeZone.getDefault()), baseDateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithSpecificZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Europe/Paris"); [EOL] BaseDateTime baseDateTime = new BaseDateTime(specificZone); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(specificZone, baseDateTime.getZone()); [EOL] assertEquals(ISOChronology.getInstance(specificZone), baseDateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithNullChronology() { [EOL] BaseDateTime dateTime = new BaseDateTime((Chronology) null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(ISOChronology.getInstance(), dateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithNonNullChronology() { [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] BaseDateTime dateTime = new BaseDateTime(chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testBaseDateTimeWithValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] BaseDateTime dateTime = new BaseDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testBaseDateTimeWithNullZone() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] DateTimeZone zone = null; [EOL] BaseDateTime dateTime = new BaseDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] assertNotNull(dateTime.getZone()); [EOL] }
protected long checkInstant(long instant, Chronology chronology) { [EOL] return instant; [EOL] }
protected void setMillis(long instant) { [EOL] iMillis = checkInstant(instant, iChronology); [EOL] }
public void testGetNameKey() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name [EOL] long instant = 123456789L; // Example value for 'instant' parameter [EOL] String result = instance.getNameKey(instant); [EOL] assertEquals("ExpectedNameKey", result); // Replace 'ExpectedNameKey' with the expected value of iNameKey [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL] return iWallOffset; [EOL] }
public void testIsFixed() { [EOL] Time time = new Time(); [EOL] boolean result = time.isFixed(); [EOL] assertTrue(result); [EOL] }
public void testSetInto_NullChronology() { [EOL] ReadWritablePeriod writablePeriod = new MockWritablePeriod(); [EOL] ReadableDuration duration = new MockDuration(1234L); [EOL] new Time().setInto(writablePeriod, duration, null); [EOL] } [EOL] public void testSetInto_NonNullChronology() { [EOL] ReadWritablePeriod writablePeriod = new MockWritablePeriod(); [EOL] ReadableDuration duration = new MockDuration(1234L); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] new Time().setInto(writablePeriod, duration, chrono); [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(ReadableDuration.class, supportedType); [EOL] }
public void testDateTimeConstantsConstructorIsPrivate() throws NoSuchMethodException { [EOL] Constructor<DateTimeConstants> constructor = DateTimeConstants.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Constructor should throw an exception when invoked."); [EOL] } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) { [EOL] } [EOL] }
public String testGetNameWhenFieldIsNull() { [EOL] Time time = new Time(); [EOL] ReflectionTestUtils.setField(time, "field", null); [EOL] String result = time.getName(); [EOL] assertNull(result); [EOL] }
public String testGetNameWhenFieldHasName() { [EOL] Time time = new Time(); [EOL] Field mockField = mock(Field.class); [EOL] when(mockField.getName()).thenReturn("mockFieldName"); [EOL] ReflectionTestUtils.setField(time, "field", mockField); [EOL] String result = time.getName(); [EOL] assertEquals("mockFieldName", result); [EOL] }
public int testGetWithValidMillis() { [EOL] Field mockField = mock(Field.class); [EOL] when(mockField.get(anyLong())).thenReturn(10); [EOL] when(this.getMillis()).thenReturn(1000L); [EOL] int result = this.get(); [EOL] assertEquals(10, result); [EOL] }
public int testGetWithFieldReturningNegative() { [EOL] Field mockField = mock(Field.class); [EOL] when(mockField.get(anyLong())).thenReturn(-10); [EOL] when(this.getMillis()).thenReturn(1000L); [EOL] int result = this.get(); [EOL] assertEquals(-10, result); [EOL] }
public String getAsString() { [EOL] return Integer.toString(get()); [EOL] }
public String getAsText() { [EOL] return getAsText(null); [EOL] }
public void testGetAsTextWithNullLocale() { [EOL] Time time = new Time(); // Assuming Time is the class where getAsText is defined [EOL] Locale nullLocale = null; [EOL] String result = time.getAsText(nullLocale); [EOL] assertNotNull(result); [EOL] }
public void testGetAsTextWithNonNullLocale() { [EOL] Time time = new Time(); // Assuming Time is the class where getAsText is defined [EOL] Locale nonNullLocale = new Locale("en", "US"); [EOL] String result = time.getAsText(nonNullLocale); [EOL] assertNotNull(result); [EOL] }
public String getAsShortText() { [EOL] return getAsShortText(null); [EOL] }
public void testGetAsShortTextWithNullLocale() { [EOL] YourClass instance = new YourClass(); [EOL] String result = instance.getAsShortText(null); [EOL] assertNotNull(result); [EOL] }
public void testGetAsShortTextWithNonNullLocale() { [EOL] YourClass instance = new YourClass(); [EOL] Locale locale = new Locale("en"); [EOL] String result = instance.getAsShortText(locale); [EOL] assertNotNull(result); [EOL] }
public void testGetDurationField() { [EOL] Time time = new Time(); [EOL] DurationField result = time.getDurationField(); [EOL] assertNotNull("DurationField should not be null", result); [EOL] DurationField expected = time.getField().getDurationField(); [EOL] assertEquals("DurationField returned was not as expected", expected, result); [EOL] }
public void testGetRangeDurationField_Coverage() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] DurationField expectedRangeDurationField = mock(DurationField.class); [EOL] when(mockField.getRangeDurationField()).thenReturn(expectedRangeDurationField); [EOL] Time time = new Time(mockField); [EOL] DurationField actualRangeDurationField = time.getRangeDurationField(); [EOL] assertSame("The range duration field should be the same as the one returned by getField().", expectedRangeDurationField, actualRangeDurationField); [EOL] }
public boolean isLeap() { [EOL] return getField().isLeap(getMillis()); [EOL] }
public int getLeapAmount() { [EOL] return getField().getLeapAmount(getMillis()); [EOL] }
public void testGetLeapDurationField() { [EOL] DurationField field = mock(DurationField.class); [EOL] DateTimeField dateTimeField = mock(DateTimeField.class); [EOL] when(dateTimeField.getLeapDurationField()).thenReturn(field); [EOL] Time time = new Time(dateTimeField); [EOL] DurationField result = time.getLeapDurationField(); [EOL] assertNotNull(result); [EOL] assertEquals(field, result); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL] return getField().getMaximumTextLength(locale); [EOL] }
public void testGetMaximumShortTextLengthWithNullLocale() { [EOL] try { [EOL] int result = getMaximumShortTextLength(null); [EOL] fail("Should have thrown IllegalArgumentException for null locale"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetMaximumShortTextLengthWithNonNullLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] int result = getMaximumShortTextLength(locale); [EOL] int expected = getField().getMaximumShortTextLength(locale); [EOL] assertEquals("The maximum short text length should match the expected value", expected, result); [EOL] }
public void testToString() { [EOL] Property property = new Property(); [EOL] property.setName("TestName"); [EOL] String result = property.toString(); [EOL] assertEquals("Property[TestName]", result); [EOL] }
public void testGetInstance_NewField() { [EOL] DateTimeFieldType testType = DateTimeFieldType.secondOfMinute(); [EOL] DurationField testDurationField = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDateTimeField result = UnsupportedDateTimeField.getInstance(testType, testDurationField); [EOL] assertNotNull(result); [EOL] assertSame(testType, result.getType()); [EOL] assertSame(testDurationField, result.getDurationField()); [EOL] }
public void testGetInstance_CachedField() { [EOL] DateTimeFieldType testType = DateTimeFieldType.secondOfMinute(); [EOL] DurationField testDurationField = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDateTimeField result1 = UnsupportedDateTimeField.getInstance(testType, testDurationField); [EOL] UnsupportedDateTimeField result2 = UnsupportedDateTimeField.getInstance(testType, testDurationField); [EOL] assertNotNull(result2); [EOL] assertSame(result1, result2); [EOL] }
public void testGetInstance_CachedFieldDifferentDuration() { [EOL] DateTimeFieldType testType = DateTimeFieldType.secondOfMinute(); [EOL] DurationField testDurationField1 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] DurationField testDurationField2 = UnsupportedDurationField.getInstance(DurationFieldType.minutes()); [EOL] UnsupportedDateTimeField result1 = UnsupportedDateTimeField.getInstance(testType, testDurationField1); [EOL] UnsupportedDateTimeField result2 = UnsupportedDateTimeField.getInstance(testType, testDurationField2); [EOL] assertNotNull(result2); [EOL] assertNotSame(result1, result2); [EOL] assertSame(testType, result2.getType()); [EOL] assertSame(testDurationField2, result2.getDurationField()); [EOL] }
public void testGetType() { [EOL] DateTimeFieldType expectedType = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeProperty property = new DateTimeProperty(null, expectedType); [EOL] assertEquals(expectedType, property.getType()); [EOL] }
public void testIsSupported() { [EOL] Time time = new Time(); [EOL] boolean result = time.isSupported(); [EOL] assertFalse(result); [EOL] }
public boolean isLenient() { [EOL] return false; [EOL] }
public void testGetDurationField() { [EOL] MyClass myClassInstance = new MyClass(); // Assuming MyClass is the class containing getDurationField [EOL] DurationField expected = // initialize with expected DurationField [EOL] myClassInstance.iDurationField = expected; // Assuming iDurationField is accessible, otherwise use a constructor or a setter method [EOL] DurationField actual = myClassInstance.getDurationField(); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreciseDateTimeField_WithPreciseRange() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] DurationField mockRange = mock(DurationField.class); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] when(mockRange.isPrecise()).thenReturn(true); [EOL] when(mockRange.getUnitMillis()).thenReturn(2L); [EOL] PreciseDateTimeField field = new PreciseDateTimeField(mockType, mockUnit, mockRange); [EOL] assertEquals(2, field.getRange()); [EOL] }
public void testPreciseDateTimeField_WithImpreciseRange() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] DurationField mockRange = mock(DurationField.class); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] when(mockRange.isPrecise()).thenReturn(false); [EOL] try { [EOL] new PreciseDateTimeField(mockType, mockUnit, mockRange); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Range duration field must be precise", e.getMessage()); [EOL] } [EOL] }
public void testPreciseDateTimeField_WithInvalidRange() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] DurationField mockRange = mock(DurationField.class); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] when(mockRange.isPrecise()).thenReturn(true); [EOL] when(mockRange.getUnitMillis()).thenReturn(1L); [EOL] try { [EOL] new PreciseDateTimeField(mockType, mockUnit, mockRange); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The effective range must be at least 2", e.getMessage()); [EOL] } [EOL] }
public void testGetInstance_BaseIsNull() { [EOL] try { [EOL] ZonedChronology.getInstance(null, DateTimeZone.UTC); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Must supply a chronology", ex.getMessage()); [EOL] } [EOL] }
public void testGetInstance_ZoneIsNull() { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] ZonedChronology.getInstance(baseChronology, null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeZone"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("DateTimeZone must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetInstance_ValidArguments() { [EOL] Chronology baseChronology = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] ZonedChronology zonedChronology = ZonedChronology.getInstance(baseChronology, zone); [EOL] assertNotNull("ZonedChronology must not be null", zonedChronology); [EOL] assertEquals("UTC chronology must not be null", baseChronology, zonedChronology.getBase()); [EOL] assertEquals("DateTimeZone must be equal to the one passed", zone, zonedChronology.getZone()); [EOL] }
public void testUseTimeArithmeticWithNullField() { [EOL] boolean result = useTimeArithmetic(null); [EOL] assertFalse(result); [EOL] }
public void testUseTimeArithmeticWithLargeUnitMillis() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.getUnitMillis()).thenReturn(DateTimeConstants.MILLIS_PER_HOUR * 12L); [EOL] boolean result = useTimeArithmetic(field); [EOL] assertFalse(result); [EOL] }
public void testUseTimeArithmeticWithSmallUnitMillis() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.getUnitMillis()).thenReturn(DateTimeConstants.MILLIS_PER_HOUR - 1); [EOL] boolean result = useTimeArithmetic(field); [EOL] assertTrue(result); [EOL] }
private ZonedChronology(Chronology base, DateTimeZone zone) { [EOL] super(base, zone); [EOL] }
public void testConvertFieldWithNullField() { [EOL] DurationField result = convertField(null, new HashMap<>()); [EOL] assertNull(result); [EOL] }
public void testConvertFieldWithUnsupportedField() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.isSupported()).thenReturn(false); [EOL] DurationField result = convertField(field, new HashMap<>()); [EOL] assertSame(field, result); [EOL] }
public void testConvertFieldWithSupportedFieldNotConverted() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.isSupported()).thenReturn(true); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DurationField result = convertField(field, converted); [EOL] assertTrue(result instanceof ZonedDurationField); [EOL] assertTrue(converted.containsValue(result)); [EOL] }
public void testConvertFieldWithSupportedFieldAlreadyConverted() { [EOL] DurationField field = mock(DurationField.class); [EOL] when(field.isSupported()).thenReturn(true); [EOL] ZonedDurationField zonedField = new ZonedDurationField(field, getZone()); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] converted.put(field, zonedField); [EOL] DurationField result = convertField(field, converted); [EOL] assertSame(zonedField, result); [EOL] }
public void testConvertFieldWithNullField() { [EOL] DateTimeField result = convertField(null, new HashMap<>()); [EOL] assertNull(result); [EOL] }
public void testConvertFieldWithUnsupportedField() { [EOL] DateTimeField unsupportedField = mock(DateTimeField.class); [EOL] when(unsupportedField.isSupported()).thenReturn(false); [EOL] DateTimeField result = convertField(unsupportedField, new HashMap<>()); [EOL] assertSame(unsupportedField, result); [EOL] }
public void testConvertFieldWithAlreadyConvertedField() { [EOL] DateTimeField field = mock(DateTimeField.class); [EOL] when(field.isSupported()).thenReturn(true); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DateTimeField expectedField = mock(DateTimeField.class); [EOL] converted.put(field, expectedField); [EOL] DateTimeField result = convertField(field, converted); [EOL] assertSame(expectedField, result); [EOL] }
public void testConvertFieldWithNewField() { [EOL] DateTimeField field = mock(DateTimeField.class); [EOL] when(field.isSupported()).thenReturn(true); [EOL] when(field.getDurationField()).thenReturn(null); [EOL] when(field.getRangeDurationField()).thenReturn(null); [EOL] when(field.getLeapDurationField()).thenReturn(null); [EOL] HashMap<Object, Object> converted = new HashMap<>(); [EOL] DateTimeField result = convertField(field, converted); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ZonedDateTimeField); [EOL] assertSame(result, converted.get(field)); [EOL] }
public void testZonedDurationFieldWithSupportedField() { [EOL] DurationField mockField = Mockito.mock(DurationField.class); [EOL] DateTimeZone mockZone = Mockito.mock(DateTimeZone.class); [EOL] Mockito.when(mockField.isSupported()).thenReturn(true); [EOL] ZonedDurationField zonedDurationField = new ZonedDurationField(mockField, mockZone); [EOL] assertNotNull(zonedDurationField); [EOL] assertEquals(mockField, zonedDurationField.iField); [EOL] assertEquals(mockZone, zonedDurationField.iZone); [EOL] }
public void testZonedDurationFieldWithUnsupportedField() { [EOL] DurationField mockField = Mockito.mock(DurationField.class); [EOL] DateTimeZone mockZone = Mockito.mock(DateTimeZone.class); [EOL] Mockito.when(mockField.isSupported()).thenReturn(false); [EOL] try { [EOL] new ZonedDurationField(mockField, mockZone); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsPrecise_WithTimeFieldTrueAndFieldIsPrecise() { [EOL] boolean iTimeField = true; [EOL] DateTimeField iField = mock(DateTimeField.class); [EOL] when(iField.isPrecise()).thenReturn(true); [EOL] DateTimeZone iZone = mock(DateTimeZone.class); // This will not affect the result as iTimeField is true [EOL] MyClass myClass = new MyClass(iTimeField, iField, iZone); [EOL] boolean result = myClass.isPrecise(); [EOL] assertTrue(result); [EOL] }
public void testIsPrecise_WithTimeFieldFalseAndFieldIsPreciseZoneIsFixed() { [EOL] boolean iTimeField = false; [EOL] DateTimeField iField = mock(DateTimeField.class); [EOL] when(iField.isPrecise()).thenReturn(true); [EOL] DateTimeZone iZone = mock(DateTimeZone.class); [EOL] when(iZone.isFixed()).thenReturn(true); [EOL] MyClass myClass = new MyClass(iTimeField, iField, iZone); [EOL] boolean result = myClass.isPrecise(); [EOL] assertTrue(result); [EOL] }
public void testIsPrecise_WithTimeFieldFalseAndFieldIsPreciseZoneIsNotFixed() { [EOL] boolean iTimeField = false; [EOL] DateTimeField iField = mock(DateTimeField.class); [EOL] when(iField.isPrecise()).thenReturn(true); [EOL] DateTimeZone iZone = mock(DateTimeZone.class); [EOL] when(iZone.isFixed()).thenReturn(false); [EOL] MyClass myClass = new MyClass(iTimeField, iField, iZone); [EOL] boolean result = myClass.isPrecise(); [EOL] assertFalse(result); [EOL] }
public void testIsPrecise_WithTimeFieldFalseAndFieldIsNotPrecise() { [EOL] boolean iTimeField = false; [EOL] DateTimeField iField = mock(DateTimeField.class); [EOL] when(iField.isPrecise()).thenReturn(false); [EOL] DateTimeZone iZone = mock(DateTimeZone.class); // This will not affect the result as iField is not precise [EOL] MyClass myClass = new MyClass(iTimeField, iField, iZone); [EOL] boolean result = myClass.isPrecise(); [EOL] assertFalse(result); [EOL] }
public void testGetUnitMillis() { [EOL] long expectedMillis = 1000; // This should be the expected unit millis for the initialized object [EOL] when(time.iField.getUnitMillis()).thenReturn(expectedMillis); [EOL] long actualMillis = time.getUnitMillis(); [EOL] assertEquals("The unit millis should match the expected value", expectedMillis, actualMillis); [EOL] }
public void testEquals_Reflexive() { [EOL] ZonedDurationField zonedDurationField = new ZonedDurationField(someField, someZone); [EOL] assertTrue(zonedDurationField.equals(zonedDurationField)); [EOL] }
public void testEquals_SameContent() { [EOL] ZonedDurationField zonedDurationField1 = new ZonedDurationField(someField, someZone); [EOL] ZonedDurationField zonedDurationField2 = new ZonedDurationField(someField, someZone); [EOL] assertTrue(zonedDurationField1.equals(zonedDurationField2)); [EOL] }
public void testEquals_DifferentField() { [EOL] ZonedDurationField zonedDurationField1 = new ZonedDurationField(someField, someZone); [EOL] ZonedDurationField zonedDurationField2 = new ZonedDurationField(differentField, someZone); [EOL] assertFalse(zonedDurationField1.equals(zonedDurationField2)); [EOL] }
public void testEquals_DifferentZone() { [EOL] ZonedDurationField zonedDurationField1 = new ZonedDurationField(someField, someZone); [EOL] ZonedDurationField zonedDurationField2 = new ZonedDurationField(someField, differentZone); [EOL] assertFalse(zonedDurationField1.equals(zonedDurationField2)); [EOL] }
public void testEquals_Null() { [EOL] ZonedDurationField zonedDurationField = new ZonedDurationField(someField, someZone); [EOL] assertFalse(zonedDurationField.equals(null)); [EOL] }
public void testEquals_DifferentType() { [EOL] ZonedDurationField zonedDurationField = new ZonedDurationField(someField, someZone); [EOL] Object otherObject = new Object(); [EOL] assertFalse(zonedDurationField.equals(otherObject)); [EOL] }
public void testZonedDateTimeFieldWithSupportedField() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeZone mockZone = Mockito.mock(DateTimeZone.class); [EOL] DurationField mockDurationField = Mockito.mock(DurationField.class); [EOL] DurationField mockRangeDurationField = Mockito.mock(DurationField.class); [EOL] DurationField mockLeapDurationField = Mockito.mock(DurationField.class); [EOL] Mockito.when(mockField.isSupported()).thenReturn(true); [EOL] ZonedDateTimeField zonedDateTimeField = new ZonedDateTimeField(mockField, mockZone, mockDurationField, mockRangeDurationField, mockLeapDurationField); [EOL] assertNotNull(zonedDateTimeField); [EOL] assertEquals(mockField, zonedDateTimeField.iField); [EOL] assertEquals(mockZone, zonedDateTimeField.iZone); [EOL] assertEquals(mockDurationField, zonedDateTimeField.iDurationField); [EOL] assertEquals(mockRangeDurationField, zonedDateTimeField.iRangeDurationField); [EOL] assertEquals(mockLeapDurationField, zonedDateTimeField.iLeapDurationField); [EOL] }
public void testZonedDateTimeFieldWithUnsupportedField() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeZone mockZone = Mockito.mock(DateTimeZone.class); [EOL] DurationField mockDurationField = Mockito.mock(DurationField.class); [EOL] DurationField mockRangeDurationField = Mockito.mock(DurationField.class); [EOL] DurationField mockLeapDurationField = Mockito.mock(DurationField.class); [EOL] Mockito.when(mockField.isSupported()).thenReturn(false); [EOL] try { [EOL] new ZonedDateTimeField(mockField, mockZone, mockDurationField, mockRangeDurationField, mockLeapDurationField); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsTextWithLocale() { [EOL] long instant = 1234567890L; [EOL] Locale locale = Locale.US; [EOL] String expected = "ExpectedText"; [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockZone.convertUTCToLocal(instant)).thenReturn(instant); [EOL] when(mockField.getAsText(instant, locale)).thenReturn(expected); [EOL] Time time = new Time(mockZone, mockField); [EOL] String result = time.getAsText(instant, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAsTextWithDifferentLocale() { [EOL] long instant = 1234567890L; [EOL] Locale locale = Locale.FRANCE; [EOL] String expected = "ExpectedTextFrench"; [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockZone.convertUTCToLocal(instant)).thenReturn(instant); [EOL] when(mockField.getAsText(instant, locale)).thenReturn(expected); [EOL] Time time = new Time(mockZone, mockField); [EOL] String result = time.getAsText(instant, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAsShortTextWithValidInstantAndLocale() { [EOL] long instant = 1234567890L; // A sample UTC timestamp [EOL] Locale locale = Locale.US; // A sample Locale [EOL] DateTimeZoneMock zone = new DateTimeZoneMock("TestZone"); [EOL] DateTimeFieldMock field = new DateTimeFieldMock(); [EOL] Time time = new Time(zone, field); [EOL] String expected = "TestShortText"; [EOL] field.setAsShortText(expected); [EOL] String result = time.getAsShortText(instant, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testGetAsShortTextWithValidInstantAndDifferentLocale() { [EOL] long instant = 1234567890L; // A sample UTC timestamp [EOL] Locale locale = Locale.FRANCE; // A different Locale [EOL] DateTimeZoneMock zone = new DateTimeZoneMock("TestZone"); [EOL] DateTimeFieldMock field = new DateTimeFieldMock(); [EOL] Time time = new Time(zone, field); [EOL] String expected = "TestShortTextFR"; [EOL] field.setAsShortText(expected); [EOL] String result = time.getAsShortText(instant, locale); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithValidInput() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] long instant = 0L; [EOL] String text = "text"; [EOL] Locale locale = Locale.getDefault(); [EOL] long expectedLocalInstant = 12345L; [EOL] long expectedUTCInstant = 67890L; [EOL] when(mockZone.convertUTCToLocal(instant)).thenReturn(expectedLocalInstant); [EOL] when(mockField.set(expectedLocalInstant, text, locale)).thenReturn(expectedLocalInstant); [EOL] when(mockZone.convertLocalToUTC(expectedLocalInstant, false, instant)).thenReturn(expectedUTCInstant); [EOL] MyClass myClass = new MyClass(mockZone, mockField); [EOL] long result = myClass.set(instant, text, locale); [EOL] assertEquals(expectedUTCInstant, result); [EOL] }
public void testSetWithDifferentLocale() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] long instant = 0L; [EOL] String text = "text"; [EOL] Locale locale = new Locale("es", "ES"); [EOL] long expectedLocalInstant = 12345L; [EOL] long expectedUTCInstant = 67890L; [EOL] when(mockZone.convertUTCToLocal(instant)).thenReturn(expectedLocalInstant); [EOL] when(mockField.set(expectedLocalInstant, text, locale)).thenReturn(expectedLocalInstant); [EOL] when(mockZone.convertLocalToUTC(expectedLocalInstant, false, instant)).thenReturn(expectedUTCInstant); [EOL] MyClass myClass = new MyClass(mockZone, mockField); [EOL] long result = myClass.set(instant, text, locale); [EOL] assertEquals(expectedUTCInstant, result); [EOL] }
public void testIsLeap_WithLeapInstant() { [EOL] long leapInstant = /* some leap year instant */; [EOL] boolean result = isLeap(leapInstant); [EOL] assert result : "Expected leap year instant to be true"; [EOL] } [EOL] public void testIsLeap_WithNonLeapInstant() { [EOL] long nonLeapInstant = /* some non-leap year instant */; [EOL] boolean result = isLeap(nonLeapInstant); [EOL] assert !result : "Expected non-leap year instant to be false"; [EOL] }
public void testGetLeapAmount_ForNonLeapInstant() { [EOL] long nonLeapInstant = ...; // provide a non-leap year instant [EOL] int expectedLeapAmount = 0; // assuming getLeapAmount returns 0 for non-leap years [EOL] int actualLeapAmount = getLeapAmount(nonLeapInstant); [EOL] assertEquals(expectedLeapAmount, actualLeapAmount); [EOL] }
public void testGetLeapAmount_ForLeapInstant() { [EOL] long leapInstant = ...; // provide a leap year instant [EOL] int expectedLeapAmount = 1; // assuming getLeapAmount returns 1 for leap years [EOL] int actualLeapAmount = getLeapAmount(leapInstant); [EOL] assertEquals(expectedLeapAmount, actualLeapAmount); [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL] return iField.getMaximumTextLength(locale); [EOL] }
public int getMaximumShortTextLengthTestWithValidLocale() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfWeek(); [EOL] DateTimeField field = fieldType.getField(DateTimeFormat.forPattern("EEE").getChronology()); [EOL] Time time = new Time(field); [EOL] Locale locale = Locale.ENGLISH; // Assuming Locale.ENGLISH is a valid locale for this test [EOL] int result = time.getMaximumShortTextLength(locale); [EOL] assertEquals("Expected maximum short text length for the given locale", expectedValue, result); [EOL] }
public void testEquals_SameObject() { [EOL] ZonedDateTimeField zdtField = new ZonedDateTimeField(); [EOL] boolean result = zdtField.equals(zdtField); [EOL] assertTrue(result); [EOL] }
public void testEquals_DifferentClass() { [EOL] ZonedDateTimeField zdtField = new ZonedDateTimeField(); [EOL] Object other = new Object(); [EOL] boolean result = zdtField.equals(other); [EOL] assertFalse(result); [EOL] }
public void testEquals_EqualZonedDateTimeField() { [EOL] ZonedDateTimeField zdtField1 = new ZonedDateTimeField(); [EOL] ZonedDateTimeField zdtField2 = new ZonedDateTimeField(); [EOL] zdtField1.setField(someField); [EOL] zdtField1.setZone(someZone); [EOL] zdtField1.setDurationField(someDurationField); [EOL] zdtField1.setRangeDurationField(someRangeDurationField); [EOL] zdtField2.setField(someField); [EOL] zdtField2.setZone(someZone); [EOL] zdtField2.setDurationField(someDurationField); [EOL] zdtField2.setRangeDurationField(someRangeDurationField); [EOL] boolean result = zdtField1.equals(zdtField2); [EOL] assertTrue(result); [EOL] }
public void testEquals_NotEqualZonedDateTimeField() { [EOL] ZonedDateTimeField zdtField1 = new ZonedDateTimeField(); [EOL] ZonedDateTimeField zdtField2 = new ZonedDateTimeField(); [EOL] zdtField1.setField(someField); [EOL] zdtField1.setZone(someZone); [EOL] zdtField1.setDurationField(someDurationField); [EOL] zdtField1.setRangeDurationField(someRangeDurationField); [EOL] zdtField2.setField(otherField); [EOL] zdtField2.setZone(otherZone); [EOL] zdtField2.setDurationField(otherDurationField); [EOL] zdtField2.setRangeDurationField(otherRangeDurationField); [EOL] boolean result = zdtField1.equals(zdtField2); [EOL] assertFalse(result); [EOL] }
public void testHashCode_WhenFieldsAreEqual() { [EOL] Time time1 = new Time(someField, someZone); [EOL] Time time2 = new Time(someField, someZone); [EOL] assertEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testHashCode_WhenFieldsAreNotEqual() { [EOL] Time time1 = new Time(someField, someZone); [EOL] Time time2 = new Time(differentField, differentZone); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testGJDayOfWeekDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new GJDayOfWeekDateTimeField(null, new MockDurationField()); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGJDayOfWeekDateTimeFieldWithNonNullChronology() { [EOL] BasicChronology mockChronology = new MockBasicChronology(); [EOL] DurationField days = new MockDurationField(); [EOL] GJDayOfWeekDateTimeField field = new GJDayOfWeekDateTimeField(mockChronology, days); [EOL] assertNotNull("The GJDayOfWeekDateTimeField should not be null", field); [EOL] assertEquals("The chronology should be the one that was passed in the constructor", mockChronology, field.getChronology()); [EOL] }
public int getDayOfWeekTest() { [EOL] long instant = /* some valid instant representing a specific day of the week */; [EOL] int expectedDayOfWeek = /* the expected day of the week for the given instant */; [EOL] int actualDayOfWeek = /* your object instance */.get(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testConvertTextWithValidDayEnglishLocale() { [EOL] int result = convertText("Monday", Locale.ENGLISH); [EOL] assertEquals(1, result); [EOL] }
public void testConvertTextWithValidDayFrenchLocale() { [EOL] int result = convertText("lundi", Locale.FRENCH); [EOL] assertEquals(1, result); [EOL] }
public void testConvertTextWithInvalidDay() { [EOL] try { [EOL] convertText("Noday", Locale.ENGLISH); [EOL] fail("Should have thrown an exception for invalid day text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIllegalFieldValueExceptionWithNonNullFieldType() { [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); [EOL] Integer value = 10; [EOL] Integer lowerBound = 5; [EOL] Integer upperBound = 15; [EOL] IllegalFieldValueException ex = new IllegalFieldValueException(fieldType, value, lowerBound, upperBound); [EOL] assertNotNull(ex.getMessage()); [EOL] assertNull(ex.getDateTimeFieldType()); [EOL] assertEquals(fieldType, ex.getDurationFieldType()); [EOL] assertEquals("minutes", ex.getFieldName()); [EOL] assertEquals(value, ex.getNumberValue()); [EOL] assertNull(ex.getStringValue()); [EOL] assertEquals(lowerBound, ex.getLowerBound()); [EOL] assertEquals(upperBound, ex.getUpperBound()); [EOL] }
public void testIllegalFieldValueExceptionWithNullFieldType() { [EOL] DurationFieldType fieldType = null; [EOL] Integer value = 10; [EOL] Integer lowerBound = 5; [EOL] Integer upperBound = 15; [EOL] try { [EOL] new IllegalFieldValueException(fieldType, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalArgumentException because fieldType is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIllegalFieldValueExceptionWithStringValue() { [EOL] String testValue = "testValue"; [EOL] DurationFieldType testFieldType = DurationFieldType.centuries(); [EOL] IllegalFieldValueException ex = new IllegalFieldValueException(testFieldType, testValue); [EOL] assertNull(ex.getNumberValue()); [EOL] assertNull(ex.getLowerBound()); [EOL] assertNull(ex.getUpperBound()); [EOL] assertEquals(testFieldType, ex.getDurationFieldType()); [EOL] assertEquals(testValue, ex.getStringValue()); [EOL] assertEquals(testFieldType.getName(), ex.getFieldName()); [EOL] assertEquals("Value " + testValue + " for " + testFieldType.getName() + " is not supported", ex.getMessage()); [EOL] }
public void testIllegalFieldValueExceptionWithFieldNameAndStringValue() { [EOL] String fieldName = "hour"; [EOL] String value = "25"; [EOL] IllegalFieldValueException ex = new IllegalFieldValueException(fieldName, value); [EOL] assertNull(ex.getDateTimeFieldType()); [EOL] assertNull(ex.getDurationFieldType()); [EOL] assertEquals(fieldName, ex.getFieldName()); [EOL] assertEquals(value, ex.getStringValue()); [EOL] assertNull(ex.getNumberValue()); [EOL] assertNull(ex.getLowerBound()); [EOL] assertNull(ex.getUpperBound()); [EOL] assertEquals("Value " + value + " for " + fieldName + " is not supported", ex.getMessage()); [EOL] }
public void testLocalTimeWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] LocalTime localTime = new LocalTime(instant, null); [EOL] assertNotNull(localTime); [EOL] assertEquals(DateTimeZone.UTC, localTime.getChronology().getZone()); [EOL] }
public void testLocalTimeWithSpecificChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] LocalTime localTime = new LocalTime(instant, chronology); [EOL] assertNotNull(localTime); [EOL] assertEquals(chronology.withUTC(), localTime.getChronology()); [EOL] assertEquals(chronology.millisOfDay().get(instant), localTime.getLocalMillis()); [EOL] }
public void testLocalTimeConstructor_ValidValues() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 500; [EOL] LocalTime localTime = new LocalTime(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(hourOfDay, localTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, localTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, localTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, localTime.getMillisOfSecond()); [EOL] }
public void testLocalTimeConstructorWithValidValues() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] LocalTime localTime = new LocalTime(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertEquals(hourOfDay, localTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, localTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, localTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, localTime.getMillisOfSecond()); [EOL] assertEquals(chronology, localTime.getChronology()); [EOL] }
public void testLocalTimeConstructorWithNullChronology() { [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] int millisOfSecond = 123; [EOL] Chronology nullChronology = null; [EOL] LocalTime localTime = new LocalTime(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, nullChronology); [EOL] assertNotNull(localTime.getChronology()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), localTime.getChronology()); [EOL] }
public void testGetValueWithHourOfDay() { [EOL] int index = HOUR_OF_DAY; [EOL] int expectedValue = // expected value for HOUR_OF_DAY [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithMinuteOfHour() { [EOL] int index = MINUTE_OF_HOUR; [EOL] int expectedValue = // expected value for MINUTE_OF_HOUR [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithSecondOfMinute() { [EOL] int index = SECOND_OF_MINUTE; [EOL] int expectedValue = // expected value for SECOND_OF_MINUTE [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithMillisOfSecond() { [EOL] int index = MILLIS_OF_SECOND; [EOL] int expectedValue = // expected value for MILLIS_OF_SECOND [EOL] int actualValue = instance.getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueWithInvalidIndex() { [EOL] int index = INVALID_INDEX; // INVALID_INDEX should be a constant that is not a valid case [EOL] try { [EOL] instance.getValue(index); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Invalid index: " + index, e.getMessage()); [EOL] } [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedDurationType() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(DurationFieldType.years()); [EOL] when(isSupported(DurationFieldType.years())).thenReturn(false); [EOL] boolean result = isSupported(mockType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedDurationAndRangeType() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(DurationFieldType.days()); [EOL] when(mockType.getRangeDurationType()).thenReturn(DurationFieldType.weeks()); [EOL] when(isSupported(DurationFieldType.days())).thenReturn(true); [EOL] when(isSupported(DurationFieldType.weeks())).thenReturn(true); [EOL] boolean result = isSupported(mockType); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithSupportedDurationAndUnsupportedRangeType() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(DurationFieldType.days()); [EOL] when(mockType.getRangeDurationType()).thenReturn(DurationFieldType.months()); [EOL] when(isSupported(DurationFieldType.days())).thenReturn(true); [EOL] when(isSupported(DurationFieldType.months())).thenReturn(false); [EOL] boolean result = isSupported(mockType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedDurationAndRangeTypeIsDays() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] when(mockType.getDurationType()).thenReturn(DurationFieldType.hours()); [EOL] when(mockType.getRangeDurationType()).thenReturn(DurationFieldType.days()); [EOL] when(isSupported(DurationFieldType.hours())).thenReturn(true); [EOL] boolean result = isSupported(mockType); [EOL] assertTrue(result); [EOL] }
public void testGetLocalMillis() { [EOL] Time time = new Time(); // Assuming there is a constructor available [EOL] long expected = 123456789L; // Example value [EOL] time.iLocalMillis = expected; // Assuming iLocalMillis can be accessed or set somehow [EOL] long actual = time.getLocalMillis(); [EOL] assertEquals(expected, actual); [EOL] }
public void testEquals_SameReference() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] assertTrue(time.equals(time)); [EOL] }
public void testEquals_DifferentClass() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] Object obj = new Object(); [EOL] assertFalse(time.equals(obj)); [EOL] }
public void testEquals_EqualLocalTime() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(10, 0, 0); [EOL] assertTrue(time1.equals(time2)); [EOL] }
public void testEquals_NonEqualLocalTime_DifferentChronology() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(10, 0, 0, GregorianChronology.getInstance()); [EOL] assertFalse(time1.equals(time2)); [EOL] }
public void testEquals_NonEqualLocalTime_DifferentMillis() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(11, 0, 0); [EOL] assertFalse(time1.equals(time2)); [EOL] }
public void testCompareTo_SameInstance() { [EOL] LocalTime time1 = new LocalTime(10, 0); [EOL] int result = time1.compareTo(time1); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LocalTimeEqualChronology() { [EOL] LocalTime time1 = new LocalTime(10, 0); [EOL] LocalTime time2 = new LocalTime(10, 0); [EOL] int result = time1.compareTo(time2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LocalTimeDifferentChronology() { [EOL] LocalTime time1 = new LocalTime(10, 0, DateTimeZone.UTC); [EOL] LocalTime time2 = new LocalTime(10, 0, DateTimeZone.forOffsetHours(1)); [EOL] int result = time1.compareTo(time2); [EOL] assertFalse(result == 0); [EOL] }
public void testCompareTo_LocalTimeBefore() { [EOL] LocalTime time1 = new LocalTime(9, 0); [EOL] LocalTime time2 = new LocalTime(10, 0); [EOL] int result = time1.compareTo(time2); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_LocalTimeAfter() { [EOL] LocalTime time1 = new LocalTime(11, 0); [EOL] LocalTime time2 = new LocalTime(10, 0); [EOL] int result = time1.compareTo(time2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareTo_NonLocalTime() { [EOL] LocalTime time1 = new LocalTime(10, 0); [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] int result = time1.compareTo(mockPartial); [EOL] assertNotNull(result); [EOL] }
public void testWithLocalMillis_SameMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] LocalTime localTime = new LocalTime(currentMillis, ISOChronology.getInstance()); [EOL] LocalTime result = localTime.withLocalMillis(currentMillis); [EOL] assertSame("Expected same instance of LocalTime as the millis are the same", localTime, result); [EOL] }
public void testWithLocalMillis_DifferentMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] LocalTime localTime = new LocalTime(currentMillis, ISOChronology.getInstance()); [EOL] long newMillis = currentMillis + 1000; // Assuming newMillis is different from currentMillis [EOL] LocalTime result = localTime.withLocalMillis(newMillis); [EOL] assertNotSame("Expected different instance of LocalTime as the millis are different", localTime, result); [EOL] assertEquals("Expected the chronology to be the same", localTime.getChronology(), result.getChronology()); [EOL] }
public void testWithField_NullFieldType() { [EOL] LocalTime time = new LocalTime(); [EOL] try { [EOL] time.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_UnsupportedFieldType() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.centuryOfEra(); [EOL] try { [EOL] time.withField(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_SupportedFieldType() { [EOL] LocalTime time = new LocalTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] int newValue = 10; [EOL] LocalTime updatedTime = time.withField(fieldType, newValue); [EOL] assertEquals(newValue, updatedTime.getHourOfDay()); [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] LocalTime time = new LocalTime(10, 0); // Any arbitrary time [EOL] LocalTime result = time.withPeriodAdded(null, 1); [EOL] assertEquals(time, result); [EOL] } [EOL] public void testWithPeriodAdded_ZeroScalar() { [EOL] LocalTime time = new LocalTime(10, 0); // Any arbitrary time [EOL] ReadablePeriod period = new Period(hours: 2); // Any non-null period [EOL] LocalTime result = time.withPeriodAdded(period, 0); [EOL] assertEquals(time, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodPositiveScalar() { [EOL] LocalTime time = new LocalTime(10, 0); // Any arbitrary time [EOL] ReadablePeriod period = new Period(hours: 2); // Any non-null period [EOL] LocalTime result = time.withPeriodAdded(period, 1); [EOL] assertNotEquals(time, result); [EOL] assertEquals(new LocalTime(12, 0), result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodNegativeScalar() { [EOL] LocalTime time = new LocalTime(10, 0); // Any arbitrary time [EOL] ReadablePeriod period = new Period(hours: 2); // Any non-null period [EOL] LocalTime result = time.withPeriodAdded(period, -1); [EOL] assertNotEquals(time, result); [EOL] assertEquals(new LocalTime(8, 0), result); [EOL] }
public void testPlus_withNullPeriod() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plus(null); [EOL] assertEquals(time, result); [EOL] }
public void testPlus_withValidPeriod() { [EOL] LocalTime time = LocalTime.of(10, 0); [EOL] Period period = Period.ofHours(2); [EOL] LocalTime result = time.plus(period); [EOL] assertEquals(LocalTime.of(12, 0), result); [EOL] }
public void testPlusHours_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.plusHours(0); [EOL] assertSame("Expected same instance when adding zero hours", time, result); [EOL] }
public void testPlusHours_Positive() { [EOL] LocalTime time = LocalTime.MIDNIGHT; [EOL] int hoursToAdd = 5; [EOL] LocalTime expected = time.plusHours(hoursToAdd); [EOL] LocalTime result = time.plusHours(hoursToAdd); [EOL] assertEquals("Expected time plus 5 hours", expected, result); [EOL] }
public void testPlusHours_Negative() { [EOL] LocalTime time = LocalTime.NOON; [EOL] int hoursToSubtract = -3; [EOL] LocalTime expected = time.plusHours(hoursToSubtract); [EOL] LocalTime result = time.plusHours(hoursToSubtract); [EOL] assertEquals("Expected time minus 3 hours", expected, result); [EOL] }
public void testPropertyWithNullFieldType() { [EOL] try { [EOL] someObject.property(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testPropertyWithUnsupportedFieldType() { [EOL] DateTimeFieldType unsupportedFieldType = // initialize with an unsupported DateTimeFieldType [EOL] try { [EOL] someObject.property(unsupportedFieldType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '" + unsupportedFieldType + "' is not supported")); [EOL] } [EOL] }
public void testPropertyWithSupportedFieldType() { [EOL] DateTimeFieldType supportedFieldType = // initialize with a supported DateTimeFieldType [EOL] Property result = someObject.property(supportedFieldType); [EOL] assertNotNull(result); [EOL] }
public int getHourOfDay() { [EOL] return getChronology().hourOfDay().get(getLocalMillis()); [EOL] }
public void testGetMinuteOfHour() { [EOL] Time time = new Time(chronology, localMillis); [EOL] int expectedMinute = chronology.minuteOfHour().get(localMillis); [EOL] int actualMinute = time.getMinuteOfHour(); [EOL] assertEquals(expectedMinute, actualMinute); [EOL] }
public int getSecondOfMinute() { [EOL] return getChronology().secondOfMinute().get(getLocalMillis()); [EOL] }
public void testGetMillisOfSecond() { [EOL] DateTime testDateTime = new DateTime(2021, 5, 20, 10, 15, 30, 123); // Example date with milliseconds [EOL] int millis = testDateTime.getMillisOfSecond(); [EOL] assertEquals(123, millis); [EOL] }
public void testWithHourOfDay_ValidHour() { [EOL] LocalTime time = new LocalTime(12, 0); // Assuming LocalTime is initialized with hour and minute [EOL] LocalTime updatedTime = time.withHourOfDay(6); [EOL] assertEquals(6, updatedTime.getHourOfDay()); [EOL] }
public void testWithHourOfDay_MinHour() { [EOL] LocalTime time = new LocalTime(12, 0); [EOL] LocalTime updatedTime = time.withHourOfDay(0); [EOL] assertEquals(0, updatedTime.getHourOfDay()); [EOL] }
public void testWithHourOfDay_MaxHour() { [EOL] LocalTime time = new LocalTime(12, 0); [EOL] LocalTime updatedTime = time.withHourOfDay(23); [EOL] assertEquals(23, updatedTime.getHourOfDay()); [EOL] }
public void testWithHourOfDay_InvalidHour() { [EOL] LocalTime time = new LocalTime(12, 0); [EOL] try { [EOL] time.withHourOfDay(24); [EOL] fail("Should have thrown an exception for invalid hour"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMinuteOfHour_ValidMinute() { [EOL] LocalTime time = new LocalTime(12, 0); // Assuming 12:00 as the initial time [EOL] int validMinute = 30; [EOL] LocalTime updatedTime = time.withMinuteOfHour(validMinute); [EOL] assertEquals(30, updatedTime.getMinuteOfHour()); [EOL] }
public void testWithMinuteOfHour_MinuteTooLow() { [EOL] LocalTime time = new LocalTime(12, 0); // Assuming 12:00 as the initial time [EOL] int invalidMinute = -1; [EOL] try { [EOL] time.withMinuteOfHour(invalidMinute); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMinuteOfHour_MinuteTooHigh() { [EOL] LocalTime time = new LocalTime(12, 0); // Assuming 12:00 as the initial time [EOL] int invalidMinute = 60; [EOL] try { [EOL] time.withMinuteOfHour(invalidMinute); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithSecondOfMinute_ValidSecond() { [EOL] LocalTime time = new LocalTime(12, 0, 0); // Assuming 12:00:00 as the initial time [EOL] int validSecond = 30; [EOL] LocalTime updatedTime = time.withSecondOfMinute(validSecond); [EOL] assertEquals(30, updatedTime.getSecondOfMinute()); [EOL] }
public void testWithSecondOfMinute_BoundarySecondLower() { [EOL] LocalTime time = new LocalTime(12, 0, 0); // Assuming 12:00:00 as the initial time [EOL] int boundarySecondLower = 0; [EOL] LocalTime updatedTime = time.withSecondOfMinute(boundarySecondLower); [EOL] assertEquals(0, updatedTime.getSecondOfMinute()); [EOL] }
public void testWithSecondOfMinute_BoundarySecondUpper() { [EOL] LocalTime time = new LocalTime(12, 0, 0); // Assuming 12:00:00 as the initial time [EOL] int boundarySecondUpper = 59; [EOL] LocalTime updatedTime = time.withSecondOfMinute(boundarySecondUpper); [EOL] assertEquals(59, updatedTime.getSecondOfMinute()); [EOL] }
public void testWithSecondOfMinute_InvalidSecondLower() { [EOL] LocalTime time = new LocalTime(12, 0, 0); // Assuming 12:00:00 as the initial time [EOL] int invalidSecondLower = -1; [EOL] try { [EOL] time.withSecondOfMinute(invalidSecondLower); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithSecondOfMinute_InvalidSecondUpper() { [EOL] LocalTime time = new LocalTime(12, 0, 0); // Assuming 12:00:00 as the initial time [EOL] int invalidSecondUpper = 60; [EOL] try { [EOL] time.withSecondOfMinute(invalidSecondUpper); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMillisOfSecond_ValidMillis() { [EOL] LocalTime time = new LocalTime(12, 0, 0, 0); [EOL] int validMillis = 500; [EOL] LocalTime updatedTime = time.withMillisOfSecond(validMillis); [EOL] assertEquals(validMillis, updatedTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfSecond_MinMillis() { [EOL] LocalTime time = new LocalTime(12, 0, 0, 0); [EOL] int minMillis = 0; [EOL] LocalTime updatedTime = time.withMillisOfSecond(minMillis); [EOL] assertEquals(minMillis, updatedTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfSecond_MaxMillis() { [EOL] LocalTime time = new LocalTime(12, 0, 0, 0); [EOL] int maxMillis = 999; [EOL] LocalTime updatedTime = time.withMillisOfSecond(maxMillis); [EOL] assertEquals(maxMillis, updatedTime.getMillisOfSecond()); [EOL] }
public void testWithMillisOfDay_ValidMillis() { [EOL] int validMillis = 12345; // Assuming this is a valid millisecond value within the day [EOL] LocalTime originalTime = new LocalTime(); [EOL] LocalTime updatedTime = originalTime.withMillisOfDay(validMillis); [EOL] assertNotEquals(originalTime, updatedTime); [EOL] assertEquals(validMillis, updatedTime.getMillisOfDay()); [EOL] }
public void testWithMillisOfDay_MinValue() { [EOL] int minMillis = 0; [EOL] LocalTime originalTime = new LocalTime(); [EOL] LocalTime updatedTime = originalTime.withMillisOfDay(minMillis); [EOL] assertNotEquals(originalTime, updatedTime); [EOL] assertEquals(minMillis, updatedTime.getMillisOfDay()); [EOL] }
public void testWithMillisOfDay_MaxValue() { [EOL] int maxMillis = 86399999; // Assuming this is the maximum millisecond value for a day [EOL] LocalTime originalTime = new LocalTime(); [EOL] LocalTime updatedTime = originalTime.withMillisOfDay(maxMillis); [EOL] assertNotEquals(originalTime, updatedTime); [EOL] assertEquals(maxMillis, updatedTime.getMillisOfDay()); [EOL] }
public void testMillisOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.millisOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().millisOfDay(), property.getField()); [EOL] assertEquals(dateTime.getMillis(), property.getMillis()); [EOL] }
public void testToString() { [EOL] Time time = new Time(); [EOL] String expected = ISODateTimeFormat.time().print(time); [EOL] String actual = time.toString(); [EOL] assertEquals(expected, actual); [EOL] }
protected Chronology getChronology() { [EOL] return iInstant.getChronology(); [EOL] }
public void testAddCopy_PositiveValue() { [EOL] LocalTime initialTime = new LocalTime(10, 0); // Assuming LocalTime(hour, minute) constructor [EOL] int valueToAdd = 2; // Assuming we're adding hours for simplicity [EOL] LocalTime result = initialTime.addCopy(valueToAdd); [EOL] assertEquals(new LocalTime(12, 0), result); [EOL] }
public void testAddCopy_NegativeValue() { [EOL] LocalTime initialTime = new LocalTime(10, 0); [EOL] int valueToSubtract = -2; [EOL] LocalTime result = initialTime.addCopy(valueToSubtract); [EOL] assertEquals(new LocalTime(8, 0), result); [EOL] }
public void testAddCopy_ZeroValue() { [EOL] LocalTime initialTime = new LocalTime(10, 0); [EOL] int valueToAdd = 0; [EOL] LocalTime result = initialTime.addCopy(valueToAdd); [EOL] assertEquals(initialTime, result); [EOL] }
public void testSkipDateTimeFieldWithNullChronology() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] try { [EOL] new SkipDateTimeField(null, field); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSkipDateTimeFieldWithNullField() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] try { [EOL] new SkipDateTimeField(chronology, null); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSkipDateTimeFieldWithValidInput() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeField field = new MockDateTimeField(); [EOL] SkipDateTimeField skipDateTimeField = new SkipDateTimeField(chronology, field); [EOL] assertNotNull("SkipDateTimeField should not be null", skipDateTimeField); [EOL] }
public void testHalfdays() { [EOL] DurationFieldType halfdaysType = Time.halfdays(); [EOL] assertNotNull("Halfdays type should not be null", halfdaysType); [EOL] assertEquals("Halfdays type should be equal to HALFDAYS_TYPE", Time.HALFDAYS_TYPE, halfdaysType); [EOL] }
public void testYears() { [EOL] DurationFieldType result = ClassName.years(); [EOL] assertNotNull(result); [EOL] assertSame(ClassName.YEARS_TYPE, result); [EOL] }
public void testCenturies() { [EOL] DurationFieldType type = Time.centuries(); [EOL] assertNotNull(type); [EOL] assertEquals("centuries", type.getName()); [EOL] }
public void testHashCode() { [EOL] Time time = new Time(1); [EOL] int expectedHashCode = 1 << 1; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testHashCodeWithDifferentOrdinal() { [EOL] Time time = new Time(2); [EOL] int expectedHashCode = 1 << 2; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testGetFieldForEras() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = ERAS; // Assuming ERAS is a constant representing the ordinal for eras [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.eras(), field); [EOL] } [EOL] public void testGetFieldForCenturies() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = CENTURIES; // Assuming CENTURIES is a constant representing the ordinal for centuries [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.centuries(), field); [EOL] } [EOL] public void testGetFieldForWeekyears() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = WEEKYEARS; // Assuming WEEKYEARS is a constant representing the ordinal for weekyears [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.weekyears(), field); [EOL] } [EOL] public void testGetFieldForYears() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = YEARS; // Assuming YEARS is a constant representing the ordinal for years [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.years(), field); [EOL] } [EOL] public void testGetFieldForMonths() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = MONTHS; // Assuming MONTHS is a constant representing the ordinal for months [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.months(), field); [EOL] } [EOL] public void testGetFieldForWeeks() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = WEEKS; // Assuming WEEKS is a constant representing the ordinal for weeks [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.weeks(), field); [EOL] } [EOL] public void testGetFieldForDays() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = DAYS; // Assuming DAYS is a constant representing the ordinal for days [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.days(), field); [EOL] } [EOL] public void testGetFieldForHalfdays() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = HALFDAYS; // Assuming HALFDAYS is a constant representing the ordinal for halfdays [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.halfdays(), field); [EOL] } [EOL] public void testGetFieldForHours() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = HOURS; // Assuming HOURS is a constant representing the ordinal for hours [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.hours(), field); [EOL] } [EOL] public void testGetFieldForMinutes() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = MINUTES; // Assuming MINUTES is a constant representing the ordinal for minutes [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.minutes(), field); [EOL] } [EOL] public void testGetFieldForSeconds() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = SECONDS; // Assuming SECONDS is a constant representing the ordinal for seconds [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.seconds(), field); [EOL] } [EOL] public void testGetFieldForMillis() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = MILLIS; // Assuming MILLIS is a constant representing the ordinal for millis [EOL] DurationField field = getField(chronology); [EOL] assertEquals(chronology.millis(), field); [EOL] } [EOL] public void testGetFieldForInvalidOrdinal() { [EOL] Chronology chronology = createMockChronology(); [EOL] int iOrdinal = INVALID_ORDINAL; // Assuming INVALID_ORDINAL is a constant representing an invalid ordinal [EOL] try { [EOL] getField(chronology); [EOL] fail("Expected an InternalError to be thrown"); [EOL] } catch (InternalError e) { [EOL] } [EOL] }
public void testReadResolveForEras() { [EOL] MyClass instance = new MyClass(MyClass.ERAS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.ERAS_TYPE, result); [EOL] }
public void testReadResolveForCenturies() { [EOL] MyClass instance = new MyClass(MyClass.CENTURIES); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.CENTURIES_TYPE, result); [EOL] }
public void testReadResolveForWeekyears() { [EOL] MyClass instance = new MyClass(MyClass.WEEKYEARS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.WEEKYEARS_TYPE, result); [EOL] }
public void testReadResolveForYears() { [EOL] MyClass instance = new MyClass(MyClass.YEARS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.YEARS_TYPE, result); [EOL] }
public void testReadResolveForMonths() { [EOL] MyClass instance = new MyClass(MyClass.MONTHS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MONTHS_TYPE, result); [EOL] }
public void testReadResolveForWeeks() { [EOL] MyClass instance = new MyClass(MyClass.WEEKS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.WEEKS_TYPE, result); [EOL] }
public void testReadResolveForDays() { [EOL] MyClass instance = new MyClass(MyClass.DAYS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.DAYS_TYPE, result); [EOL] }
public void testReadResolveForHalfdays() { [EOL] MyClass instance = new MyClass(MyClass.HALFDAYS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.HALFDAYS_TYPE, result); [EOL] }
public void testReadResolveForHours() { [EOL] MyClass instance = new MyClass(MyClass.HOURS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.HOURS_TYPE, result); [EOL] }
public void testReadResolveForMinutes() { [EOL] MyClass instance = new MyClass(MyClass.MINUTES); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MINUTES_TYPE, result); [EOL] }
public void testReadResolveForSeconds() { [EOL] MyClass instance = new MyClass(MyClass.SECONDS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.SECONDS_TYPE, result); [EOL] }
public void testReadResolveForMillis() { [EOL] MyClass instance = new MyClass(MyClass.MILLIS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MILLIS_TYPE, result); [EOL] }
public void testReadResolveForDefault() { [EOL] MyClass instance = new MyClass(-1); // Assuming -1 is not a valid iOrdinal [EOL] Object result = instance.readResolve(); [EOL] assertSame(instance, result); [EOL] }
public void testGetInstance_NewType() { [EOL] DurationFieldType newType = DurationFieldType.seconds(); [EOL] UnsupportedDurationField result = UnsupportedDurationField.getInstance(newType); [EOL] assertNotNull(result); [EOL] assertSame(newType, result.getType()); [EOL] }
public void testGetInstance_ExistingType() { [EOL] DurationFieldType existingType = DurationFieldType.seconds(); [EOL] UnsupportedDurationField firstCallResult = UnsupportedDurationField.getInstance(existingType); [EOL] UnsupportedDurationField secondCallResult = UnsupportedDurationField.getInstance(existingType); [EOL] assertNotNull(secondCallResult); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
It seems there is a misunderstanding. The provided input text is a constructor for a private class `UnsupportedDurationField` which takes a `DurationFieldType` as an argument. Since the constructor is private, it cannot be directly tested from outside the class. Typically, private methods and constructors are tested indirectly through public methods that use them. However, since no public methods or additional context is provided, I cannot generate meaningful unit test cases. [EOL] If you can provide a public method that uses this private constructor or more context about the class `UnsupportedDurationField`, I could then generate test cases that ensure this constructor is being tested indirectly. Otherwise, without additional information, it's not possible to create unit test cases for a private constructor.
public int compareTo(DurationField durationField) { [EOL] return 0; [EOL] }
public void testEquals_Reflexive() { [EOL] UnsupportedDurationField field = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertTrue(field.equals(field)); [EOL] }
public void testEquals_Null() { [EOL] UnsupportedDurationField field = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertFalse(field.equals(null)); [EOL] }
public void testEquals_OtherClass() { [EOL] UnsupportedDurationField field = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertFalse(field.equals(new Object())); [EOL] }
public void testEquals_DifferentUnsupportedDurationField() { [EOL] UnsupportedDurationField field1 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDurationField field2 = UnsupportedDurationField.getInstance(DurationFieldType.minutes()); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testEquals_SameName() { [EOL] UnsupportedDurationField field1 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDurationField field2 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_NameNull() { [EOL] UnsupportedDurationField field1 = new UnsupportedDurationField(null); [EOL] UnsupportedDurationField field2 = new UnsupportedDurationField(null); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_OneNameNull() { [EOL] UnsupportedDurationField field1 = new UnsupportedDurationField(null); [EOL] UnsupportedDurationField field2 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] MutableDateTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Chronology must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutableDateTime dateTime = MutableDateTime.now(chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testParseWithNullString() { [EOL] try { [EOL] MutableDateTime result = MutableDateTime.parse(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseWithEmptyString() { [EOL] try { [EOL] MutableDateTime result = MutableDateTime.parse(""); [EOL] fail("Should have thrown IllegalArgumentException for empty input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseWithValidString() { [EOL] String validDateTimeString = "2023-04-01T12:00:00.000Z"; [EOL] MutableDateTime result = MutableDateTime.parse(validDateTimeString); [EOL] assertNotNull("Resulting MutableDateTime should not be null", result); [EOL] assertEquals("The year should be 2023", 2023, result.getYear()); [EOL] assertEquals("The month should be April", 4, result.getMonthOfYear()); [EOL] assertEquals("The day should be 1", 1, result.getDayOfMonth()); [EOL] assertEquals("The hour should be 12", 12, result.getHourOfDay()); [EOL] assertEquals("The minute should be 0", 0, result.getMinuteOfHour()); [EOL] assertEquals("The second should be 0", 0, result.getSecondOfMinute()); [EOL] assertEquals("The millis should be 0", 0, result.getMillisOfSecond()); [EOL] }
public void testParseWithValidFormatterAndString() { [EOL] String validDateString = "2023-04-01T00:00:00.000Z"; [EOL] DateTimeFormatter formatter = ISODateTimeFormat.dateTime(); [EOL] MutableDateTime expected = new MutableDateTime(2023, 4, 1, 0, 0, 0, 0); [EOL] MutableDateTime result = Time.parse(validDateString, formatter); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithInvalidFormatter() { [EOL] String validDateString = "2023-04-01T00:00:00.000Z"; [EOL] DateTimeFormatter formatter = null; [EOL] try { [EOL] Time.parse(validDateString, formatter); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidDateString = "invalid-date-time"; [EOL] DateTimeFormatter formatter = ISODateTimeFormat.dateTime(); [EOL] try { [EOL] Time.parse(invalidDateString, formatter); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMutableDateTimeConstructor() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] assertNotNull(dateTime); [EOL] }
public void testMutableDateTimeWithValidValues() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 3, 14, 15, 9, 26, 123, chronology); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(14, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(9, dateTime.getMinuteOfHour()); [EOL] assertEquals(26, dateTime.getSecondOfMinute()); [EOL] assertEquals(123, dateTime.getMillisOfSecond()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] } [EOL] public void testMutableDateTimeWithNullChronology() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 3, 14, 15, 9, 26, 123, null); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(14, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(9, dateTime.getMinuteOfHour()); [EOL] assertEquals(26, dateTime.getSecondOfMinute()); [EOL] assertEquals(123, dateTime.getMillisOfSecond()); [EOL] assertNotNull(dateTime.getChronology()); [EOL] }
public void testGetRoundingField() { [EOL] DateTimeField roundingField = new DateTimeField(); [EOL] DateTime dateTime = new DateTime(roundingField); [EOL] assertEquals("Rounding field should match", roundingField, dateTime.getRoundingField()); [EOL] }
public int getRoundingMode() { [EOL] return iRoundingMode; [EOL] }
public void testSetRoundingWithNullField() { [EOL] MutableDateTime mutableDateTime = new MutableDateTime(); [EOL] mutableDateTime.setRounding(null); [EOL] assertNull(mutableDateTime.getRoundingField()); [EOL] }
public void testSetRoundingWithNonNullField() { [EOL] MutableDateTime mutableDateTime = new MutableDateTime(); [EOL] DateTimeField field = ISOChronology.getInstance().hourOfDay(); [EOL] mutableDateTime.setRounding(field); [EOL] assertEquals(field, mutableDateTime.getRoundingField()); [EOL] }
public void testSetRoundingWithNullFieldAndValidMode() { [EOL] DateTimeField field = null; [EOL] int mode = DateTimeFormatter.ROUND_FLOOR; // Assuming ROUND_FLOOR is a valid mode within the valid range [EOL] try { [EOL] setRounding(field, mode); [EOL] assertEquals("Rounding mode should be set to ROUND_NONE when field is null", DateTimeFormatter.ROUND_NONE, iRoundingMode); [EOL] assertNull("Rounding field should be null when mode is ROUND_NONE", iRoundingField); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("No exception should be thrown for null field with valid mode"); [EOL] } [EOL] }
public void testSetRoundingWithNonNullFieldAndInvalidMode() { [EOL] DateTimeField field = new MockDateTimeField(); // Assuming MockDateTimeField is a valid implementation of DateTimeField [EOL] int mode = Integer.MIN_VALUE; // An invalid mode, outside the valid range [EOL] try { [EOL] setRounding(field, mode); [EOL] fail("IllegalArgumentException expected for invalid rounding mode"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetRoundingWithNonNullFieldAndValidMode() { [EOL] DateTimeField field = new MockDateTimeField(); // Assuming MockDateTimeField is a valid implementation of DateTimeField [EOL] int mode = DateTimeFormatter.ROUND_CEILING; // Assuming ROUND_CEILING is a valid mode within the valid range [EOL] try { [EOL] setRounding(field, mode); [EOL] assertEquals("Rounding mode should be set correctly", mode, iRoundingMode); [EOL] assertEquals("Rounding field should be set correctly", field, iRoundingField); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("No exception should be thrown for non-null field with valid mode"); [EOL] } [EOL] }
public void testSetRoundingWithNonNullFieldAndRoundNoneMode() { [EOL] DateTimeField field = new MockDateTimeField(); // Assuming MockDateTimeField is a valid implementation of DateTimeField [EOL] int mode = DateTimeFormatter.ROUND_NONE; [EOL] try { [EOL] setRounding(field, mode); [EOL] assertEquals("Rounding mode should be set to ROUND_NONE", DateTimeFormatter.ROUND_NONE, iRoundingMode); [EOL] assertNull("Rounding field should be null when mode is ROUND_NONE", iRoundingField); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("No exception should be thrown for non-null field with ROUND_NONE mode"); [EOL] } [EOL] }
public void testSetMillisRoundNone() { [EOL] setTimeRoundingMode(ROUND_NONE); [EOL] long expected = SOME_INSTANT; [EOL] setMillis(expected); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisRoundFloor() { [EOL] setTimeRoundingMode(ROUND_FLOOR); [EOL] long input = SOME_INSTANT; [EOL] long expected = SOME_ROUNDED_INSTANT_FLOOR; [EOL] setMillis(input); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisRoundCeiling() { [EOL] setTimeRoundingMode(ROUND_CEILING); [EOL] long input = SOME_INSTANT; [EOL] long expected = SOME_ROUNDED_INSTANT_CEILING; [EOL] setMillis(input); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisRoundHalfFloor() { [EOL] setTimeRoundingMode(ROUND_HALF_FLOOR); [EOL] long input = SOME_INSTANT; [EOL] long expected = SOME_ROUNDED_INSTANT_HALF_FLOOR; [EOL] setMillis(input); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisRoundHalfCeiling() { [EOL] setTimeRoundingMode(ROUND_HALF_CEILING); [EOL] long input = SOME_INSTANT; [EOL] long expected = SOME_ROUNDED_INSTANT_HALF_CEILING; [EOL] setMillis(input); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisRoundHalfEven() { [EOL] setTimeRoundingMode(ROUND_HALF_EVEN); [EOL] long input = SOME_INSTANT; [EOL] long expected = SOME_ROUNDED_INSTANT_HALF_EVEN; [EOL] setMillis(input); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void add_withNonNullDurationAndPositiveScalar() { [EOL] MockReadableDuration duration = new MockReadableDuration(1000); // Assuming MockReadableDuration is a mock that returns 1000 from getMillis() [EOL] int scalar = 2; [EOL] add(duration, scalar); [EOL] assertEquals(2000, this.getMillis()); // Assuming getMillis() returns the internal state [EOL] }
public void add_withNonNullDurationAndNegativeScalar() { [EOL] MockReadableDuration duration = new MockReadableDuration(1000); // Assuming MockReadableDuration is a mock that returns 1000 from getMillis() [EOL] int scalar = -3; [EOL] add(duration, scalar); [EOL] assertEquals(-3000, this.getMillis()); // Assuming getMillis() returns the internal state [EOL] }
public void add_withNonNullDurationAndZeroScalar() { [EOL] MockReadableDuration duration = new MockReadableDuration(1000); // Assuming MockReadableDuration is a mock that returns 1000 from getMillis() [EOL] int scalar = 0; [EOL] add(duration, scalar); [EOL] assertEquals(0, this.getMillis()); // Assuming getMillis() returns the internal state [EOL] }
public void add_withNullDuration() { [EOL] MockReadableDuration duration = null; [EOL] int scalar = 2; [EOL] add(duration, scalar); [EOL] assertEquals(0, this.getMillis()); // Assuming getMillis() returns the internal state and initial state is 0 [EOL] }
public void setYearTestValidYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validYear = 2023; [EOL] dateTime.setYear(validYear); [EOL] assertEquals(validYear, dateTime.getYear()); [EOL] }
public void setYearTestNegativeYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int negativeYear = -1; [EOL] dateTime.setYear(negativeYear); [EOL] assertEquals(negativeYear, dateTime.getYear()); [EOL] }
public void setYearTestFutureYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int futureYear = 3000; [EOL] dateTime.setYear(futureYear); [EOL] assertEquals(futureYear, dateTime.getYear()); [EOL] }
public void addWeekyears_WithZeroWeekyears_NoChange() { [EOL] Time time = new Time(); // Assuming Time is the class where addWeekyears is defined [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() returns the current state [EOL] time.addWeekyears(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addWeekyears_WithPositiveWeekyears_ChangesMillis() { [EOL] Time time = new Time(); [EOL] int weekyearsToAdd = 1; // Can be any positive number [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().weekyears().add(initialMillis, weekyearsToAdd); // Assuming this is the expected behavior [EOL] time.addWeekyears(weekyearsToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void addWeekyears_WithNegativeWeekyears_ChangesMillis() { [EOL] Time time = new Time(); [EOL] int weekyearsToSubtract = -1; // Can be any negative number [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().weekyears().add(initialMillis, weekyearsToSubtract); // Assuming this is the expected behavior [EOL] time.addWeekyears(weekyearsToSubtract); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void testAddMonths_ZeroMonths() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addMonths(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void testAddMonths_PositiveMonths() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addMonths(5); [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void testAddMonths_NegativeMonths() { [EOL] Time time = new Time(); [EOL] long initialMillis = time.getMillis(); [EOL] time.addMonths(-5); [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void testAddWeeks_ZeroWeeks() { [EOL] DateTime initialTime = new DateTime(); [EOL] initialTime.addWeeks(0); [EOL] assertEquals(initialTime, new DateTime()); [EOL] }
public void testAddWeeks_PositiveWeeks() { [EOL] DateTime initialTime = new DateTime(); [EOL] long initialMillis = initialTime.getMillis(); [EOL] int weeksToAdd = 3; // for example [EOL] initialTime.addWeeks(weeksToAdd); [EOL] assertEquals(initialTime.getMillis(), initialTime.getChronology().weeks().add(initialMillis, weeksToAdd)); [EOL] }
public void testAddWeeks_NegativeWeeks() { [EOL] DateTime initialTime = new DateTime(); [EOL] long initialMillis = initialTime.getMillis(); [EOL] int weeksToAdd = -2; // for example [EOL] initialTime.addWeeks(weeksToAdd); [EOL] assertEquals(initialTime.getMillis(), initialTime.getChronology().weeks().add(initialMillis, weeksToAdd)); [EOL] }
public void testSetHourOfDay_ValidHour() { [EOL] int validHour = 10; // A valid hour within the 24-hour range [EOL] instance.setHourOfDay(validHour); [EOL] assertEquals(validHour, instance.getChronology().hourOfDay().get(instance.getMillis())); [EOL] }
public void testSetHourOfDay_InvalidHour_Low() { [EOL] try { [EOL] int invalidHourLow = -1; // An invalid hour below the 24-hour range [EOL] instance.setHourOfDay(invalidHourLow); [EOL] fail("Should have thrown an IllegalArgumentException for hour too low"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetHourOfDay_InvalidHour_High() { [EOL] try { [EOL] int invalidHourHigh = 24; // An invalid hour above the 24-hour range [EOL] instance.setHourOfDay(invalidHourHigh); [EOL] fail("Should have thrown an IllegalArgumentException for hour too high"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetTime_ValidTime() { [EOL] Time time = new Time(); // Replace with actual constructor [EOL] int expectedHour = 10; [EOL] int expectedMinute = 30; [EOL] int expectedSecond = 45; [EOL] int expectedMillis = 500; [EOL] time.setTime(expectedHour, expectedMinute, expectedSecond, expectedMillis); [EOL] long actualMillis = time.getMillis(); [EOL] int actualHour = getHourFromMillis(actualMillis); [EOL] int actualMinute = getMinuteFromMillis(actualMillis); [EOL] int actualSecond = getSecondFromMillis(actualMillis); [EOL] int actualMillisOfSecond = getMillisFromMillis(actualMillis); [EOL] assertEquals(expectedHour, actualHour); [EOL] assertEquals(expectedMinute, actualMinute); [EOL] assertEquals(expectedSecond, actualSecond); [EOL] assertEquals(expectedMillis, actualMillisOfSecond); [EOL] }
public void testYearProperty() { [EOL] Time time = new Time(); [EOL] Property yearProperty = time.year(); [EOL] assertNotNull(yearProperty); [EOL] assertEquals(time.getChronology().year(), yearProperty.getField()); [EOL] }
public void testDayOfWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfWeek(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfWeek(), property.getField()); [EOL] assertEquals(dateTime, property.getReadableInstant()); [EOL] }
public void testMillisOfSecond() { [EOL] DateTime testDateTime = new DateTime(); [EOL] Property property = testDateTime.millisOfSecond(); [EOL] assertNotNull(property); [EOL] assertEquals(testDateTime.getChronology().millisOfSecond(), property.getField()); [EOL] assertEquals(testDateTime.getMillisOfSecond(), property.get()); [EOL] }
public void testSet_ValidValue() { [EOL] MutableDateTime mutableDateTime = new MutableDateTime(); [EOL] int validValue = 10; [EOL] MutableDateTime result = mutableDateTime.set(validValue); [EOL] assertEquals("Expected the result to be the same as the input instance", mutableDateTime, result); [EOL] assertEquals("Expected the internal millis to be set to the value by the field", validValue, result.getMillis()); [EOL] }
public void testSet_InvalidValue() { [EOL] MutableDateTime mutableDateTime = new MutableDateTime(); [EOL] int invalidValue = -1; [EOL] try { [EOL] mutableDateTime.set(invalidValue); [EOL] fail("Should have thrown an IllegalArgumentException for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testHours_Zero() { [EOL] Hours result = Time.hours(0); [EOL] assertSame(Hours.ZERO, result); [EOL] }
public void testHours_One() { [EOL] Hours result = Time.hours(1); [EOL] assertSame(Hours.ONE, result); [EOL] }
public void testHours_Two() { [EOL] Hours result = Time.hours(2); [EOL] assertSame(Hours.TWO, result); [EOL] }
public void testHours_Three() { [EOL] Hours result = Time.hours(3); [EOL] assertSame(Hours.THREE, result); [EOL] }
public void testHours_Four() { [EOL] Hours result = Time.hours(4); [EOL] assertSame(Hours.FOUR, result); [EOL] }
public void testHours_Five() { [EOL] Hours result = Time.hours(5); [EOL] assertSame(Hours.FIVE, result); [EOL] }
public void testHours_Six() { [EOL] Hours result = Time.hours(6); [EOL] assertSame(Hours.SIX, result); [EOL] }
public void testHours_Seven() { [EOL] Hours result = Time.hours(7); [EOL] assertSame(Hours.SEVEN, result); [EOL] }
public void testHours_Eight() { [EOL] Hours result = Time.hours(8); [EOL] assertSame(Hours.EIGHT, result); [EOL] }
public void testHours_MaxValue() { [EOL] Hours result = Time.hours(Integer.MAX_VALUE); [EOL] assertSame(Hours.MAX_VALUE, result); [EOL] }
public void testHours_MinValue() { [EOL] Hours result = Time.hours(Integer.MIN_VALUE); [EOL] assertSame(Hours.MIN_VALUE, result); [EOL] }
public void testHours_Default() { [EOL] int anyOtherValue = 9; // This can be any value not covered by the switch cases [EOL] Hours result = Time.hours(anyOtherValue); [EOL] assertNotNull(result); [EOL] assertEquals(anyOtherValue, result.getValue()); [EOL] }
public void testParseHoursWithNullInput() { [EOL] Hours result = Time.parseHours(null); [EOL] assertEquals(Hours.ZERO, result); [EOL] }
public void testParseHoursWithValidInput() { [EOL] Hours result = Time.parseHours("PT2H"); [EOL] assertEquals(Hours.hours(2), result); [EOL] }
public void testParseHoursWithInvalidInput() { [EOL] try { [EOL] Time.parseHours("InvalidInput"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPlus_WithNullHours() { [EOL] Hours initialHours = new Hours(5); [EOL] Hours result = initialHours.plus(null); [EOL] assertEquals("Result should be the same as initial hours when adding null", 5, result.getValue()); [EOL] }
public void testPlus_WithNonNullHours() { [EOL] Hours initialHours = new Hours(5); [EOL] Hours additionalHours = new Hours(3); [EOL] Hours result = initialHours.plus(additionalHours); [EOL] assertEquals("Result should be the sum of initial and additional hours", 8, result.getValue()); [EOL] }
public void testNegated_Zero() { [EOL] Hours hours = Hours.hours(0); [EOL] Hours result = hours.negated(); [EOL] assertEquals("Negating zero should give zero", 0, result.getValue()); [EOL] }
public void testNegated_Positive() { [EOL] Hours hours = Hours.hours(5); [EOL] Hours result = hours.negated(); [EOL] assertEquals("Negating a positive value should give negative", -5, result.getValue()); [EOL] }
public void testNegated_Negative() { [EOL] Hours hours = Hours.hours(-3); [EOL] Hours result = hours.negated(); [EOL] assertEquals("Negating a negative value should give positive", 3, result.getValue()); [EOL] }
public void testNegated_MaxValue() { [EOL] Hours hours = Hours.hours(Integer.MAX_VALUE); [EOL] try { [EOL] hours.negated(); [EOL] fail("Negating MAX_VALUE should throw an ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testNegated_MinValue() { [EOL] Hours hours = Hours.hours(Integer.MIN_VALUE); [EOL] try { [EOL] hours.negated(); [EOL] fail("Negating MIN_VALUE should throw an ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testIsLessThanWithNullOther() { [EOL] Hours hours = new Hours(1); [EOL] boolean result = hours.isLessThan(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLessThanWithNegativeValue() { [EOL] Hours hours = new Hours(-1); [EOL] boolean result = hours.isLessThan(null); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsLessThanWithPositiveValueLessThanOther() { [EOL] Hours hours = new Hours(1); [EOL] Hours other = new Hours(2); [EOL] boolean result = hours.isLessThan(other); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsLessThanWithPositiveValueNotLessThanOther() { [EOL] Hours hours = new Hours(2); [EOL] Hours other = new Hours(1); [EOL] boolean result = hours.isLessThan(other); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsLessThanWithEqualValues() { [EOL] Hours hours = new Hours(1); [EOL] Hours other = new Hours(1); [EOL] boolean result = hours.isLessThan(other); [EOL] assertFalse(result); [EOL] }
public void testConverterSetWithNullConverters() { [EOL] Converter[] converters = null; [EOL] try { [EOL] new ConverterSet(converters); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testConverterSetWithEmptyConverters() { [EOL] Converter[] converters = new Converter[0]; [EOL] ConverterSet set = new ConverterSet(converters); [EOL] assertNotNull(set); [EOL] }
public void testConverterSetWithNonEmptyConverters() { [EOL] Converter[] converters = new Converter[1]; [EOL] converters[0] = new SomeConverterImplementation(); [EOL] ConverterSet set = new ConverterSet(converters); [EOL] assertNotNull(set); [EOL] assertEquals(1, set.iConverters.length); [EOL] }
public void testSelectWithNullType() { [EOL] Entry[] entries = new Entry[2]; // Small array for testing [EOL] entries[0] = new Entry(String.class, new Converter()); // Fill one entry [EOL] iSelectEntries = entries; // Set the field to our test array [EOL] Converter result = select(null); [EOL] assertNotNull(result); [EOL] verify(selectSlow(this, null)); [EOL] }
public void testSelectWithTypeFound() { [EOL] Entry[] entries = new Entry[2]; [EOL] Converter expectedConverter = new Converter(); [EOL] entries[0] = new Entry(String.class, expectedConverter); [EOL] iSelectEntries = entries; [EOL] Converter result = select(String.class); [EOL] assertSame(expectedConverter, result); [EOL] }
public void testSelectWithTypeNotFound() { [EOL] Entry[] entries = new Entry[2]; [EOL] entries[0] = new Entry(String.class, new Converter()); [EOL] iSelectEntries = entries; [EOL] Converter result = select(Integer.class); [EOL] assertNotNull(result); [EOL] verify(selectSlow(this, Integer.class)); [EOL] }
public void testSelectWithFullArrayAndExpansion() { [EOL] Entry[] entries = new Entry[2]; [EOL] entries[0] = new Entry(String.class, new Converter()); [EOL] entries[1] = new Entry(Integer.class, new Converter()); [EOL] iSelectEntries = entries; [EOL] Converter result = select(Double.class); [EOL] assertNotNull(result); [EOL] assertTrue(iSelectEntries.length > entries.length); [EOL] }
public void testSize() { [EOL] TimeConverter converter = new TimeConverter(new Converter[0]); [EOL] assertEquals(0, converter.size()); [EOL] }
public void testSizeWithNonEmptyConverters() { [EOL] TimeConverter converter = new TimeConverter(new Converter[]{new Converter(), new Converter()}); [EOL] assertEquals(2, converter.size()); [EOL] }
public void testRemove_IndexOutOfBounds() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new ConverterA(), new ConverterB()}); [EOL] try { [EOL] set.remove(2, new Converter[1]); [EOL] fail("Expected IndexOutOfBoundsException."); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemove_ValidIndexWithRemovedNotNull() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new ConverterA(), new ConverterB()}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet newSet = set.remove(0, removed); [EOL] assertNotNull("Removed converter should not be null", removed[0]); [EOL] assertEquals("Removed converter should be instance of ConverterA", ConverterA.class, removed[0].getClass()); [EOL] assertEquals("New set should have one less converter", 1, newSet.size()); [EOL] }
public void testRemove_ValidIndexWithRemovedNull() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new ConverterA(), new ConverterB()}); [EOL] ConverterSet newSet = set.remove(0, null); [EOL] assertEquals("New set should have one less converter", 1, newSet.size()); [EOL] }
private static Converter selectSlow(ConverterSet set, Class<?> type) { [EOL] Converter[] converters = set.iConverters; [EOL] int length = converters.length; [EOL] Converter converter; [EOL] for (int i = length; --i >= 0; ) { [EOL] converter = converters[i]; [EOL] Class<?> supportedType = converter.getSupportedType(); [EOL] if (supportedType == type) { [EOL] return converter; [EOL] } [EOL] if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) { [EOL] set = set.remove(i, null); [EOL] converters = set.iConverters; [EOL] length = converters.length; [EOL] } [EOL] } [EOL] if (type == null || length == 0) { [EOL] return null; [EOL] } [EOL] if (length == 1) { [EOL] return converters[0]; [EOL] } [EOL] for (int i = length; --i >= 0; ) { [EOL] converter = converters[i]; [EOL] Class<?> supportedType = converter.getSupportedType(); [EOL] for (int j = length; --j >= 0; ) { [EOL] if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) { [EOL] set = set.remove(j, null); [EOL] converters = set.iConverters; [EOL] length = converters.length; [EOL] i = length - 1; [EOL] } [EOL] } [EOL] } [EOL] if (length == 1) { [EOL] return converters[0]; [EOL] } [EOL] StringBuilder msg = new StringBuilder(); [EOL] msg.append("Unable to find best converter for type \""); [EOL] msg.append(type.getName()); [EOL] msg.append("\" from remaining set: "); [EOL] for (int i = 0; i < length; i++) { [EOL] converter = converters[i]; [EOL] Class<?> supportedType = converter.getSupportedType(); [EOL] msg.append(converter.getClass().getName()); [EOL] msg.append('['); [EOL] msg.append(supportedType == null ? null : supportedType.getName()); [EOL] msg.append("], "); [EOL] } [EOL] throw new IllegalStateException(msg.toString()); [EOL] }
public void testEntryConstructorWithValidArguments() { [EOL] Class<?> expectedType = String.class; [EOL] Converter expectedConverter = new SomeConverterImplementation(); [EOL] Entry entry = new Entry(expectedType, expectedConverter); [EOL] assertEquals(expectedType, entry.iType); [EOL] assertEquals(expectedConverter, entry.iConverter); [EOL] }
public void testToFormatterWithPrinterAndParser() { [EOL] Object formatter = createMockedFormatterThatIsBothPrinterAndParser(); [EOL] setFormatter(formatter); [EOL] DateTimeFormatter result = toFormatter(); [EOL] assertNotNull(result); [EOL] assertTrue(result.getPrinter() instanceof DateTimePrinter); [EOL] assertTrue(result.getParser() instanceof DateTimeParser); [EOL] }
public void testToFormatterWithPrinterOnly() { [EOL] Object formatter = createMockedFormatterThatIsOnlyPrinter(); [EOL] setFormatter(formatter); [EOL] DateTimeFormatter result = toFormatter(); [EOL] assertNotNull(result); [EOL] assertTrue(result.getPrinter() instanceof DateTimePrinter); [EOL] assertNull(result.getParser()); [EOL] }
public void testToFormatterWithParserOnly() { [EOL] Object formatter = createMockedFormatterThatIsOnlyParser(); [EOL] setFormatter(formatter); [EOL] DateTimeFormatter result = toFormatter(); [EOL] assertNotNull(result); [EOL] assertNull(result.getPrinter()); [EOL] assertTrue(result.getParser() instanceof DateTimeParser); [EOL] }
public void testToFormatterWithNeitherPrinterNorParser() { [EOL] Object formatter = createMockedFormatterThatIsNeitherPrinterNorParser(); [EOL] setFormatter(formatter); [EOL] try { [EOL] toFormatter(); [EOL] fail("UnsupportedOperationException expected"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testAppendDateTimeFormatter_NullFormatter() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.append(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No formatter supplied", e.getMessage()); [EOL] } [EOL] }
public void testAppendDateTimeFormatter_NonNullFormatter() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd"); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.append(formatter); [EOL] assertNotNull(returnedBuilder); [EOL] assertFalse(returnedBuilder.toFormatter().toString().isEmpty()); [EOL] }
public void testAppendWithNullParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithValidParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeParser parser = new DateTimeParser() { [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] return position; [EOL] } [EOL] }; [EOL] DateTimeFormatterBuilder returnedBuilder = builder.append(parser); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppend0_WithNonNullPrinterAndParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeFormatterBuilder result = builder.append0(printer, parser); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] assertEquals(2, builder.iElementPairs.size()); [EOL] assertSame(printer, builder.iElementPairs.get(0)); [EOL] assertSame(parser, builder.iElementPairs.get(1)); [EOL] }
public void testAppend0_WithNullPrinterAndParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.append0(null, null); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] assertEquals(2, builder.iElementPairs.size()); [EOL] assertNull(builder.iElementPairs.get(0)); [EOL] assertNull(builder.iElementPairs.get(1)); [EOL] }
public void testAppendSignedDecimal_WithNullFieldType_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendSignedDecimal(null, 1, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSignedDecimal_WithMaxDigitsLessThanMinDigits_AdjustsMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] DateTimeFormatterBuilder result = builder.appendSignedDecimal(fieldType, 3, 2); [EOL] assertNotNull(result); [EOL] }
public void testAppendSignedDecimal_WithInvalidMinOrMaxDigits_ThrowsIllegalArgumentException() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendSignedDecimal(DateTimeFieldType.secondOfMinute(), -1, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSignedDecimal_WithMinDigitsLessThanOrEqualToOne_AppendsUnpaddedNumber() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] DateTimeFormatterBuilder result = builder.appendSignedDecimal(fieldType, 1, 2); [EOL] assertNotNull(result); [EOL] }
public void testAppendSignedDecimal_WithMinDigitsGreaterThanOne_AppendsPaddedNumber() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.secondOfMinute(); [EOL] DateTimeFormatterBuilder result = builder.appendSignedDecimal(fieldType, 2, 3); [EOL] assertNotNull(result); [EOL] }
public void testAppendShortTextWithNullFieldType() { [EOL] try { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendShortText(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field type must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendShortTextWithValidFieldType() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfWeek(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendShortText(fieldType); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendSecondOfMinute_MinDigitsLessThanTwo() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendSecondOfMinute(1); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 2"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSecondOfMinute_MinDigitsTwo() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendSecondOfMinute(2); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendSecondOfMinute_MinDigitsMoreThanTwo() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendSecondOfMinute(3); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendSecondOfDay_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendSecondOfDay(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits less than 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSecondOfDay_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendSecondOfDay(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendSecondOfDay_MaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendSecondOfDay(5); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendHourOfHalfday_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendHourOfHalfday(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits < 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendHourOfHalfday_MinDigitsOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendHourOfHalfday(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendHourOfHalfday_MinDigitsTwo() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendHourOfHalfday(2); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendClockhourOfHalfday_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendClockhourOfHalfday(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits less than 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendClockhourOfHalfday_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendClockhourOfHalfday(1); [EOL] }
public void testAppendDayOfWeek_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendDayOfWeek(0); [EOL] fail("Should have thrown IllegalArgumentException for minDigits less than 1"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDayOfWeek_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendDayOfWeek(1); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertSame("Returned builder should be the same as the original builder", builder, returnedBuilder); [EOL] }
public void testAppendTwoDigitYearWithPivot() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendTwoDigitYear(2000); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendTwoDigitYearWithPivotAndFalse() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendTwoDigitYear(2000, false); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendCenturyOfEra_MinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendCenturyOfEra(2, 4); [EOL] assertNotNull(result); [EOL] }
public void testAppendCenturyOfEra_SameMinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendCenturyOfEra(3, 3); [EOL] assertNotNull(result); [EOL] }
public void testAppendCenturyOfEra_InvalidMinMaxDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendCenturyOfEra(4, 2); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendHalfdayOfDayText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendHalfdayOfDayText(); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendMonthOfYearShortText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendMonthOfYearShortText(); [EOL] assertNotNull(result); [EOL] }
public void testAppendEraText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendEraText(); [EOL] assertNotNull(result); [EOL] }
public void testAppendTimeZoneOffset_WithValidParameters() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetPrintText = "GMT"; [EOL] String zeroOffsetParseText = "UTC"; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = 4; [EOL] DateTimeFormatterBuilder result = builder.appendTimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] assertNotNull(result); [EOL] }
public void testAppendTimeZoneOffset_WithMinFieldsGreaterThanMaxFields() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetPrintText = "GMT"; [EOL] String zeroOffsetParseText = "UTC"; [EOL] boolean showSeparators = true; [EOL] int minFields = 5; [EOL] int maxFields = 4; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendTimeZoneOffset_WithNullPrintText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetPrintText = null; [EOL] String zeroOffsetParseText = "UTC"; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = 4; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAppendTimeZoneOffset_WithNullParseText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetPrintText = "GMT"; [EOL] String zeroOffsetParseText = null; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = 4; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAppendTimeZoneOffset_WithNegativeMinFields() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetPrintText = "GMT"; [EOL] String zeroOffsetParseText = "UTC"; [EOL] boolean showSeparators = true; [EOL] int minFields = -1; [EOL] int maxFields = 4; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendTimeZoneOffset_WithNegativeMaxFields() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] String zeroOffsetPrintText = "GMT"; [EOL] String zeroOffsetParseText = "UTC"; [EOL] boolean showSeparators = true; [EOL] int minFields = 2; [EOL] int maxFields = -1; [EOL] try { [EOL] builder.appendTimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsParserWithDateTimeParser() { [EOL] Object f = new DateTimeParser() {}; // Assuming DateTimeParser is an interface or class we can implement/extend [EOL] boolean result = isParser(f); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsParserWithCompositeAndIsParserTrue() { [EOL] Object f = new Composite() { // Assuming Composite is a class we can extend [EOL] public boolean isParser() { [EOL] return true; [EOL] } [EOL] }; [EOL] boolean result = isParser(f); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsParserWithCompositeAndIsParserFalse() { [EOL] Object f = new Composite() { // Assuming Composite is a class we can extend [EOL] public boolean isParser() { [EOL] return false; [EOL] } [EOL] }; [EOL] boolean result = isParser(f); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsParserWithNonParserObject() { [EOL] Object f = new Object(); [EOL] boolean result = isParser(f); [EOL] assertFalse(result); [EOL] }
public void printTo_ShouldAppendValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] int iValue = 123; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("123", buf.toString()); [EOL] }
public void testPrintToWithValidInput() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertFalse(buf.toString().isEmpty()); [EOL] assertNotEquals('\ufffd', buf.charAt(0)); [EOL] }
public void testPrintToWithException() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = null; // Assuming this will cause a NullPointerException [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals('\ufffd', buf.charAt(0)); [EOL] }
public void testPrintToWithValidInput() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.ENGLISH; [EOL] printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL] assertFalse(out.toString().isEmpty()); [EOL] } [EOL] public void testPrintToWithNullChronology() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.ENGLISH; [EOL] try { [EOL] printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testPrintToWithIOException() throws IOException { [EOL] Writer out = new Writer() { [EOL] @Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL] throw new IOException("Fake IOException"); [EOL] } [EOL] @Override [EOL] public void flush() throws IOException { [EOL] throw new IOException("Fake IOException"); [EOL] } [EOL] @Override [EOL] public void close() throws IOException { [EOL] throw new IOException("Fake IOException"); [EOL] } [EOL] }; [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.ENGLISH; [EOL] try { [EOL] printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL] fail("Should have thrown IOException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testPrintTo_SupportedFieldType() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenReturn(123); [EOL] printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] assertEquals("0123", mockWriter.toString()); [EOL] }
public void testPrintTo_UnsupportedFieldType() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(false); [EOL] printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] assertEquals("Unknown", mockWriter.toString()); [EOL] }
public void testPrintTo_IOExceptionOnWrite() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenReturn(123); [EOL] doThrow(new IOException()).when(mockWriter).write(anyString(), anyInt(), anyInt()); [EOL] assertThrows(IOException.class, () -> { [EOL] printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] }); [EOL] }
public void testPrintTo_RuntimeExceptionOnGet() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.isSupported(iFieldType)).thenReturn(true); [EOL] when(mockPartial.get(iFieldType)).thenThrow(new RuntimeException()); [EOL] printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] assertEquals("Unknown", mockWriter.toString()); [EOL] }
public void testPrintToWithValidInputs() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write(anyString()); [EOL] }
public void testPrintToWithRuntimeException() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] doThrow(new RuntimeException()).when(mockWriter).write(anyString()); [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write('\ufffd'); [EOL] }
public void testPrintToWithNullDisplayZone() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = null; [EOL] Locale locale = null; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithZeroOffsetAndSpecialText() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iZeroOffsetPrintText = "GMT"; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("GMT", buf.toString()); [EOL] }
public void testPrintToWithPositiveOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR; // 1 hour [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01:00", buf.toString()); [EOL] }
public void testPrintToWithNegativeOffset() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = -DateTimeConstants.MILLIS_PER_HOUR; // -1 hour [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("-01:00", buf.toString()); [EOL] }
public void testPrintToWithMaxFields() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; // 1 hour 1 minute [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 1; [EOL] iMinFields = 0; [EOL] iShowSeparators = false; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01", buf.toString()); [EOL] }
public void testPrintToWithMinFields() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; // 1 hour 1 minute [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 3; [EOL] iMinFields = 2; [EOL] iShowSeparators = false; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+0101", buf.toString()); [EOL] }
public void testPrintToWithShowSeparators() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = 0L; [EOL] Chronology chrono = null; [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE + DateTimeConstants.MILLIS_PER_SECOND; // 1 hour 1 minute 1 second [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = null; [EOL] iMaxFields = 4; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertEquals("+01:01:01.000", buf.toString()); [EOL] }
public void testPrintToWithNullDisplayZone() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = null; [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verifyNoInteractions(mockWriter); [EOL] }
public void testPrintToWithZeroOffsetAndNonNullText() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.UTC; [EOL] Locale locale = Locale.getDefault(); [EOL] iZeroOffsetPrintText = "Z"; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write("Z"); [EOL] }
public void testPrintToWithPositiveOffset() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR; // 1 hour positive offset [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetHours(1); [EOL] Locale locale = Locale.getDefault(); [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write('+'); [EOL] verify(mockWriter).write(':'); [EOL] verify(mockWriter, times(2)).write(anyString()); [EOL] }
public void testPrintToWithNegativeOffset() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = -DateTimeConstants.MILLIS_PER_HOUR; // 1 hour negative offset [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetHours(-1); [EOL] Locale locale = Locale.getDefault(); [EOL] iMaxFields = 2; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write('-'); [EOL] verify(mockWriter).write(':'); [EOL] verify(mockWriter, times(2)).write(anyString()); [EOL] }
public void testPrintToWithMaxFieldsOne() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_HOUR + DateTimeConstants.MILLIS_PER_MINUTE; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = Locale.getDefault(); [EOL] iMaxFields = 1; [EOL] iMinFields = 0; [EOL] iShowSeparators = false; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write(anyString()); [EOL] verifyNoMoreInteractions(mockWriter); [EOL] }
public void testPrintToWithMaxFieldsTwoAndMinFieldsOne() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_MINUTE; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = Locale.getDefault(); [EOL] iMaxFields = 2; [EOL] iMinFields = 1; [EOL] iShowSeparators = false; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write(anyString()); [EOL] verifyNoMoreInteractions(mockWriter); [EOL] }
public void testPrintToWithMaxFieldsThreeAndMinFieldsTwo() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_SECOND; [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = Locale.getDefault(); [EOL] iMaxFields = 3; [EOL] iMinFields = 2; [EOL] iShowSeparators = true; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write(':'); [EOL] verify(mockWriter, times(2)).write(anyString()); [EOL] verifyNoMoreInteractions(mockWriter); [EOL] }
public void testPrintToWithFractionalOffset() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = 0L; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] int displayOffset = DateTimeConstants.MILLIS_PER_SECOND + 1; // 1 second + 1 millisecond [EOL] DateTimeZone displayZone = DateTimeZone.forOffsetMillis(displayOffset); [EOL] Locale locale = Locale.getDefault(); [EOL] iMaxFields = 4; [EOL] iMinFields = 0; [EOL] iShowSeparators = true; [EOL] printTo(mockWriter, instant, chrono, displayOffset, displayZone, locale); [EOL] verify(mockWriter).write('.'); [EOL] verify(mockWriter, times(3)).write(anyString()); [EOL] }
public void testParseInto_ZeroOffsetTextEmptyAndLimitGreaterThanZeroWithSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(0, result); [EOL] assertEquals(Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextEmptyAndLimitGreaterThanZeroWithoutSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "A"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(0, result); [EOL] assertEquals(Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_ZeroOffsetTextMatches() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Z"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(1, result); [EOL] assertEquals(Integer.valueOf(0), bucket.getOffset()); [EOL] } [EOL] public void testParseInto_LimitLessThanOrEqualToOne() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "-"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_InvalidFirstCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "A23:59:59.999"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_HoursGreaterThan23() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+24:00"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_ExpectSeparatorsButNoneFound() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+23A59"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_MinutesGreaterThan59() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+23:60"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_SecondsGreaterThan59() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+23:59:60"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_MillisSeparatorNotDotOrComma() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+23:59:59A999"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_ValidOffset() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "+23:59:59.999"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(12, result); [EOL] assertNotNull(bucket.getOffset()); [EOL] }
public void testParseInto_NoMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "NoMatchZone"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_MatchAtStart() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "UTC+MatchZone"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 3, result); // Assuming "UTC" is in ALL_IDS and is the longest match at the start [EOL] } [EOL] public void testParseInto_MatchNotAtStart() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "SomeTextUTC+MatchZone"; [EOL] int position = 9; // Position of "UTC" in the string [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 3, result); // Assuming "UTC" is in ALL_IDS and is the longest match at position 9 [EOL] } [EOL] public void testParseInto_MatchWithDifferentLengths() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "UTC+GMT+MatchZone"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 3, result); // Assuming "UTC" and "GMT" are in ALL_IDS but "UTC" is the longest match at the start [EOL] }
public void testPrintToWithNullElementsThrowsException() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] int displayOffset = 0; [EOL] DateTimeZone mockDateTimeZone = mock(DateTimeZone.class); [EOL] Locale mockLocale = mock(Locale.class); [EOL] try { [EOL] printTo(mockWriter, instant, mockChronology, displayOffset, mockDateTimeZone, mockLocale); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullElementsAndNullLocale() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] int displayOffset = 0; [EOL] DateTimeZone mockDateTimeZone = mock(DateTimeZone.class); [EOL] Locale defaultLocale = Locale.getDefault(); [EOL] DateTimePrinter[] elements = new DateTimePrinter[] { mock(DateTimePrinter.class) }; [EOL] setPrinters(elements); // Assuming there is a method to set the private iPrinters field [EOL] printTo(mockWriter, instant, mockChronology, displayOffset, mockDateTimeZone, null); [EOL] verify(elements[0]).printTo(mockWriter, instant, mockChronology, displayOffset, mockDateTimeZone, defaultLocale); [EOL] }
public void testPrintToWithNonNullElementsAndNonNullLocale() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] int displayOffset = 0; [EOL] DateTimeZone mockDateTimeZone = mock(DateTimeZone.class); [EOL] Locale customLocale = new Locale("fr", "CA"); [EOL] DateTimePrinter[] elements = new DateTimePrinter[] { mock(DateTimePrinter.class) }; [EOL] setPrinters(elements); // Assuming there is a method to set the private iPrinters field [EOL] printTo(mockWriter, instant, mockChronology, displayOffset, mockDateTimeZone, customLocale); [EOL] verify(elements[0]).printTo(mockWriter, instant, mockChronology, displayOffset, mockDateTimeZone, customLocale); [EOL] }
public void testPrintToWithNullElementsThrowsException() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null); [EOL] try { [EOL] dtf.printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullElementsAndLocale() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] DateTimePrinter[] printers = new DateTimePrinter[] {mock(DateTimePrinter.class)}; [EOL] DateTimeFormatter dtf = new DateTimeFormatter(printers, null); [EOL] dtf.printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] verify(printers[0]).printTo(mockWriter, mockPartial, Locale.ENGLISH); [EOL] }
public void testPrintToWithNonNullElementsAndNullLocale() throws IOException { [EOL] Writer mockWriter = mock(Writer.class); [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] DateTimePrinter[] printers = new DateTimePrinter[] {mock(DateTimePrinter.class)}; [EOL] DateTimeFormatter dtf = new DateTimeFormatter(printers, null); [EOL] dtf.printTo(mockWriter, mockPartial, null); [EOL] verify(printers[0]).printTo(mockWriter, mockPartial, Locale.getDefault()); [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] TimeOfDay.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithValidDate() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.HOUR_OF_DAY, 13); [EOL] calendar.set(Calendar.MINUTE, 15); [EOL] calendar.set(Calendar.SECOND, 10); [EOL] calendar.set(Calendar.MILLISECOND, 200); [EOL] Date date = calendar.getTime(); [EOL] TimeOfDay result = TimeOfDay.fromDateFields(date); [EOL] assertNotNull(result); [EOL] assertEquals(13, result.getHourOfDay()); [EOL] assertEquals(15, result.getMinuteOfHour()); [EOL] assertEquals(10, result.getSecondOfMinute()); [EOL] assertEquals(200, result.getMillisOfSecond()); [EOL] }
public static TimeOfDay fromMillisOfDay(long millisOfDay) { [EOL] return fromMillisOfDay(millisOfDay, null); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testFromMillisOfDayWithNullChronology() { [EOL] long millisOfDay = 12345L; [EOL] TimeOfDay result = TimeOfDay.fromMillisOfDay(millisOfDay, null); [EOL] assertNotNull(result); [EOL] assertEquals(result.getChronology().getZone(), DateTimeZone.UTC); [EOL] }
public void testFromMillisOfDayWithNonNullChronology() { [EOL] long millisOfDay = 12345L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] TimeOfDay result = TimeOfDay.fromMillisOfDay(millisOfDay, chrono); [EOL] assertNotNull(result); [EOL] assertEquals(result.getChronology().getZone(), DateTimeZone.UTC); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteSecondMillis() { [EOL] int hour = 13; [EOL] int minute = 15; [EOL] int second = 10; [EOL] int millis = 200; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hour, minute, second, millis); [EOL] assertEquals(hour, timeOfDay.getHourOfDay()); [EOL] assertEquals(minute, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(second, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millis, timeOfDay.getMillisOfSecond()); [EOL] }
public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) { [EOL] super(new int[] { hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond }, chronology); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testTimeOfDayWithPartialAndValues() { [EOL] TimeOfDay partial = new TimeOfDay(10, 20, 30, 400); [EOL] int[] values = new int[] {11, 22, 33, 44}; [EOL] TimeOfDay result = new TimeOfDay(partial, values); [EOL] assertEquals(11, result.getHourOfDay()); [EOL] assertEquals(22, result.getMinuteOfHour()); [EOL] assertEquals(33, result.getSecondOfMinute()); [EOL] assertEquals(44, result.getMillisOfSecond()); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay result = new TimeOfDay(); [EOL] assertNotNull(result); [EOL] }
public void testTimeOfDayConstructorWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay result = new TimeOfDay(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getChronology().getZone()); [EOL] }
public void testTimeOfDayConstructorWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testTimeOfDayConstructorWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay result = new TimeOfDay(instant); [EOL] assertNotNull(result); [EOL] }
public void testTimeOfDayConstructorWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testTimeOfDayConstructorWithObject() { [EOL] Object instant = new Date(); [EOL] TimeOfDay result = new TimeOfDay(instant); [EOL] assertNotNull(result); [EOL] }
public void testTimeOfDayConstructorWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testTimeOfDayConstructorWithHourAndMinute() { [EOL] TimeOfDay result = new TimeOfDay(10, 20); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteAndChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(10, 20, chronology); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteSecond() { [EOL] TimeOfDay result = new TimeOfDay(10, 20, 30); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteSecondAndChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(10, 20, 30, chronology); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteSecondMillis() { [EOL] TimeOfDay result = new TimeOfDay(10, 20, 30, 400); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(400, result.getMillisOfSecond()); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteSecondMillisAndChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(10, 20, 30, 400, chronology); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(400, result.getMillisOfSecond()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testSize() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] int size = timeOfDay.size(); [EOL] assertEquals(4, size); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayHourMinuteConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(30, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayHourMinuteSecondConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(20, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayHourMinuteSecondChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayFullConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20, 500); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(500, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayFullChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20, 500, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case HOUR_OF_DAY: [EOL] return chrono.hourOfDay(); [EOL] case MINUTE_OF_HOUR: [EOL] return chrono.minuteOfHour(); [EOL] case SECOND_OF_MINUTE: [EOL] return chrono.secondOfMinute(); [EOL] case MILLIS_OF_SECOND: [EOL] return chrono.millisOfSecond(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withField(DateTimeFieldType fieldType, int value) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (value == getValue(index)) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).set(this, index, newValues, value); [EOL] return new TimeOfDay(this, newValues); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=Optional[3633353405803318660L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }]
public void testWithPeriodAdded_NullPeriod() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay result = time.withPeriodAdded(null, 1); [EOL] assertEquals(time, result); [EOL] }
public void testWithPeriodAdded_ZeroScalar() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay result = time.withPeriodAdded(new MockPeriod(), 0); [EOL] assertEquals(time, result); [EOL] }
public void testWithPeriodAdded_NonZeroScalar() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] ReadablePeriod period = new MockPeriod(); [EOL] TimeOfDay result = time.withPeriodAdded(period, 1); [EOL] TimeOfDay expected = new TimeOfDay(11, 21, 30, 400); [EOL] assertEquals(expected, result); [EOL] }
public void testWithPeriodAdded_NegativeScalar() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] ReadablePeriod period = new MockPeriod(); [EOL] TimeOfDay result = time.withPeriodAdded(period, -1); [EOL] TimeOfDay expected = new TimeOfDay(9, 19, 30, 400); [EOL] assertEquals(expected, result); [EOL] }
public void testMinus_withPeriod() { [EOL] TimeOfDay time = new TimeOfDay(10, 0); // 10:00 AM [EOL] ReadablePeriod period = new Period(1, 0, 0, 0); // 1 hour [EOL] TimeOfDay result = time.minus(period); [EOL] assertEquals(new TimeOfDay(9, 0), result); // Assert result is 9:00 AM [EOL] }
public void testMinus_withNullPeriod() { [EOL] TimeOfDay time = new TimeOfDay(10, 0); // 10:00 AM [EOL] TimeOfDay result = time.minus(null); [EOL] assertEquals(time, result); // Assert result is unchanged [EOL] }
public void testMinusMinutes_CoverNewLines() { [EOL] TimeOfDay time = new TimeOfDay(10, 30); [EOL] TimeOfDay result = time.minusMinutes(10); [EOL] assertEquals(new TimeOfDay(10, 20), result); [EOL] result = time.minusMinutes(-10); [EOL] assertEquals(new TimeOfDay(10, 40), result); [EOL] result = time.minusMinutes(0); [EOL] assertEquals(time, result); [EOL] }
public void testTimeOfDayConstructors_CoverNewLines() { [EOL] TimeOfDay defaultTime = new TimeOfDay(); [EOL] assertNotNull(defaultTime); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay zonedTime = new TimeOfDay(zone); [EOL] assertNotNull(zonedTime); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay chronoTime = new TimeOfDay(chronology); [EOL] assertNotNull(chronoTime); [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay instantTime = new TimeOfDay(instant); [EOL] assertNotNull(instantTime); [EOL] TimeOfDay instantChronoTime = new TimeOfDay(instant, chronology); [EOL] assertNotNull(instantChronoTime); [EOL] Date date = new Date(); [EOL] TimeOfDay objectTime = new TimeOfDay(date); [EOL] assertNotNull(objectTime); [EOL] TimeOfDay objectChronoTime = new TimeOfDay(date, chronology); [EOL] assertNotNull(objectChronoTime); [EOL] TimeOfDay hourMinuteTime = new TimeOfDay(10, 30); [EOL] assertEquals(10, hourMinuteTime.getHourOfDay()); [EOL] assertEquals(30, hourMinuteTime.getMinuteOfHour()); [EOL] TimeOfDay hourMinuteChronoTime = new TimeOfDay(10, 30, chronology); [EOL] assertEquals(10, hourMinuteChronoTime.getHourOfDay()); [EOL] assertEquals(30, hourMinuteChronoTime.getMinuteOfHour()); [EOL] TimeOfDay hourMinuteSecondTime = new TimeOfDay(10, 30, 20); [EOL] assertEquals(10, hourMinuteSecondTime.getHourOfDay()); [EOL] assertEquals(30, hourMinuteSecondTime.getMinuteOfHour()); [EOL] assertEquals(20, hourMinuteSecondTime.getSecondOfMinute()); [EOL] TimeOfDay hourMinuteSecondChronoTime = new TimeOfDay(10, 30, 20, chronology); [EOL] assertEquals(10, hourMinuteSecondChronoTime.getHourOfDay()); [EOL] assertEquals(30, hourMinuteSecondChronoTime.getMinuteOfHour()); [EOL] assertEquals(20, hourMinuteSecondChronoTime.getSecondOfMinute()); [EOL] TimeOfDay hourMinuteSecondMillisTime = new TimeOfDay(10, 30, 20, 500); [EOL] assertEquals(10, hourMinuteSecondMillisTime.getHourOfDay()); [EOL] assertEquals(30, hourMinuteSecondMillisTime.getMinuteOfHour()); [EOL] assertEquals(20, hourMinuteSecondMillisTime.getSecondOfMinute()); [EOL] assertEquals(500, hourMinuteSecondMillisTime.getMillisOfSecond()); [EOL] TimeOfDay hourMinuteSecondMillisChronoTime = new TimeOfDay(10, 30, 20, 500, chronology); [EOL] assertEquals(10, hourMinuteSecondMillisChronoTime.getHourOfDay()); [EOL] assertEquals(30, hourMinuteSecondMillisChronoTime.getMinuteOfHour()); [EOL] assertEquals(20, hourMinuteSecondMillisChronoTime.getSecondOfMinute()); [EOL] assertEquals(500, hourMinuteSecondMillisChronoTime.getMillisOfSecond()); [EOL] }
public void testPropertyWithValidType() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] Property property = timeOfDay.property(DateTimeFieldType.hourOfDay()); [EOL] assertNotNull(property); [EOL] assertEquals(DateTimeFieldType.hourOfDay(), property.getFieldType()); [EOL] }
public void testPropertyWithUnsupportedType() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] try { [EOL] timeOfDay.property(DateTimeFieldType.dayOfWeek()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(zone, timeOfDay.getChronology().getZone()); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayIntIntConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayIntIntIntConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayIntIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayIntIntIntIntConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 40); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(40, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayIntIntIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 40, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(40, timeOfDay.getMillisOfSecond()); [EOL] }
public LocalTime toLocalTime() { [EOL] return new LocalTime(getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), getChronology()); [EOL] } [EOL] public TimeOfDay() {} [EOL] public TimeOfDay(DateTimeZone zone) {} [EOL] public TimeOfDay(Chronology chronology) {} [EOL] public TimeOfDay(long instant) {} [EOL] public TimeOfDay(long instant, Chronology chronology) {} [EOL] public TimeOfDay(Object instant) {} [EOL] public TimeOfDay(Object instant, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {} [EOL] TimeOfDay(TimeOfDay partial, int[] values) {} [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) {} [EOL] Property(TimeOfDay partial, int fieldIndex) {} [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) {} [EOL] public static TimeOfDay fromDateFields(Date date) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public TimeOfDay plus(ReadablePeriod period) {} [EOL] public TimeOfDay plusHours(int hours) {} [EOL] public TimeOfDay plusMinutes(int minutes) {} [EOL] public TimeOfDay plusSeconds(int seconds) {} [EOL] public TimeOfDay plusMillis(int millis) {} [EOL] public TimeOfDay minus(ReadablePeriod period) {} [EOL] public TimeOfDay minusHours(int hours) {} [EOL] public TimeOfDay minusMinutes(int minutes) {} [EOL] public TimeOfDay minusSeconds(int seconds) {} [EOL] public TimeOfDay minusMillis(int millis) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public LocalTime toLocalTime() {} [EOL] public DateTime toDateTimeToday() {} [EOL] public DateTime toDateTimeToday(DateTimeZone zone) {} [EOL] public int getHourOfDay() {} [EOL] public int getMinuteOfHour() {} [EOL] public int getSecondOfMinute() {} [EOL] public int getMillisOfSecond() {} [EOL] public TimeOfDay withHourOfDay(int hour) {} [EOL] public TimeOfDay withMinuteOfHour(int minute) {} [EOL] public TimeOfDay withSecondOfMinute(int second) {} [EOL] public TimeOfDay withMillisOfSecond(int millis) {} [EOL] public Property hourOfDay() {} [EOL] public Property minuteOfHour() {} [EOL] public Property secondOfMinute() {} [EOL] public Property millisOfSecond() {} [EOL] public String toString() {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public TimeOfDay getTimeOfDay() {} [EOL] public int get() {} [EOL] public TimeOfDay addToCopy(int valueToAdd) {} [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) {} [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public TimeOfDay setCopy(int value) {} [EOL] public TimeOfDay setCopy(String text, Locale locale) {} [EOL] public TimeOfDay setCopy(String text) {} [EOL] public TimeOfDay withMaximumValue() {} [EOL] public TimeOfDay withMinimumValue() {} [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testGetHourOfDay() { [EOL] TimeOfDay time = new TimeOfDay(10, 0); [EOL] int hour = time.getHourOfDay(); [EOL] assertEquals(10, hour); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay time = new TimeOfDay(); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(chronology); [EOL] assertNotNull(time); [EOL] assertEquals(chronology, time.getChronology()); [EOL] }
public void testTimeOfDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay time = new TimeOfDay(instant); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(instant, chronology); [EOL] assertNotNull(time); [EOL] assertEquals(chronology, time.getChronology()); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay time = new TimeOfDay(instant); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(instant, chronology); [EOL] assertNotNull(time); [EOL] assertEquals(chronology, time.getChronology()); [EOL] }
public void testTimeOfDayFullConstructor() { [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400); [EOL] assertNotNull(time); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(20, time.getMinuteOfHour()); [EOL] assertEquals(30, time.getSecondOfMinute()); [EOL] assertEquals(400, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayFullChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(10, 20, 30, 400, chronology); [EOL] assertNotNull(time); [EOL] assertEquals(chronology, time.getChronology()); [EOL] }
public void testGetMinuteOfHour() { [EOL] TimeOfDay time = new TimeOfDay(10, 30); [EOL] int minute = time.getMinuteOfHour(); [EOL] assertEquals(30, minute); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay time = new TimeOfDay(); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay time = new TimeOfDay(zone); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(chronology); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay time = new TimeOfDay(instant); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(instant, chronology); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay time = new TimeOfDay(instant); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(instant, chronology); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayHourAndMinuteConstructor() { [EOL] TimeOfDay time = new TimeOfDay(10, 30); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(10, 30, chronology); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayFullConstructor() { [EOL] TimeOfDay time = new TimeOfDay(10, 30, 20, 500); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(20, time.getSecondOfMinute()); [EOL] assertEquals(500, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayFullChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(10, 30, 20, 500, chronology); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(20, time.getSecondOfMinute()); [EOL] assertEquals(500, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayPartialValuesConstructor() { [EOL] TimeOfDay partial = new TimeOfDay(10, 30); [EOL] int[] values = new int[] {11, 40}; [EOL] TimeOfDay time = new TimeOfDay(partial, values); [EOL] assertEquals(11, time.getHourOfDay()); [EOL] assertEquals(40, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayPartialChronoConstructor() { [EOL] TimeOfDay partial = new TimeOfDay(10, 30); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(partial, chrono); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.HOUR_OF_DAY, 10); [EOL] calendar.set(Calendar.MINUTE, 30); [EOL] TimeOfDay time = TimeOfDay.fromCalendarFields(calendar); [EOL] assertEquals(10, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] }
public void testTimeOfDayFromDateFields() { [EOL] Date date = new Date(); [EOL] TimeOfDay time = TimeOfDay.fromDateFields(date); [EOL] assertNotNull(time); [EOL] }
public void testTimeOfDayFromMillisOfDay() { [EOL] long millisOfDay = 3600000; // 1 hour in milliseconds [EOL] TimeOfDay time = TimeOfDay.fromMillisOfDay(millisOfDay); [EOL] assertEquals(1, time.getHourOfDay()); [EOL] }
public void testTimeOfDayFromMillisOfDayChronology() { [EOL] long millisOfDay = 3600000; // 1 hour in milliseconds [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = TimeOfDay.fromMillisOfDay(millisOfDay, chrono); [EOL] assertEquals(1, time.getHourOfDay()); [EOL] }
public int getSecondOfMinute() { [EOL] return getValue(SECOND_OF_MINUTE); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public int getMillisOfSecond() { [EOL] return getValue(MILLIS_OF_SECOND); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public void testMinuteOfHour() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] Property property = timeOfDay.minuteOfHour(); [EOL] assertNotNull(property); [EOL] assertEquals(DateTimeFieldType.minuteOfHour(), property.getFieldType()); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayHourMinuteConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteSecondConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayHourMinuteSecondChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayFullConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(400, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayFullChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(400, timeOfDay.getMillisOfSecond()); [EOL] }
public Property secondOfMinute() { [EOL] return new Property(this, SECOND_OF_MINUTE); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public String toString() { [EOL] return ISODateTimeFormat.tTime().print(this); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public void testPropertyWithValidTimeOfDayAndFieldIndex() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] int fieldIndex = 0; // Assuming 0 is a valid field index [EOL] Property property = new Property(timeOfDay, fieldIndex); [EOL] assertNotNull(property); [EOL] assertEquals(timeOfDay, property.getTimeOfDay()); [EOL] assertEquals(fieldIndex, property.get()); [EOL] }
public void testPropertyWithNullTimeOfDay() { [EOL] try { [EOL] new Property(null, 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPropertyWithInvalidFieldIndex() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] int fieldIndex = -1; // Assuming -1 is an invalid field index [EOL] try { [EOL] new Property(timeOfDay, fieldIndex); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetField() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] DateTimeField field = timeOfDay.getField(); [EOL] assertNotNull(field); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayHourMinuteConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayHourMinuteSecondConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayHourMinuteSecondChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayHourMinuteSecondMillisConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 40); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(40, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayHourMinuteSecondMillisChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 40, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(20, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(30, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(40, timeOfDay.getMillisOfSecond()); [EOL] }
protected ReadablePartial getReadablePartial() { [EOL] return iTimeOfDay; [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=Optional[3633353405803318660L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }];
public void testSetCopy_ValidValue() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] int newValue = 15; [EOL] TimeOfDay updatedTimeOfDay = timeOfDay.setCopy(newValue); [EOL] assertNotNull(updatedTimeOfDay); [EOL] assertEquals(newValue, updatedTimeOfDay.get(timeOfDay.getField().getType())); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] int invalidValue = -1; [EOL] try { [EOL] timeOfDay.setCopy(invalidValue); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopy_MaximumValue() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] int maxValue = timeOfDay.getField().getMaximumValue(); [EOL] TimeOfDay updatedTimeOfDay = timeOfDay.setCopy(maxValue); [EOL] assertNotNull(updatedTimeOfDay); [EOL] assertEquals(maxValue, updatedTimeOfDay.get(timeOfDay.getField().getType())); [EOL] }
public void testSetCopy_MinimumValue() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] int minValue = timeOfDay.getField().getMinimumValue(); [EOL] TimeOfDay updatedTimeOfDay = timeOfDay.setCopy(minValue); [EOL] assertNotNull(updatedTimeOfDay); [EOL] assertEquals(minValue, updatedTimeOfDay.get(timeOfDay.getField().getType())); [EOL] }
public int get(long instant) { [EOL] int year = getWrappedField().get(instant); [EOL] return year < 0 ? -year : year; [EOL] }
public void testContains_MillisBeforeStart() { [EOL] long millisInstant = getStartMillis() - 1; [EOL] boolean result = contains(millisInstant); [EOL] assertFalse(result); [EOL] }
public void testContains_MillisAtStart() { [EOL] long millisInstant = getStartMillis(); [EOL] boolean result = contains(millisInstant); [EOL] assertTrue(result); [EOL] }
public void testContains_MillisAfterStartBeforeEnd() { [EOL] long millisInstant = getStartMillis() + 1; [EOL] boolean result = contains(millisInstant); [EOL] assertTrue(result); [EOL] }
public void testContains_MillisAtEnd() { [EOL] long millisInstant = getEndMillis(); [EOL] boolean result = contains(millisInstant); [EOL] assertFalse(result); [EOL] }
public void testContains_MillisAfterEnd() { [EOL] long millisInstant = getEndMillis() + 1; [EOL] boolean result = contains(millisInstant); [EOL] assertFalse(result); [EOL] }
public boolean containsNow() { [EOL] return contains(DateTimeUtils.currentTimeMillis()); [EOL] }
public void testContains_withNullInstant() { [EOL] TimePeriod timePeriod = new TimePeriod(); // Assuming TimePeriod is the class containing the contains method [EOL] boolean result = timePeriod.contains(null); [EOL] assertTrue("Expected the time period to contain now when instant is null", result); [EOL] }
public void testContains_withNonNullInstant() { [EOL] TimePeriod timePeriod = new TimePeriod(); // Assuming TimePeriod is the class containing the contains method [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); // Using a mocking framework like Mockito [EOL] when(mockInstant.getMillis()).thenReturn(VALID_TIME_MILLIS); // VALID_TIME_MILLIS should be a timestamp that is contained within the time period [EOL] boolean result = timePeriod.contains(mockInstant); [EOL] assertTrue("Expected the time period to contain the instant", result); [EOL] }
public void testIsBeforeWithNullInterval() { [EOL] DateTime testDateTime = new DateTime(); [EOL] boolean result = testDateTime.isBefore(null); [EOL] boolean expected = testDateTime.isBeforeNow(); [EOL] assertEquals(expected, result); [EOL] }
public void testIsBeforeWithNonNullInterval() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInterval interval = new Interval(testDateTime.plusHours(1), testDateTime.plusHours(2)); [EOL] boolean result = testDateTime.isBefore(interval); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeWithIntervalBeforeDateTime() { [EOL] DateTime testDateTime = new DateTime(); [EOL] ReadableInterval interval = new Interval(testDateTime.minusHours(2), testDateTime.minusHours(1)); [EOL] boolean result = testDateTime.isBefore(interval); [EOL] assertFalse(result); [EOL] }
public void testIsAfterWithNullInstant() { [EOL] Time time = new Time(); [EOL] boolean result = time.isAfter(null); [EOL] assertTrue(result); [EOL] }
public void testIsAfterWithPastInstant() { [EOL] Time time = new Time(); [EOL] ReadableInstant pastInstant = new MockReadableInstant(System.currentTimeMillis() - 1000); [EOL] boolean result = time.isAfter(pastInstant); [EOL] assertTrue(result); [EOL] }
public void testIsAfterWithFutureInstant() { [EOL] Time time = new Time(); [EOL] ReadableInstant futureInstant = new MockReadableInstant(System.currentTimeMillis() + 1000); [EOL] boolean result = time.isAfter(futureInstant); [EOL] assertFalse(result); [EOL] }
public void testEquals_SameObject() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] assertTrue(period1.equals(period1)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] assertFalse(period1.equals(new Object())); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] assertFalse(period1.equals(null)); [EOL] } [EOL] public void testEquals_DifferentSize() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriodWithDifferentSize(); [EOL] assertFalse(period1.equals(period2)); [EOL] } [EOL] public void testEquals_DifferentValues() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriodWithDifferentValues(); [EOL] assertFalse(period1.equals(period2)); [EOL] } [EOL] public void testEquals_DifferentFieldTypes() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriodWithDifferentFieldTypes(); [EOL] assertFalse(period1.equals(period2)); [EOL] } [EOL] public void testEquals_EqualPeriods() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriod(); [EOL] assertTrue(period1.equals(period2)); [EOL] }
public void testMutablePeriod_AllFields() { [EOL] MutablePeriod mp = new MutablePeriod(1, 2, 3, 4); [EOL] assertEquals(1, mp.getHours()); [EOL] assertEquals(2, mp.getMinutes()); [EOL] assertEquals(3, mp.getSeconds()); [EOL] assertEquals(4, mp.getMillis()); [EOL] }
public void testMutablePeriod_AllFields() { [EOL] MutablePeriod period = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); [EOL] assertEquals(1, period.getYears()); [EOL] assertEquals(2, period.getMonths()); [EOL] assertEquals(3, period.getWeeks()); [EOL] assertEquals(4, period.getDays()); [EOL] assertEquals(5, period.getHours()); [EOL] assertEquals(6, period.getMinutes()); [EOL] assertEquals(7, period.getSeconds()); [EOL] assertEquals(8, period.getMillis()); [EOL] }
public void testMutablePeriodWithValidDurationAndChronology() { [EOL] long duration = 1000L; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, chronology); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationMillis()); [EOL] assertEquals(chronology, mutablePeriod.getChronology()); [EOL] }
public void testMutablePeriodWithValidDurationAndNullChronology() { [EOL] long duration = 1000L; [EOL] MutablePeriod mutablePeriod = new MutablePeriod(duration, null); [EOL] assertNotNull(mutablePeriod); [EOL] assertEquals(duration, mutablePeriod.toDurationMillis()); [EOL] assertNull(mutablePeriod.getChronology()); [EOL] }
public void testMutablePeriodWithValidPeriodType() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, type); [EOL] assertNotNull(period); [EOL] assertEquals(type, period.getPeriodType()); [EOL] }
public void testMutablePeriodWithNullPeriodType() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, null); [EOL] assertNotNull(period); [EOL] assertEquals(PeriodType.standard(), period.getPeriodType()); [EOL] }
public void testMutablePeriodWithValidArguments() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 10000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, type, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(9000, period.toDurationMillis()); [EOL] }
public void testMutablePeriodWithNullType() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 10000L; [EOL] PeriodType type = null; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, type, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(9000, period.toDurationMillis()); [EOL] }
public void testMutablePeriodWithNullChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 10000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Chronology chrono = null; [EOL] MutablePeriod period = new MutablePeriod(startInstant, endInstant, type, chrono); [EOL] assertNotNull(period); [EOL] assertEquals(9000, period.toDurationMillis()); [EOL] }
public void testSetPeriodWithNullInterval() { [EOL] Period period = new Period(); [EOL] ReadableInterval interval = null; [EOL] period.setPeriod(interval); [EOL] assertEquals(0, period.toStandardDuration().getMillis()); [EOL] }
public void testSetPeriodWithNonNullInterval() { [EOL] Period period = new Period(); [EOL] ReadableInterval interval = new Interval(0, 1000); // 1 second interval [EOL] period.setPeriod(interval); [EOL] assertEquals(1000, period.toStandardDuration().getMillis()); [EOL] }
public void testSetPeriod_WithValidChronology() { [EOL] long startInstant = 0L; [EOL] long endInstant = 10000L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] setPeriod(startInstant, endInstant, chrono); [EOL] }
public void testSetPeriod_WithNullChronology() { [EOL] long startInstant = 0L; [EOL] long endInstant = 10000L; [EOL] setPeriod(startInstant, endInstant, null); [EOL] }
public void testSetPeriodWithNullDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.setPeriod(null); [EOL] assertNull(timePeriod.getStart()); [EOL] assertNull(timePeriod.getEnd()); [EOL] }
public void testSetPeriodWithNonNullDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] ReadableDuration duration = new ReadableDuration() { [EOL] public long getMillis() { return 1000; } [EOL] }; [EOL] timePeriod.setPeriod(duration); [EOL] assertNotNull(timePeriod.getStart()); [EOL] assertNotNull(timePeriod.getEnd()); [EOL] assertEquals(1000, timePeriod.getEnd().getTime() - timePeriod.getStart().getTime()); [EOL] }
public void testSetPeriodWithNullDuration() { [EOL] MyPeriod period = new MyPeriod(); [EOL] period.setPeriod((ReadableDuration) null, Chronology.getISO()); [EOL] assertEquals(0, period.getMillis()); [EOL] }
public void testSetPeriodWithNonNullDuration() { [EOL] MyPeriod period = new MyPeriod(); [EOL] ReadableDuration duration = new Duration(1234); [EOL] period.setPeriod(duration, Chronology.getISO()); [EOL] assertEquals(1234, period.getMillis()); [EOL] }
public void testSetPeriodWithNullChronology() { [EOL] MyPeriod period = new MyPeriod(); [EOL] ReadableDuration duration = new Duration(1234); [EOL] period.setPeriod(duration, null); [EOL] assertEquals(1234, period.getMillis()); [EOL] }
public void add(DurationFieldType field, int value) { [EOL] super.addField(field, value); [EOL] }
public int getHours() { [EOL] return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX); [EOL] }
public void testSetMonths_ValidMonths() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setMonths(5); [EOL] assertEquals(5, testDuration.getMonths()); [EOL] }
public void testSetMonths_Zero() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setMonths(0); [EOL] assertEquals(0, testDuration.getMonths()); [EOL] }
public void testSetMonths_NegativeMonths() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setMonths(-3); [EOL] assertEquals(-3, testDuration.getMonths()); [EOL] }
public void testSetDays_Positive() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setDays(5); [EOL] assertEquals(5, testDuration.getField(DurationFieldType.days())); [EOL] }
public void testSetDays_Negative() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setDays(-5); [EOL] assertEquals(-5, testDuration.getField(DurationFieldType.days())); [EOL] }
public void testSetDays_Zero() { [EOL] Duration testDuration = new Duration(); [EOL] testDuration.setDays(0); [EOL] assertEquals(0, testDuration.getField(DurationFieldType.days())); [EOL] }
public void setHours_validHours() { [EOL] Duration duration = new Duration(); [EOL] int validHours = 5; [EOL] duration.setHours(validHours); [EOL] assertEquals(validHours, duration.getField(DurationFieldType.hours()).getValue()); [EOL] }

public void testSetMinutes_ValidValue() { [EOL] Duration testDuration = new Duration(0L); [EOL] testDuration.setMinutes(30); [EOL] assertEquals(30, testDuration.getMinutes()); [EOL] }
public void testSetMinutes_NegativeValue() { [EOL] Duration testDuration = new Duration(0L); [EOL] testDuration.setMinutes(-30); [EOL] assertEquals(-30, testDuration.getMinutes()); [EOL] }
public void testSetSeconds_ValidValue() { [EOL] MutablePeriod period = new MutablePeriod(); [EOL] period.setSeconds(30); [EOL] assertEquals(30, period.getSeconds()); [EOL] }
public void testSetSeconds_NegativeValue() { [EOL] MutablePeriod period = new MutablePeriod(); [EOL] period.setSeconds(-10); [EOL] assertEquals(-10, period.getSeconds()); [EOL] }
public void testSetSeconds_MaxInteger() { [EOL] MutablePeriod period = new MutablePeriod(); [EOL] period.setSeconds(Integer.MAX_VALUE); [EOL] assertEquals(Integer.MAX_VALUE, period.getSeconds()); [EOL] }
public void testSetSeconds_MinInteger() { [EOL] MutablePeriod period = new MutablePeriod(); [EOL] period.setSeconds(Integer.MIN_VALUE); [EOL] assertEquals(Integer.MIN_VALUE, period.getSeconds()); [EOL] }
public void addSeconds_addPositiveSeconds() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.addSeconds(10); [EOL] assertEquals(10, timePeriod.getSeconds()); [EOL] }
public void addSeconds_addNegativeSeconds() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.addSeconds(-5); [EOL] assertEquals(-5, timePeriod.getSeconds()); [EOL] }
public void addSeconds_addZeroSeconds() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.addSeconds(0); [EOL] assertEquals(0, timePeriod.getSeconds()); [EOL] }
public void testSetMillis_ValidValue() { [EOL] Duration testDuration = new Duration(0L); [EOL] testDuration.setMillis(500); [EOL] assertEquals(500, testDuration.getMillis()); [EOL] }
public void testSetMillis_NegativeValue() { [EOL] Duration testDuration = new Duration(0L); [EOL] testDuration.setMillis(-500); [EOL] assertEquals(-500, testDuration.getMillis()); [EOL] }
public void testCopy() { [EOL] MutablePeriod original = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); [EOL] MutablePeriod copy = original.copy(); [EOL] assertNotSame(original, copy); [EOL] assertEquals(original, copy); [EOL] }
public void testCloneSuccessful() throws Exception { [EOL] YourClass instance = new YourClass(); [EOL] Object clonedInstance = instance.clone(); [EOL] assertNotNull(clonedInstance); [EOL] assertNotSame(instance, clonedInstance); [EOL] assertEquals(instance.getClass(), clonedInstance.getClass()); [EOL] }
public void testCloneThrowsInternalError() { [EOL] YourClass instance = new YourClass() { [EOL] public Object clone() throws CloneNotSupportedException { [EOL] throw new CloneNotSupportedException(); [EOL] } [EOL] }; [EOL] try { [EOL] instance.clone(); [EOL] fail("Expected an InternalError to be thrown"); [EOL] } catch (InternalError ex) { [EOL] assertEquals("Clone error", ex.getMessage()); [EOL] } [EOL] }
public void testRoundFloor_PositiveInstant() { [EOL] long instant = 1000; // Assuming iUnitMillis is 500 for this test [EOL] long expected = 1000; // As 1000 % 500 is 0 [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_NegativeInstant() { [EOL] long instant = -1000; // Assuming iUnitMillis is 500 for this test [EOL] long expected = -1500; // As (-1000 + 1) % 500 is 499, so -1000 + 1 - 499 - 500 [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_PositiveInstantNonZeroRemainder() { [EOL] long instant = 750; // Assuming iUnitMillis is 500 for this test [EOL] long expected = 500; // As 750 % 500 is 250 [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_NegativeInstantNonZeroRemainder() { [EOL] long instant = -750; // Assuming iUnitMillis is 500 for this test [EOL] long expected = -1000; // As (-750 + 1) % 500 is 251, so -750 + 1 - 251 - 500 [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithPositiveInstant() { [EOL] long instant = 50; // Assume iUnitMillis is initialized to 10 [EOL] long expected = instant % iUnitMillis; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithNegativeInstant() { [EOL] long instant = -50; // Assume iUnitMillis is initialized to 10 [EOL] long expected = (instant + 1) % iUnitMillis + iUnitMillis - 1; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithZeroInstant() { [EOL] long instant = 0; // Assume iUnitMillis is initialized to 10 [EOL] long expected = instant % iUnitMillis; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithInstantEqualToUnitMillis() { [EOL] long instant = iUnitMillis; // Assume iUnitMillis is initialized to a positive value [EOL] long expected = instant % iUnitMillis; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testBasicYearDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new BasicYearDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testBasicYearDateTimeFieldWithValidChronology() { [EOL] BasicChronology chronology = new GregorianChronology(); [EOL] BasicYearDateTimeField field = new BasicYearDateTimeField(chronology); [EOL] assertNotNull(field); [EOL] assertEquals(DateTimeFieldType.year(), field.getType()); [EOL] assertEquals(chronology.getAverageMillisPerYear(), field.getDurationField().getUnitMillis()); [EOL] }
public void testGetRangeDurationField_ReturnsNull() { [EOL] Time time = new Time(); [EOL] assertNull("Range duration field should be null", time.getRangeDurationField()); [EOL] }
public void testIsLeap_LeapYear() { [EOL] long leapYearInstant = /* assume this is a timestamp for a leap year */; [EOL] boolean result = isLeap(leapYearInstant); [EOL] assertTrue(result); [EOL] }
public void testIsLeap_NonLeapYear() { [EOL] long nonLeapYearInstant = /* assume this is a timestamp for a non-leap year */; [EOL] boolean result = isLeap(nonLeapYearInstant); [EOL] assertFalse(result); [EOL] }
public void testGetLeapAmount_LeapYear() { [EOL] long instant = /* provide a timestamp for a leap year */; [EOL] int expected = 1; [EOL] int actual = getLeapAmount(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetLeapAmount_NonLeapYear() { [EOL] long instant = /* provide a timestamp for a non-leap year */; [EOL] int expected = 0; [EOL] int actual = getLeapAmount(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundCeiling_AtYearStart() { [EOL] long instantAtYearStart = /* assume this is the start of the year millis */; [EOL] long expected = instantAtYearStart; [EOL] long actual = roundCeiling(instantAtYearStart); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundCeiling_WithinYear() { [EOL] long instantWithinYear = /* assume this is some millis within the year */; [EOL] int year = /* calculate the year from instantWithinYear */; [EOL] long expected = /* calculate the start of the next year millis */; [EOL] long actual = roundCeiling(instantWithinYear); [EOL] assertEquals(expected, actual); [EOL] }
public void testCompareTo_DifferentRangeDurationFields() { [EOL] SavedField field1 = createSavedFieldWithRangeDurationField(10); [EOL] SavedField field2 = createSavedFieldWithRangeDurationField(5); [EOL] int result = field1.compareTo(field2); [EOL] assertTrue(result > 0); [EOL] } [EOL] public void testCompareTo_SameRangeDifferentDurationFields() { [EOL] SavedField field1 = createSavedFieldWithSameRangeDifferentDurationField(10, 20); [EOL] SavedField field2 = createSavedFieldWithSameRangeDifferentDurationField(10, 5); [EOL] int result = field1.compareTo(field2); [EOL] assertTrue(result > 0); [EOL] } [EOL] public void testCompareTo_SameRangeSameDurationFields() { [EOL] SavedField field1 = createSavedFieldWithSameRangeSameDurationField(10, 20); [EOL] SavedField field2 = createSavedFieldWithSameRangeSameDurationField(10, 20); [EOL] int result = field1.compareTo(field2); [EOL] assertEquals(0, result); [EOL] }

public void testOffsetDateTimeFieldWithNullField() { [EOL] int offset = 5; [EOL] OffsetDateTimeField result = new OffsetDateTimeField(null, offset); [EOL] assertNull(result.getField()); [EOL] assertNull(result.getType()); [EOL] assertEquals(offset, result.getOffset()); [EOL] assertEquals(Integer.MIN_VALUE, result.getMin()); [EOL] assertEquals(Integer.MAX_VALUE, result.getMax()); [EOL] }
public void testOffsetDateTimeFieldWithNonNullField() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getType()).thenReturn(DateTimeFieldType.secondOfMinute()); [EOL] int offset = 5; [EOL] OffsetDateTimeField result = new OffsetDateTimeField(mockField, offset); [EOL] assertNotNull(result.getField()); [EOL] assertEquals(DateTimeFieldType.secondOfMinute(), result.getType()); [EOL] assertEquals(offset, result.getOffset()); [EOL] assertEquals(Integer.MIN_VALUE, result.getMin()); [EOL] assertEquals(Integer.MAX_VALUE, result.getMax()); [EOL] }
public void testOffsetDateTimeFieldWithValidInput() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] DateTimeFieldType type = DateTimeFieldType.hourOfDay(); [EOL] int offset = 5; [EOL] OffsetDateTimeField offsetDateTimeField = new OffsetDateTimeField(field, type, offset); [EOL] assertNotNull(offsetDateTimeField); [EOL] assertEquals(type, offsetDateTimeField.getType()); [EOL] assertEquals(offset, offsetDateTimeField.getOffset()); [EOL] }
public void testOffsetDateTimeFieldWithMinOffset() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] DateTimeFieldType type = DateTimeFieldType.hourOfDay(); [EOL] int offset = Integer.MIN_VALUE; [EOL] OffsetDateTimeField offsetDateTimeField = new OffsetDateTimeField(field, type, offset); [EOL] assertNotNull(offsetDateTimeField); [EOL] assertEquals(Integer.MIN_VALUE, offsetDateTimeField.getOffset()); [EOL] }
public void testOffsetDateTimeFieldWithMaxOffset() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] DateTimeFieldType type = DateTimeFieldType.hourOfDay(); [EOL] int offset = Integer.MAX_VALUE; [EOL] OffsetDateTimeField offsetDateTimeField = new OffsetDateTimeField(field, type, offset); [EOL] assertNotNull(offsetDateTimeField); [EOL] assertEquals(Integer.MAX_VALUE, offsetDateTimeField.getOffset()); [EOL] }
public void testOffsetDateTimeField_WithNonZeroOffset() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(1); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(10); [EOL] int offset = 5; [EOL] int minValue = 3; [EOL] int maxValue = 8; [EOL] OffsetDateTimeField field = new OffsetDateTimeField(mockField, DateTimeFieldType.dayOfMonth(), offset, minValue, maxValue); [EOL] assertEquals("Offset should be set to 5", 5, field.iOffset); [EOL] assertEquals("Minimum value should be adjusted by offset", 6, field.iMin); [EOL] assertEquals("Maximum value should be the original max value", 8, field.iMax); [EOL] }
public void testOffsetDateTimeField_WithOffsetCausingMinValueAdjustment() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(1); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(10); [EOL] int offset = 3; [EOL] int minValue = 2; [EOL] int maxValue = 12; [EOL] OffsetDateTimeField field = new OffsetDateTimeField(mockField, DateTimeFieldType.dayOfMonth(), offset, minValue, maxValue); [EOL] assertEquals("Offset should be set to 3", 3, field.iOffset); [EOL] assertEquals("Minimum value should be adjusted by offset", 4, field.iMin); [EOL] assertEquals("Maximum value should be adjusted by offset", 13, field.iMax); [EOL] }
public void testOffsetDateTimeField_WithOffsetCausingMaxValueAdjustment() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(1); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(10); [EOL] int offset = 2; [EOL] int minValue = 0; [EOL] int maxValue = 15; [EOL] OffsetDateTimeField field = new OffsetDateTimeField(mockField, DateTimeFieldType.dayOfMonth(), offset, minValue, maxValue); [EOL] assertEquals("Offset should be set to 2", 2, field.iOffset); [EOL] assertEquals("Minimum value should be the original min value", 0, field.iMin); [EOL] assertEquals("Maximum value should be adjusted by offset", 12, field.iMax); [EOL] }
public void testOffsetDateTimeField_WithZeroOffset_ShouldThrowException() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(1); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(10); [EOL] int offset = 0; [EOL] int minValue = 3; [EOL] int maxValue = 8; [EOL] try { [EOL] new OffsetDateTimeField(mockField, DateTimeFieldType.dayOfMonth(), offset, minValue, maxValue); [EOL] fail("Should have thrown IllegalArgumentException because offset is zero"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The offset cannot be zero", ex.getMessage()); [EOL] } [EOL] }
public int get(long instant) { [EOL] return super.get(instant) + iOffset; [EOL] }
public boolean isLeap(long instant) { [EOL] return getWrappedField().isLeap(instant); [EOL] }
public int getLeapAmountTest() { [EOL] YourConcreteClass instance = new YourConcreteClass(); [EOL] long instant = 0L; // Example value, you should use a value that makes sense in your context [EOL] Field mockField = mock(Field.class); [EOL] when(instance.getWrappedField()).thenReturn(mockField); [EOL] when(mockField.getLeapAmount(instant)).thenReturn(1); // Assuming 1 is the leap amount for the given instant [EOL] int result = instance.getLeapAmount(instant); [EOL] assertEquals(1, result); // Assert that the result is as expected [EOL] }
public void testGetLeapDurationField() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] DurationFieldType mockFieldType = mock(DurationFieldType.class); [EOL] when(mockField.getType()).thenReturn(mockFieldType); [EOL] when(mockField.getLeapDurationField()).thenReturn(mockField); [EOL] DelegatingDurationField delegatingField = new DelegatingDurationField(mockField); [EOL] DurationField result = delegatingField.getLeapDurationField(); [EOL] assertNotNull(result); [EOL] assertSame(mockField, result); [EOL] }
public int getMinimumValueTest() { [EOL] Time time = new Time(10); [EOL] int minValue = time.getMinimumValue(); [EOL] assert minValue == 10; [EOL] }
public void testGetMaximumValue() { [EOL] Time time = new Time(); [EOL] int expected = // set the expected value based on the context or preconditions [EOL] int actual = time.getMaximumValue(); [EOL] assertEquals(expected, actual); [EOL] }
public long roundHalfEven(long instant) { [EOL] return getWrappedField().roundHalfEven(instant); [EOL] }
public void testRoundFloor() { [EOL] long instant = SOME_INSTANT_IN_MILLIS; [EOL] long expected = instant - (instant % DateTimeConstants.MILLIS_PER_DAY); [EOL] assertEquals(expected, roundFloor(instant)); [EOL] }
public void testRoundFloorWithOffset() { [EOL] long instant = SOME_INSTANT_IN_MILLIS - 3 * DateTimeConstants.MILLIS_PER_DAY; [EOL] long expected = instant - (instant % DateTimeConstants.MILLIS_PER_DAY); [EOL] assertEquals(expected, roundFloor(instant)); [EOL] }
public int getMaximumValueTest() { [EOL] Time time = new Time(); [EOL] int result = time.getMaximumValue(); [EOL] assertEquals(53, result); [EOL] }
public void testGetMaximumValue_WithWeekYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.weekyear()); [EOL] int[] values = {2021}; [EOL] when(iChronology.getWeeksInYear(2021)).thenReturn(52); [EOL] int result = instance.getMaximumValue(mockPartial, values); [EOL] assertEquals(52, result); [EOL] }
public void testGetMaximumValue_WithoutWeekYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] int[] values = {15}; [EOL] int result = instance.getMaximumValue(mockPartial, values); [EOL] assertEquals(53, result); [EOL] }
public void testGetMaximumValue_MultipleFieldsIncludingWeekYear() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(3); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(mockPartial.getFieldType(1)).thenReturn(DateTimeFieldType.weekyear()); [EOL] when(mockPartial.getFieldType(2)).thenReturn(DateTimeFieldType.year()); [EOL] int[] values = {15, 2021, 2021}; [EOL] when(iChronology.getWeeksInYear(2021)).thenReturn(52); [EOL] int result = instance.getMaximumValue(mockPartial, values); [EOL] assertEquals(52, result); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagsMatch() { [EOL] Chronology mockBase = Mockito.mock(Chronology.class); [EOL] iBase = mockBase; [EOL] iBaseFlags = 6; [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expected = 162149760012345L; [EOL] Mockito.when(mockBase.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)).thenReturn(expected); [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDateTimeMillis_BaseNotNullAndFlagsDoNotMatch() { [EOL] Chronology mockBase = Mockito.mock(Chronology.class); [EOL] iBase = mockBase; [EOL] iBaseFlags = 2; // Any value that does not match the condition (iBaseFlags & 6) == 6 [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long expected = 162149760012345L; [EOL] Mockito.when(mockBase.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay)).thenReturn(expected); [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] assertNotEquals(expected, result); // The result should not be equal to expected since the condition is not met [EOL] }
public void testGetDateTimeMillis_BaseNull() { [EOL] iBase = null; [EOL] iBaseFlags = 0; // Any value since iBase is null [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int millisOfDay = 12345; [EOL] long result = getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL] }
private void setFields() { [EOL] Fields fields = new Fields(); [EOL] if (iBase != null) { [EOL] fields.copyFieldsFrom(iBase); [EOL] } [EOL] assemble(fields); [EOL] { [EOL] DurationField f; [EOL] iMillis = (f = fields.millis) != null ? f : super.millis(); [EOL] iSeconds = (f = fields.seconds) != null ? f : super.seconds(); [EOL] iMinutes = (f = fields.minutes) != null ? f : super.minutes(); [EOL] iHours = (f = fields.hours) != null ? f : super.hours(); [EOL] iHalfdays = (f = fields.halfdays) != null ? f : super.halfdays(); [EOL] iDays = (f = fields.days) != null ? f : super.days(); [EOL] iWeeks = (f = fields.weeks) != null ? f : super.weeks(); [EOL] iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears(); [EOL] iMonths = (f = fields.months) != null ? f : super.months(); [EOL] iYears = (f = fields.years) != null ? f : super.years(); [EOL] iCenturies = (f = fields.centuries) != null ? f : super.centuries(); [EOL] iEras = (f = fields.eras) != null ? f : super.eras(); [EOL] } [EOL] { [EOL] DateTimeField f; [EOL] iMillisOfSecond = (f = fields.millisOfSecond) != null ? f : super.millisOfSecond(); [EOL] iMillisOfDay = (f = fields.millisOfDay) != null ? f : super.millisOfDay(); [EOL] iSecondOfMinute = (f = fields.secondOfMinute) != null ? f : super.secondOfMinute(); [EOL] iSecondOfDay = (f = fields.secondOfDay) != null ? f : super.secondOfDay(); [EOL] iMinuteOfHour = (f = fields.minuteOfHour) != null ? f : super.minuteOfHour(); [EOL] iMinuteOfDay = (f = fields.minuteOfDay) != null ? f : super.minuteOfDay(); [EOL] iHourOfDay = (f = fields.hourOfDay) != null ? f : super.hourOfDay(); [EOL] iClockhourOfDay = (f = fields.clockhourOfDay) != null ? f : super.clockhourOfDay(); [EOL] iHourOfHalfday = (f = fields.hourOfHalfday) != null ? f : super.hourOfHalfday(); [EOL] iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday(); [EOL] iHalfdayOfDay = (f = fields.halfdayOfDay) != null ? f : super.halfdayOfDay(); [EOL] iDayOfWeek = (f = fields.dayOfWeek) != null ? f : super.dayOfWeek(); [EOL] iDayOfMonth = (f = fields.dayOfMonth) != null ? f : super.dayOfMonth(); [EOL] iDayOfYear = (f = fields.dayOfYear) != null ? f : super.dayOfYear(); [EOL] iWeekOfWeekyear = (f = fields.weekOfWeekyear) != null ? f : super.weekOfWeekyear(); [EOL] iWeekyear = (f = fields.weekyear) != null ? f : super.weekyear(); [EOL] iWeekyearOfCentury = (f = fields.weekyearOfCentury) != null ? f : super.weekyearOfCentury(); [EOL] iMonthOfYear = (f = fields.monthOfYear) != null ? f : super.monthOfYear(); [EOL] iYear = (f = fields.year) != null ? f : super.year(); [EOL] iYearOfEra = (f = fields.yearOfEra) != null ? f : super.yearOfEra(); [EOL] iYearOfCentury = (f = fields.yearOfCentury) != null ? f : super.yearOfCentury(); [EOL] iCenturyOfEra = (f = fields.centuryOfEra) != null ? f : super.centuryOfEra(); [EOL] iEra = (f = fields.era) != null ? f : super.era(); [EOL] } [EOL] int flags; [EOL] if (iBase == null) { [EOL] flags = 0; [EOL] } else { [EOL] flags = ((iHourOfDay == iBase.hourOfDay() && iMinuteOfHour == iBase.minuteOfHour() && iSecondOfMinute == iBase.secondOfMinute() && iMillisOfSecond == iBase.millisOfSecond()) ? 1 : 0) | ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) | ((iYear == iBase.year() && iMonthOfYear == iBase.monthOfYear() && iDayOfMonth == iBase.dayOfMonth()) ? 4 : 0); [EOL] } [EOL] iBaseFlags = flags; [EOL] }
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL] in.defaultReadObject(); [EOL] setFields(); [EOL] }
public void testDaysInWithNullInterval() { [EOL] Days result = Time.daysIn(null); [EOL] assertEquals(Days.ZERO, result); [EOL] }
public void testDaysInWithValidInterval() { [EOL] ReadableInterval interval = new ReadableInterval() { [EOL] public DateTime getStart() { [EOL] return new DateTime(0); [EOL] } [EOL] public DateTime getEnd() { [EOL] return new DateTime(24 * 60 * 60 * 1000); // 1 day in milliseconds [EOL] } [EOL] public Chronology getChronology() { [EOL] return ISOChronology.getInstanceUTC(); [EOL] } [EOL] public boolean contains(ReadableInstant instant) { [EOL] return (instant.getMillis() >= getStart().getMillis()) && (instant.getMillis() < getEnd().getMillis()); [EOL] } [EOL] public boolean overlaps(ReadableInterval interval) { [EOL] return interval.getStart().getMillis() < getEnd().getMillis() && interval.getEnd().getMillis() > getStart().getMillis(); [EOL] } [EOL] }; [EOL] Days result = Time.daysIn(interval); [EOL] assertEquals(Days.days(1), result); [EOL] }
public void testMinus_Zero() { [EOL] Days days = Days.days(10); [EOL] Days result = days.minus(0); [EOL] assertEquals(10, result.getDays()); [EOL] }
public void testMinus_Positive() { [EOL] Days days = Days.days(10); [EOL] Days result = days.minus(5); [EOL] assertEquals(5, result.getDays()); [EOL] }
public void testMinus_Negative() { [EOL] Days days = Days.days(10); [EOL] Days result = days.minus(-5); [EOL] assertEquals(15, result.getDays()); [EOL] }
public void testMinusWithNull() { [EOL] Days days = Days.of(5); [EOL] Days result = days.minus(null); [EOL] assertEquals(5, result.getValue()); [EOL] }
public void testMinusWithNonNullDays() { [EOL] Days days = Days.of(5); [EOL] Days result = days.minus(Days.of(3)); [EOL] assertEquals(2, result.getValue()); [EOL] }
public static MonthDay now(DateTimeZone zone) { [EOL] if (zone == null) { [EOL] throw new NullPointerException("Zone must not be null"); [EOL] } [EOL] return new MonthDay(zone); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testFromCalendarFields_withNullCalendar() { [EOL] try { [EOL] MonthDay.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFields_withValidCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.JANUARY); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 1); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(1, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayConstructorWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] assertEquals(zone, monthDay.getChronology().getZone()); [EOL] }
public void testMonthDayConstructorWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayConstructorWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayConstructorWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayConstructorWithObject() { [EOL] Instant instant = new Instant(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayConstructorWithObjectAndChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayConstructorWithMonthAndDay() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertNotNull(monthDay); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayConstructorWithMonthDayAndChronology() { [EOL] int monthOfYear = 6; [EOL] int dayOfMonth = 15; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayNow() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] assertEquals(zone, monthDay.getChronology().getZone()); [EOL] }
public void testMonthDayNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayParseString() { [EOL] String str = "--06-15"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertNotNull(monthDay); [EOL] assertEquals(6, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayParseStringWithFormatter() { [EOL] String str = "06-15"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("MM-dd"); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertNotNull(monthDay); [EOL] assertEquals(6, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.JUNE); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 15); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(monthDay); [EOL] assertEquals(6, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayFromDateFields() { [EOL] Date date = new Date(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] calendar.set(Calendar.MONTH, Calendar.JUNE); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 15); [EOL] date = calendar.getTime(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertNotNull(monthDay); [EOL] assertEquals(6, monthDay.getMonthOfYear()); [EOL] assertEquals(15, monthDay.getDayOfMonth()); [EOL] }
public MonthDay(DateTimeZone zone) { [EOL] super(ISOChronology.getInstance(zone)); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testMonthDayLongChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] long instant = chronology.set(2023, 4, 5, 0, 0, 0, 0); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayDefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayObjectConstructor() { [EOL] Object instant = new LocalDate(2023, 4, 5).toDateTimeAtStartOfDay().toDate(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayObjectChronologyConstructor() { [EOL] Object instant = new LocalDate(2023, 4, 5).toDateTimeAtStartOfDay().toDate(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntConstructor() { [EOL] MonthDay monthDay = new MonthDay(4, 5); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(4, 5, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayNow() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayNowZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayParseString() { [EOL] String str = "--04-05"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayParseStringFormatter() { [EOL] String str = "04-05"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("MM-dd"); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.APRIL); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 5); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayFromDateFields() { [EOL] Date date = new GregorianCalendar(2023, Calendar.APRIL, 5).getTime(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(5, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_Object_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] Object instant = new LocalDate(2023, 4, 1).toDateTimeAtStartOfDay().toDate(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_DefaultConstructor() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Zone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = new MonthDay(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Long() { [EOL] long instant = new LocalDate(2023, 4, 1).toDateTimeAtStartOfDay().getMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_Long_Chronology() { [EOL] long instant = new LocalDate(2023, 4, 1).toDateTimeAtStartOfDay().getMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_Object() { [EOL] Object instant = new LocalDate(2023, 4, 1).toDateTimeAtStartOfDay().toDate(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_IntInt() { [EOL] MonthDay monthDay = new MonthDay(4, 1); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_IntInt_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = new MonthDay(4, 1, chronology); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_Now() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Now_Zone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Now_Chronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDay_Parse_String() { [EOL] String str = "04-01"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_Parse_String_Formatter() { [EOL] String str = "04-01"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("MM-dd"); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_FromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.MONTH, Calendar.APRIL); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 1); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDay_FromDateFields() { [EOL] Date date = new GregorianCalendar(2023, Calendar.APRIL, 1).getTime(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertEquals(4, monthDay.getMonthOfYear()); [EOL] assertEquals(1, monthDay.getDayOfMonth()); [EOL] }
public void testReadResolve_UTCChronology() { [EOL] MonthDay monthDayUTC = new MonthDay(DateTimeZone.UTC); [EOL] Object resolved = monthDayUTC.readResolve(); [EOL] assertSame("Expected same object as it has UTC chronology", monthDayUTC, resolved); [EOL] }
public void testReadResolve_NonUTCChronology() { [EOL] DateTimeZone nonUTC = DateTimeZone.forID("Europe/Paris"); [EOL] MonthDay monthDayNonUTC = new MonthDay(nonUTC); [EOL] Object resolved = monthDayNonUTC.readResolve(); [EOL] assertNotSame("Expected different object as it has non-UTC chronology", monthDayNonUTC, resolved); [EOL] assertTrue("Expected instance of MonthDay", resolved instanceof MonthDay); [EOL] assertEquals("Expected UTC chronology", DateTimeZone.UTC, ((MonthDay) resolved).getChronology().getZone()); [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] MonthDay original = new MonthDay(); [EOL] Chronology originalChronology = original.getChronology(); [EOL] MonthDay result = original.withChronologyRetainFields(originalChronology); [EOL] assertSame("Should be the same object as the chronology is the same", original, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] MonthDay original = new MonthDay(); [EOL] Chronology newChronology = ISOChronology.getInstanceUTC(); [EOL] if (original.getChronology().equals(newChronology)) { [EOL] newChronology = BuddhistChronology.getInstance(); [EOL] } [EOL] MonthDay result = original.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Should not be the same object as the chronology is different", original, result); [EOL] assertEquals("The new MonthDay should have the same month of year", original.getMonthOfYear(), result.getMonthOfYear()); [EOL] assertEquals("The new MonthDay should have the same day of month", original.getDayOfMonth(), result.getDayOfMonth()); [EOL] assertNotEquals("The new MonthDay should have a different chronology", original.getChronology(), result.getChronology()); [EOL] }
public MonthDay withField(DateTimeFieldType fieldType, int value) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (value == getValue(index)) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).set(this, index, newValues, value); [EOL] return new MonthDay(this, newValues); [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testWithPeriodAdded_NullPeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay result = monthDay.withPeriodAdded(null, 1); [EOL] assertEquals("withPeriodAdded should return the same instance when period is null", monthDay, result); [EOL] } [EOL] public void testWithPeriodAdded_ZeroScalar() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] ReadablePeriod period = new Period().withMonths(1); [EOL] MonthDay result = monthDay.withPeriodAdded(period, 0); [EOL] assertEquals("withPeriodAdded should return the same instance when scalar is 0", monthDay, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodPositiveScalar() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] ReadablePeriod period = new Period().withMonths(1); [EOL] MonthDay result = monthDay.withPeriodAdded(period, 1); [EOL] assertNotEquals("withPeriodAdded should not return the same instance for non-null period and positive scalar", monthDay, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodNegativeScalar() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] ReadablePeriod period = new Period().withMonths(1); [EOL] MonthDay result = monthDay.withPeriodAdded(period, -1); [EOL] assertNotEquals("withPeriodAdded should not return the same instance for non-null period and negative scalar", monthDay, result); [EOL] }
public void testPlus_withPeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] ReadablePeriod period = new Period().withMonths(1); [EOL] MonthDay newMonthDay = monthDay.plus(period); [EOL] assertNotSame(monthDay, newMonthDay); [EOL] assertEquals(monthDay.getMonthOfYear() + 1, newMonthDay.getMonthOfYear()); [EOL] }
public void testPlus_withNullPeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay newMonthDay = monthDay.plus(null); [EOL] assertSame(monthDay, newMonthDay); [EOL] }
public void testMinus_withPeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] ReadablePeriod period = new Period().withMonths(1); [EOL] MonthDay result = monthDay.minus(period); [EOL] assertNotNull(result); [EOL] assertNotSame(monthDay, result); [EOL] assertEquals(monthDay.minusMonths(1), result); [EOL] }
public void testMinus_withNullPeriod() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay result = monthDay.minus(null); [EOL] assertNotNull(result); [EOL] assertSame(monthDay, result); [EOL] }
public void testGetMonthDay() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] MonthDay result = monthDay.getMonthDay(); [EOL] assertNotNull(result); [EOL] }
public void testMonthDayWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayFromInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] assertEquals(instant, monthDay.toDateTimeAtCurrentTime().getMillis()); [EOL] }
public void testMonthDayFromInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayFromObject() { [EOL] Object instant = new Date(); [EOL] MonthDay monthDay = new MonthDay(instant); [EOL] assertNotNull(monthDay); [EOL] }
public void testMonthDayFromObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(instant, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testMonthDayWithMonthAndDay() { [EOL] int monthOfYear = 1; [EOL] int dayOfMonth = 1; [EOL] MonthDay monthDay = new MonthDay(monthOfYear, dayOfMonth); [EOL] assertNotNull(monthDay); [EOL] assertEquals(monthOfYear, monthDay.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, monthDay.getDayOfMonth()); [EOL] }
public void testMonthDayWithMonthDayAndChronology() { [EOL] MonthDay partial = new MonthDay(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = new MonthDay(partial, chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testNow() { [EOL] MonthDay monthDay = MonthDay.now(); [EOL] assertNotNull(monthDay); [EOL] }
public void testNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] MonthDay monthDay = MonthDay.now(zone); [EOL] assertNotNull(monthDay); [EOL] assertEquals(zone, monthDay.getChronology().getZone()); [EOL] }
public void testNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MonthDay monthDay = MonthDay.now(chronology); [EOL] assertNotNull(monthDay); [EOL] assertEquals(chronology, monthDay.getChronology()); [EOL] }
public void testParseString() { [EOL] String str = "--12-03"; [EOL] MonthDay monthDay = MonthDay.parse(str); [EOL] assertNotNull(monthDay); [EOL] assertEquals(12, monthDay.getMonthOfYear()); [EOL] assertEquals(3, monthDay.getDayOfMonth()); [EOL] }
public void testParseStringWithFormatter() { [EOL] String str = "--12-03"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("--MM-dd"); [EOL] MonthDay monthDay = MonthDay.parse(str, formatter); [EOL] assertNotNull(monthDay); [EOL] assertEquals(12, monthDay.getMonthOfYear()); [EOL] assertEquals(3, monthDay.getDayOfMonth()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] MonthDay monthDay = MonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(monthDay); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, monthDay.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), monthDay.getDayOfMonth()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] MonthDay monthDay = MonthDay.fromDateFields(date); [EOL] assertNotNull(monthDay); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, monthDay.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), monthDay.getDayOfMonth()); [EOL] }
public void testAddWrapFieldToCopy_ValueToAdd() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int valueToAdd = 1; [EOL] MonthDay result = monthDay.addWrapFieldToCopy(valueToAdd); [EOL] assertNotNull(result); [EOL] assertNotSame(monthDay, result); [EOL] }
public void testAddWrapFieldToCopy_MaxValue() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int valueToAdd = Integer.MAX_VALUE; [EOL] MonthDay result = monthDay.addWrapFieldToCopy(valueToAdd); [EOL] assertNotNull(result); [EOL] assertNotSame(monthDay, result); [EOL] }
public void testAddWrapFieldToCopy_MinValue() { [EOL] MonthDay monthDay = new MonthDay(); [EOL] int valueToAdd = Integer.MIN_VALUE; [EOL] MonthDay result = monthDay.addWrapFieldToCopy(valueToAdd); [EOL] assertNotNull(result); [EOL] assertNotSame(monthDay, result); [EOL] }
public void testSetCopy_ValidValue() { [EOL] MonthDay original = new MonthDay(); [EOL] int newValue = 5; // Assuming 5 is a valid value for the field [EOL] MonthDay updated = original.setCopy(newValue); [EOL] assertNotSame(original, updated); [EOL] assertEquals(newValue, updated.get(original.getFieldType(0).getFieldIndex())); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] MonthDay original = new MonthDay(); [EOL] int invalidValue = -1; // Assuming -1 is an invalid value for the field [EOL] try { [EOL] original.setCopy(invalidValue); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateTimeWithNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] LocalDateTime dateTime = new LocalDateTime(instant, null); [EOL] assertNotNull(dateTime); [EOL] assertEquals(DateTimeUtils.getChronology(null).withUTC(), dateTime.getChronology()); [EOL] }
public void testLocalDateTimeWithNonNullChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] LocalDateTime dateTime = new LocalDateTime(instant, chronology); [EOL] assertNotNull(dateTime); [EOL] assertEquals(chronology.withUTC(), dateTime.getChronology()); [EOL] }
public void testLocalDateTimeWithNullInstant() { [EOL] Object instant = null; [EOL] try { [EOL] new LocalDateTime(instant); [EOL] fail("Should have thrown IllegalArgumentException for null instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateTimeWithNonNullInstant() { [EOL] Object instant = new Date(); [EOL] LocalDateTime result = new LocalDateTime(instant); [EOL] assertNotNull(result); [EOL] }
public void testLocalDateTimeWithNullInstantAndChronology() { [EOL] try { [EOL] new LocalDateTime(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateTimeWithValidInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] LocalDateTime result = new LocalDateTime(instant, null); [EOL] assertNotNull(result); [EOL] assertEquals(instant.getMillis(), result.toDateTime().getMillis()); [EOL] }
public void testLocalDateTimeWithValidInstantAndChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] LocalDateTime result = new LocalDateTime(instant, chronology); [EOL] assertNotNull(result); [EOL] assertEquals(instant.getMillis(), result.toDateTime(chronology).getMillis()); [EOL] }
public void testGetFieldYear() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(YEAR, chrono); [EOL] assertEquals(chrono.year(), field); [EOL] }
public void testGetFieldMonthOfYear() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(MONTH_OF_YEAR, chrono); [EOL] assertEquals(chrono.monthOfYear(), field); [EOL] }
public void testGetFieldDayOfMonth() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(DAY_OF_MONTH, chrono); [EOL] assertEquals(chrono.dayOfMonth(), field); [EOL] }
public void testGetFieldMillisOfDay() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(MILLIS_OF_DAY, chrono); [EOL] assertEquals(chrono.millisOfDay(), field); [EOL] }
public void testGetFieldInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] getField(-1, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testToLocalDate() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, 0, 0); [EOL] LocalDate localDate = dateTime.toLocalDate(); [EOL] assertEquals(new LocalDate(2023, 4, 1), localDate); [EOL] }
public void testToDateWithTimeZone() { [EOL] TimeZone timeZoneUTC = TimeZone.getTimeZone("UTC"); [EOL] int expectedYear = 2021; // Use appropriate values for the test [EOL] int expectedMonth = Calendar.JANUARY; // Calendar months are 0-based [EOL] int expectedDay = 1; [EOL] int expectedHour = 12; [EOL] int expectedMinute = 0; [EOL] int expectedSecond = 0; [EOL] int expectedMillis = 500; [EOL] setupDate(expectedYear, expectedMonth + 1, expectedDay, expectedHour, expectedMinute, expectedSecond, expectedMillis); [EOL] Date result = toDate(timeZoneUTC); [EOL] Calendar expectedCalendar = Calendar.getInstance(timeZoneUTC); [EOL] expectedCalendar.set(expectedYear, expectedMonth, expectedDay, expectedHour, expectedMinute, expectedSecond); [EOL] expectedCalendar.set(Calendar.MILLISECOND, expectedMillis); [EOL] assertEquals(expectedCalendar.getTimeInMillis(), result.getTime()); [EOL] TimeZone timeZoneEST = TimeZone.getTimeZone("EST"); [EOL] setupDate(expectedYear, expectedMonth + 1, expectedDay, expectedHour, expectedMinute, expectedSecond, expectedMillis); [EOL] result = toDate(timeZoneEST); [EOL] Calendar expectedCalendarEST = Calendar.getInstance(timeZoneEST); [EOL] expectedCalendarEST.set(expectedYear, expectedMonth, expectedDay, expectedHour, expectedMinute, expectedSecond); [EOL] expectedCalendarEST.set(Calendar.MILLISECOND, expectedMillis); [EOL] assertEquals(correctDstTransition(expectedCalendarEST.getTime(), timeZoneEST).getTime(), result.getTime()); [EOL] }
public void testWithLocalMillis_SameMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] LocalDateTime dateTime = new LocalDateTime(currentMillis); [EOL] LocalDateTime result = dateTime.withLocalMillis(currentMillis); [EOL] assertSame(dateTime, result); [EOL] }
public void testWithLocalMillis_DifferentMillis() { [EOL] long currentMillis = System.currentTimeMillis(); [EOL] LocalDateTime dateTime = new LocalDateTime(currentMillis); [EOL] long newMillis = currentMillis + 1000; // Assuming newMillis is different [EOL] LocalDateTime result = dateTime.withLocalMillis(newMillis); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(new LocalDateTime(newMillis), result); [EOL] }
public void testWithTime_ValidTime() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 15; [EOL] int millisOfSecond = 250; [EOL] LocalDateTime updatedDateTime = dateTime.withTime(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertEquals(hourOfDay, updatedDateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, updatedDateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, updatedDateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, updatedDateTime.getMillisOfSecond()); [EOL] }
public void testWithTime_InvalidHour() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int invalidHourOfDay = 25; [EOL] try { [EOL] dateTime.withTime(invalidHourOfDay, 0, 0, 0); [EOL] fail("Should have thrown an exception for invalid hour of day"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithTime_InvalidMinute() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int invalidMinuteOfHour = 60; [EOL] try { [EOL] dateTime.withTime(0, invalidMinuteOfHour, 0, 0); [EOL] fail("Should have thrown an exception for invalid minute of hour"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithTime_InvalidSecond() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int invalidSecondOfMinute = 60; [EOL] try { [EOL] dateTime.withTime(0, 0, invalidSecondOfMinute, 0); [EOL] fail("Should have thrown an exception for invalid second of minute"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithTime_InvalidMillis() { [EOL] LocalDateTime dateTime = new LocalDateTime(); [EOL] int invalidMillisOfSecond = 1000; [EOL] try { [EOL] dateTime.withTime(0, 0, 0, invalidMillisOfSecond); [EOL] fail("Should have thrown an exception for invalid millis of second"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithFieldAdded_NullFieldType_ThrowsIllegalArgumentException() { [EOL] LocalDateTime testDateTime = LocalDateTime.now(); [EOL] try { [EOL] testDateTime.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount_ReturnsSame() { [EOL] LocalDateTime testDateTime = LocalDateTime.now(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); [EOL] LocalDateTime resultDateTime = testDateTime.withFieldAdded(fieldType, 0); [EOL] assertSame("Expected the same LocalDateTime instance", testDateTime, resultDateTime); [EOL] }
public void testWithFieldAdded_NonZeroAmount_ReturnsNew() { [EOL] LocalDateTime testDateTime = LocalDateTime.now(); [EOL] DurationFieldType fieldType = DurationFieldType.days(); [EOL] int amountToAdd = 5; [EOL] LocalDateTime resultDateTime = testDateTime.withFieldAdded(fieldType, amountToAdd); [EOL] assertNotSame("Expected a different LocalDateTime instance", testDateTime, resultDateTime); [EOL] assertTrue("The time should be after adding days", resultDateTime.isAfter(testDateTime)); [EOL] }
public void testMinusDays_ZeroDays() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusDays(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusDays_NegativeDays() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusDays(-1); [EOL] assertNotEquals(dateTime, result); [EOL] assertTrue(result.isBefore(dateTime)); [EOL] }
public void testMinusDays_PositiveDays() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusDays(1); [EOL] assertNotEquals(dateTime, result); [EOL] assertTrue(result.isAfter(dateTime)); [EOL] }
public void testMonthOfYear() { [EOL] DateTime testDateTime = new DateTime(); [EOL] Property monthProperty = testDateTime.monthOfYear(); [EOL] assertNotNull("Month of year property should not be null", monthProperty); [EOL] assertEquals("Property should be the same as the one from getChronology", testDateTime.getChronology().monthOfYear(), monthProperty.getField()); [EOL] assertEquals("Property should be linked to the correct DateTime", testDateTime, monthProperty.getReadableInstant()); [EOL] }
public void testPropertyWithValidArguments() { [EOL] LocalDateTime instant = LocalDateTime.now(); [EOL] DateTimeField field = DateTimeFieldType.dayOfMonth(); [EOL] Property property = new Property(instant, field); [EOL] assertNotNull(property); [EOL] assertEquals(instant, property.iInstant); [EOL] assertEquals(field, property.iField); [EOL] }
public void testAddToCopy_PositiveValue() { [EOL] LocalDateTime initial = LocalDateTime.now(); [EOL] int valueToAdd = 5; [EOL] LocalDateTime result = initial.addToCopy(valueToAdd); [EOL] long expectedMillis = initial.toDateTime().getMillis() + valueToAdd; // Assuming iField represents a millisecond field [EOL] assertEquals(new LocalDateTime(expectedMillis), result); [EOL] }
public void testAddToCopy_NegativeValue() { [EOL] LocalDateTime initial = LocalDateTime.now(); [EOL] int valueToAdd = -5; [EOL] LocalDateTime result = initial.addToCopy(valueToAdd); [EOL] long expectedMillis = initial.toDateTime().getMillis() + valueToAdd; // Assuming iField represents a millisecond field [EOL] assertEquals(new LocalDateTime(expectedMillis), result); [EOL] }
public void testAddToCopy_ZeroValue() { [EOL] LocalDateTime initial = LocalDateTime.now(); [EOL] int valueToAdd = 0; [EOL] LocalDateTime result = initial.addToCopy(valueToAdd); [EOL] assertEquals(initial, result); [EOL] }
public void testAddWrapFieldToCopy_PositiveValue() { [EOL] LocalDateTime initial = LocalDateTime.now(); [EOL] DateTimeField field = DateTimeFieldType.hourOfDay().getField(initial.getChronology()); [EOL] LocalDateTimeProperty property = new LocalDateTimeProperty(initial, field); [EOL] int valueToAdd = 5; [EOL] LocalDateTime result = property.addWrapFieldToCopy(valueToAdd); [EOL] int expectedHourOfDay = (initial.getHourOfDay() + valueToAdd) % 24; [EOL] assertEquals(expectedHourOfDay, result.getHourOfDay()); [EOL] }
public void testAddWrapFieldToCopy_NegativeValue() { [EOL] LocalDateTime initial = LocalDateTime.now(); [EOL] DateTimeField field = DateTimeFieldType.hourOfDay().getField(initial.getChronology()); [EOL] LocalDateTimeProperty property = new LocalDateTimeProperty(initial, field); [EOL] int valueToAdd = -5; [EOL] LocalDateTime result = property.addWrapFieldToCopy(valueToAdd); [EOL] int expectedHourOfDay = (initial.getHourOfDay() + (24 + valueToAdd)) % 24; [EOL] assertEquals(expectedHourOfDay, result.getHourOfDay()); [EOL] }
public void testAddWrapFieldToCopy_ZeroValue() { [EOL] LocalDateTime initial = LocalDateTime.now(); [EOL] DateTimeField field = DateTimeFieldType.hourOfDay().getField(initial.getChronology()); [EOL] LocalDateTimeProperty property = new LocalDateTimeProperty(initial, field); [EOL] int valueToAdd = 0; [EOL] LocalDateTime result = property.addWrapFieldToCopy(valueToAdd); [EOL] assertEquals(initial.getHourOfDay(), result.getHourOfDay()); [EOL] }
public void testGetChronologyWithNonNullChronology() { [EOL] Object object = new GregorianCalendar(); [EOL] Chronology expectedChronology = ISOChronology.getInstance(); [EOL] Chronology actualChronology = getChronology(object, expectedChronology); [EOL] assertSame(expectedChronology, actualChronology); [EOL] }
public void testGetChronologyWithNullChronologyAndValidCalendar() { [EOL] Calendar cal = new GregorianCalendar(); [EOL] cal.setTimeZone(TimeZone.getTimeZone("UTC")); [EOL] Chronology actualChronology = getChronology(cal, null); [EOL] assertNotNull(actualChronology); [EOL] assertTrue(actualChronology instanceof GregorianChronology); [EOL] }
public void testGetChronologyWithNullChronologyAndInvalidTimeZone() { [EOL] Calendar cal = new GregorianCalendar() { [EOL] public TimeZone getTimeZone() { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] }; [EOL] Chronology actualChronology = getChronology(cal, null); [EOL] assertNotNull(actualChronology); [EOL] assertSame(DateTimeZone.getDefault(), ((BaseChronology) actualChronology).getZone()); [EOL] }
public void testDecoratedDurationFieldWithNullField() { [EOL] try { [EOL] new DecoratedDurationField(null, DurationFieldType.seconds()); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testDecoratedDurationFieldWithUnsupportedField() { [EOL] DurationField field = new UnsupportedDurationField(DurationFieldType.seconds()); [EOL] try { [EOL] new DecoratedDurationField(field, DurationFieldType.seconds()); [EOL] fail("Should have thrown IllegalArgumentException for unsupported field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The field must be supported", ex.getMessage()); [EOL] } [EOL] }
public void testDecoratedDurationFieldWithSupportedField() { [EOL] DurationField field = new PreciseDurationField(DurationFieldType.seconds(), 1000); [EOL] DecoratedDurationField decoratedField = new DecoratedDurationField(field, DurationFieldType.seconds()); [EOL] assertNotNull(decoratedField); [EOL] assertEquals(field, decoratedField.getField()); [EOL] }
public void testGetPrinter() { [EOL] DateTimePrinter expectedPrinter = new DateTimePrinter(); // Assuming DateTimePrinter has a constructor [EOL] MyClass myClassInstance = new MyClass(expectedPrinter); // Assuming MyClass is the class containing getPrinter and it has a constructor that accepts a DateTimePrinter [EOL] DateTimePrinter actualPrinter = myClassInstance.getPrinter(); [EOL] assertEquals(expectedPrinter, actualPrinter); [EOL] }
public void testGetParser() { [EOL] DateTimeParser expectedParser = new DateTimeParser(); // Assuming there's a constructor for DateTimeParser [EOL] MyClass myClassInstance = new MyClass(expectedParser); // Assuming MyClass is the class containing getParser and it has a constructor that accepts a DateTimeParser [EOL] DateTimeParser actualParser = myClassInstance.getParser(); [EOL] assertEquals(expectedParser, actualParser); [EOL] }
public void testGetChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chrono = dateTime.getChronology(); [EOL] assertNotNull(chrono); [EOL] }
public void testWithZoneUTC_Coverage() { [EOL] DateTimeFormatter formatter = new DateTimeFormatterBuilder().toFormatter(); [EOL] DateTimeFormatter utcFormatter = formatter.withZoneUTC(); [EOL] assertNotNull(utcFormatter); [EOL] assertEquals(DateTimeZone.UTC, utcFormatter.getZone()); [EOL] }
public void testPrintToWithNullInstant() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] try { [EOL] printTo(out, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullInstant() throws IOException { [EOL] StringWriter out = new StringWriter(); [EOL] ReadableInstant instant = new DateTime(); [EOL] printTo(out, instant); [EOL] assertFalse(out.toString().isEmpty()); [EOL] }
public void printTo_testWithNonNullBuffer() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] printTo(buffer, instant); [EOL] } [EOL] public void printTo_testWithNullBuffer() { [EOL] long instant = System.currentTimeMillis(); [EOL] try { [EOL] printTo(null, instant); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPrintToWithValidWriterAndInstant() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] long instant = System.currentTimeMillis(); [EOL] printTo(writer, instant); [EOL] assertFalse(writer.toString().isEmpty()); [EOL] }
public void testPrintToWithNullWriter() { [EOL] long instant = System.currentTimeMillis(); [EOL] try { [EOL] printTo(null, instant); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IOException e) { [EOL] fail("Should not have thrown IOException"); [EOL] } [EOL] }
public void testPrintToWithNullPartial() throws IOException { [EOL] try { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(); [EOL] dtf.printTo(new StringWriter(), null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintToWithNonNullPartial() throws IOException { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(); [EOL] ReadablePartial mockPartial = new LocalDate(); [EOL] StringWriter out = new StringWriter(); [EOL] dtf.printTo(out, mockPartial); [EOL] assertFalse(out.toString().isEmpty()); [EOL] }
public void testPrintWithValidInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] String result = print(instant); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testPrintWithNegativeInstant() { [EOL] long instant = -System.currentTimeMillis(); [EOL] String result = print(instant); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testPrintToWithPositiveOffset() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] long instant = 1582605045123L; // Example timestamp [EOL] Chronology mockChronology = ISOChronology.getInstanceUTC(); [EOL] printTo(mockWriter, instant, mockChronology); [EOL] String result = mockWriter.toString(); [EOL] } [EOL] public void testPrintToWithNegativeOffset() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] long instant = 1582605045123L; // Example timestamp [EOL] Chronology mockChronology = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone mockZone = DateTimeZone.forOffsetHours(-1); [EOL] when(mockChronology.getZone()).thenReturn(mockZone); [EOL] printTo(mockWriter, instant, mockChronology); [EOL] String result = mockWriter.toString(); [EOL] } [EOL] public void testPrintToWithNoOffset() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] long instant = 1582605045123L; // Example timestamp [EOL] Chronology mockChronology = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone mockZone = DateTimeZone.UTC; [EOL] when(mockChronology.getZone()).thenReturn(mockZone); [EOL] printTo(mockWriter, instant, mockChronology); [EOL] String result = mockWriter.toString(); [EOL] } [EOL] public void testPrintToWithOffsetChangeCausingWraparound() throws IOException { [EOL] Writer mockWriter = new StringWriter(); [EOL] long instant = Long.MAX_VALUE; // Timestamp close to Long.MAX_VALUE to cause wraparound [EOL] Chronology mockChronology = ISOChronology.getInstanceUTC(); [EOL] DateTimeZone mockZone = DateTimeZone.forOffsetHours(18); [EOL] when(mockChronology.getZone()).thenReturn(mockZone); [EOL] printTo(mockWriter, instant, mockChronology); [EOL] String result = mockWriter.toString(); [EOL] }
public void testParseInto_NullInstant_ThrowsIllegalArgumentException() { [EOL] try { [EOL] parseInto(null, "2023-04-01T00:00:00Z", 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Instant must not be null", e.getMessage()); [EOL] } [EOL] }
public void testParseInto_ValidInstantAndText_ParsesCorrectly() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_InvalidText_ReturnsErrorPosition() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "Invalid Date Time"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithOffsetParsed_UpdatesOffset() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00+02:00"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithZone_UpdatesZone() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z[Europe/London]"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseMillis_Success() { [EOL] String text = "2023-04-01T00:00:00Z"; // Assuming this is a valid date-time string for the parser [EOL] long expectedMillis = /* some expected millis value, e.g., the result of parsing the above text */; [EOL] long actualMillis = parseMillis(text); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testParseMillis_FailureDueToIncompleteParsing() { [EOL] String text = "2023-04-01T00"; // Incomplete date-time string [EOL] try { [EOL] parseMillis(text); [EOL] fail("Should have thrown IllegalArgumentException due to incomplete parsing"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMillis_FailureDueToInvalidFormat() { [EOL] String text = "Invalid date-time string"; [EOL] try { [EOL] parseMillis(text); [EOL] fail("Should have thrown IllegalArgumentException due to invalid format"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMutableDateTimeWithCompleteParse() { [EOL] String text = "2023-03-20T10:15:30"; [EOL] MutableDateTime result = parseMutableDateTime(text); [EOL] assertNotNull(result); [EOL] assertEquals("Parsed date is incorrect", new MutableDateTime(2023, 3, 20, 10, 15, 30, 0), result); [EOL] }
public void testParseMutableDateTimeWithIncompleteParse() { [EOL] String text = "2023-03-20T"; [EOL] try { [EOL] parseMutableDateTime(text); [EOL] fail("Should have thrown IllegalArgumentException due to incomplete parse"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMutableDateTimeWithInvalidFormat() { [EOL] String text = "invalid-date-time"; [EOL] try { [EOL] parseMutableDateTime(text); [EOL] fail("Should have thrown IllegalArgumentException due to invalid format"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testValidateWithValidValues() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] validValues = new int[] { 5, 10, 15 }; // Assuming these are within the valid range for the fields [EOL] validate(mockPartial, validValues); [EOL] } [EOL] public void testValidateWithMinimumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesAtMinimum = new int[] { 1, 10, 15 }; // Assuming 1 is the minimum value for the first field [EOL] validate(mockPartial, valuesAtMinimum); [EOL] } [EOL] public void testValidateWithMaximumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesAtMaximum = new int[] { 5, 20, 15 }; // Assuming 20 is the maximum value for the second field [EOL] validate(mockPartial, valuesAtMaximum); [EOL] } [EOL] public void testValidateWithBelowMinimumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesBelowMinimum = new int[] { 0, 10, 15 }; // Assuming 0 is below the minimum value for the first field [EOL] try { [EOL] validate(mockPartial, valuesBelowMinimum); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] } [EOL] public void testValidateWithAboveMaximumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithValidRange(); [EOL] int[] valuesAboveMaximum = new int[] { 5, 25, 15 }; // Assuming 25 is above the maximum value for the second field [EOL] try { [EOL] validate(mockPartial, valuesAboveMaximum); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testValidateWithDynamicMinimumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithDynamicRange(); [EOL] int[] dynamicValuesAtMinimum = new int[] { 3, 10, 15 }; // Assuming 3 is the dynamic minimum value for the first field [EOL] validate(mockPartial, dynamicValuesAtMinimum); [EOL] } [EOL] public void testValidateWithDynamicMaximumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithDynamicRange(); [EOL] int[] dynamicValuesAtMaximum = new int[] { 5, 18, 15 }; // Assuming 18 is the dynamic maximum value for the second field [EOL] validate(mockPartial, dynamicValuesAtMaximum); [EOL] } [EOL] public void testValidateWithBelowDynamicMinimumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithDynamicRange(); [EOL] int[] valuesBelowDynamicMinimum = new int[] { 2, 10, 15 }; // Assuming 2 is below the dynamic minimum value for the first field [EOL] try { [EOL] validate(mockPartial, valuesBelowDynamicMinimum); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] } [EOL] public void testValidateWithAboveDynamicMaximumValue() { [EOL] ReadablePartial mockPartial = createMockPartialWithDynamicRange(); [EOL] int[] valuesAboveDynamicMaximum = new int[] { 5, 19, 15 }; // Assuming 19 is above the dynamic maximum value for the second field [EOL] try { [EOL] validate(mockPartial, valuesAboveDynamicMaximum); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public String getName() { [EOL] return "millis"; [EOL] }
public final boolean isPrecise() { [EOL] return true; [EOL] }
public int testGetValueWithZeroDuration() { [EOL] int result = getValue(0L); [EOL] assert result == 0 : "Expected result to be 0 for zero duration"; [EOL] }
public int testGetValueWithPositiveDuration() { [EOL] int result = getValue(123456789L); [EOL] assert result == 123456789 : "Expected result to match the positive duration value"; [EOL] }
public int testGetValueWithNegativeDuration() { [EOL] int result = getValue(-123456789L); [EOL] assert result == -123456789 : "Expected result to match the negative duration value"; [EOL] }
public int testGetValueWithMaxIntDuration() { [EOL] int result = getValue((long) Integer.MAX_VALUE); [EOL] assert result == Integer.MAX_VALUE : "Expected result to be Integer.MAX_VALUE for max int duration"; [EOL] }
public int testGetValueWithMinIntDuration() { [EOL] int result = getValue((long) Integer.MIN_VALUE); [EOL] assert result == Integer.MIN_VALUE : "Expected result to be Integer.MIN_VALUE for min int duration"; [EOL] }
public int testGetValueWithOverflowDuration() { [EOL] try { [EOL] getValue(Long.MAX_VALUE); [EOL] assert false : "Expected an exception for duration causing overflow"; [EOL] } catch (ArithmeticException e) { [EOL] assert true : "Expected ArithmeticException for duration causing overflow"; [EOL] } [EOL] }
public int testGetValueWithUnderflowDuration() { [EOL] try { [EOL] getValue(Long.MIN_VALUE); [EOL] assert false : "Expected an exception for duration causing underflow"; [EOL] } catch (ArithmeticException e) { [EOL] assert true : "Expected ArithmeticException for duration causing underflow"; [EOL] } [EOL] }
public long getMillisTestWithValueZero() { [EOL] Time time = new Time(); [EOL] long result = time.getMillis(0); [EOL] assertEquals(0, result); [EOL] }
public long getMillisTestWithPositiveValue() { [EOL] Time time = new Time(); [EOL] long result = time.getMillis(123); [EOL] assertEquals(123, result); [EOL] }
public long getMillisTestWithNegativeValue() { [EOL] Time time = new Time(); [EOL] long result = time.getMillis(-123); [EOL] assertEquals(-123, result); [EOL] }
public long getMillisTest() { [EOL] long expected = 1000L; [EOL] long actual = getMillis(expected); [EOL] assertEquals(expected, actual); [EOL] }
public long add(long instant, int value) { [EOL] return FieldUtils.safeAdd(instant, value); [EOL] }
public void testGetDifferenceAsLongWithPositiveDifference() { [EOL] long minuendInstant = 10L; [EOL] long subtrahendInstant = 5L; [EOL] long expected = 5L; [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLongWithNegativeDifference() { [EOL] long minuendInstant = 5L; [EOL] long subtrahendInstant = 10L; [EOL] long expected = -5L; [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLongWithNoDifference() { [EOL] long minuendInstant = 5L; [EOL] long subtrahendInstant = 5L; [EOL] long expected = 0L; [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public int hashCode() { [EOL] return (int) getUnitMillis(); [EOL] }
public void testReadResolveForERA() { [EOL] setupWithOrdinal(ERA); [EOL] Object result = readResolve(); [EOL] assertEquals(ERA_TYPE, result); [EOL] } [EOL] public void testReadResolveForYEAR_OF_ERA() { [EOL] setupWithOrdinal(YEAR_OF_ERA); [EOL] Object result = readResolve(); [EOL] assertEquals(YEAR_OF_ERA_TYPE, result); [EOL] } [EOL] public void testReadResolveForCENTURY_OF_ERA() { [EOL] setupWithOrdinal(CENTURY_OF_ERA); [EOL] Object result = readResolve(); [EOL] assertEquals(CENTURY_OF_ERA_TYPE, result); [EOL] } [EOL] public void testReadResolveForYEAR_OF_CENTURY() { [EOL] setupWithOrdinal(YEAR_OF_CENTURY); [EOL] Object result = readResolve(); [EOL] assertEquals(YEAR_OF_CENTURY_TYPE, result); [EOL] } [EOL] public void testReadResolveForYEAR() { [EOL] setupWithOrdinal(YEAR); [EOL] Object result = readResolve(); [EOL] assertEquals(YEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveForDAY_OF_YEAR() { [EOL] setupWithOrdinal(DAY_OF_YEAR); [EOL] Object result = readResolve(); [EOL] assertEquals(DAY_OF_YEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveForMONTH_OF_YEAR() { [EOL] setupWithOrdinal(MONTH_OF_YEAR); [EOL] Object result = readResolve(); [EOL] assertEquals(MONTH_OF_YEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveForDAY_OF_MONTH() { [EOL] setupWithOrdinal(DAY_OF_MONTH); [EOL] Object result = readResolve(); [EOL] assertEquals(DAY_OF_MONTH_TYPE, result); [EOL] } [EOL] public void testReadResolveForWEEKYEAR_OF_CENTURY() { [EOL] setupWithOrdinal(WEEKYEAR_OF_CENTURY); [EOL] Object result = readResolve(); [EOL] assertEquals(WEEKYEAR_OF_CENTURY_TYPE, result); [EOL] } [EOL] public void testReadResolveForWEEKYEAR() { [EOL] setupWithOrdinal(WEEKYEAR); [EOL] Object result = readResolve(); [EOL] assertEquals(WEEKYEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveForWEEK_OF_WEEKYEAR() { [EOL] setupWithOrdinal(WEEK_OF_WEEKYEAR); [EOL] Object result = readResolve(); [EOL] assertEquals(WEEK_OF_WEEKYEAR_TYPE, result); [EOL] } [EOL] public void testReadResolveForDAY_OF_WEEK() { [EOL] setupWithOrdinal(DAY_OF_WEEK); [EOL] Object result = readResolve(); [EOL] assertEquals(DAY_OF_WEEK_TYPE, result); [EOL] } [EOL] public void testReadResolveForHALFDAY_OF_DAY() { [EOL] setupWithOrdinal(HALFDAY_OF_DAY); [EOL] Object result = readResolve(); [EOL] assertEquals(HALFDAY_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForHOUR_OF_HALFDAY() { [EOL] setupWithOrdinal(HOUR_OF_HALFDAY); [EOL] Object result = readResolve(); [EOL] assertEquals(HOUR_OF_HALFDAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForCLOCKHOUR_OF_HALFDAY() { [EOL] setupWithOrdinal(CLOCKHOUR_OF_HALFDAY); [EOL] Object result = readResolve(); [EOL] assertEquals(CLOCKHOUR_OF_HALFDAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForCLOCKHOUR_OF_DAY() { [EOL] setupWithOrdinal(CLOCKHOUR_OF_DAY); [EOL] Object result = readResolve(); [EOL] assertEquals(CLOCKHOUR_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForHOUR_OF_DAY() { [EOL] setupWithOrdinal(HOUR_OF_DAY); [EOL] Object result = readResolve(); [EOL] assertEquals(HOUR_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForMINUTE_OF_DAY() { [EOL] setupWithOrdinal(MINUTE_OF_DAY); [EOL] Object result = readResolve(); [EOL] assertEquals(MINUTE_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForMINUTE_OF_HOUR() { [EOL] setupWithOrdinal(MINUTE_OF_HOUR); [EOL] Object result = readResolve(); [EOL] assertEquals(MINUTE_OF_HOUR_TYPE, result); [EOL] } [EOL] public void testReadResolveForSECOND_OF_DAY() { [EOL] setupWithOrdinal(SECOND_OF_DAY); [EOL] Object result = readResolve(); [EOL] assertEquals(SECOND_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForSECOND_OF_MINUTE() { [EOL] setupWithOrdinal(SECOND_OF_MINUTE); [EOL] Object result = readResolve(); [EOL] assertEquals(SECOND_OF_MINUTE_TYPE, result); [EOL] } [EOL] public void testReadResolveForMILLIS_OF_DAY() { [EOL] setupWithOrdinal(MILLIS_OF_DAY); [EOL] Object result = readResolve(); [EOL] assertEquals(MILLIS_OF_DAY_TYPE, result); [EOL] } [EOL] public void testReadResolveForMILLIS_OF_SECOND() { [EOL] setupWithOrdinal(MILLIS_OF_SECOND); [EOL] Object result = readResolve(); [EOL] assertEquals(MILLIS_OF_SECOND_TYPE, result); [EOL] } [EOL] public void testReadResolveForInvalidOrdinal() { [EOL] setupWithOrdinal(INVALID_ORDINAL); [EOL] Object result = readResolve(); [EOL] assertSame(this, result); [EOL] }
public void testToPeriod() { [EOL] long expectedMillis = 1000L; // Example millis value [EOL] Time time = new Time(expectedMillis); [EOL] Period result = time.toPeriod(); [EOL] assertNotNull("Period should not be null", result); [EOL] assertEquals("Period millis should match expected value", expectedMillis, result.getMillis()); [EOL] }
public void testCompareToWithLesserDuration() { [EOL] ReadableDuration lesserDuration = mock(ReadableDuration.class); [EOL] ReadableDuration currentDuration = mock(ReadableDuration.class); [EOL] when(lesserDuration.getMillis()).thenReturn(1000L); [EOL] when(currentDuration.getMillis()).thenReturn(2000L); [EOL] int result = currentDuration.compareTo(lesserDuration); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareToWithGreaterDuration() { [EOL] ReadableDuration greaterDuration = mock(ReadableDuration.class); [EOL] ReadableDuration currentDuration = mock(ReadableDuration.class); [EOL] when(greaterDuration.getMillis()).thenReturn(3000L); [EOL] when(currentDuration.getMillis()).thenReturn(2000L); [EOL] int result = currentDuration.compareTo(greaterDuration); [EOL] assertEquals(1, result); [EOL] }
public void testCompareToWithEqualDuration() { [EOL] ReadableDuration equalDuration = mock(ReadableDuration.class); [EOL] ReadableDuration currentDuration = mock(ReadableDuration.class); [EOL] when(equalDuration.getMillis()).thenReturn(2000L); [EOL] when(currentDuration.getMillis()).thenReturn(2000L); [EOL] int result = currentDuration.compareTo(equalDuration); [EOL] assertEquals(0, result); [EOL] }
public void testIsEqual_WithNullDuration() { [EOL] Time time = new Time(); [EOL] boolean result = time.isEqual(null); [EOL] assertTrue(result); [EOL] }
public void testIsEqual_WithNonZeroDuration() { [EOL] Time time = new Time(); [EOL] ReadableDuration nonZeroDuration = new Duration(1000); [EOL] boolean result = time.isEqual(nonZeroDuration); [EOL] assertFalse(result); [EOL] }
public void testIsEqual_WithZeroDuration() { [EOL] Time time = new Time(); [EOL] ReadableDuration zeroDuration = Duration.ZERO; [EOL] boolean result = time.isEqual(zeroDuration); [EOL] assertTrue(result); [EOL] }
public void testIsShorterThanWithNullDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] boolean result = testDuration.isShorterThan(null); [EOL] assertFalse(result); [EOL] }
public void testIsShorterThanWithShorterDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] Duration shorterDuration = Duration.ofMinutes(30); [EOL] boolean result = testDuration.isShorterThan(shorterDuration); [EOL] assertTrue(result); [EOL] }
public void testIsShorterThanWithLongerDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] Duration longerDuration = Duration.ofHours(2); [EOL] boolean result = testDuration.isShorterThan(longerDuration); [EOL] assertFalse(result); [EOL] }
public void testIsShorterThanWithEqualDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] Duration equalDuration = Duration.ofHours(1); [EOL] boolean result = testDuration.isShorterThan(equalDuration); [EOL] assertFalse(result); [EOL] }
public void testSubtractWithMinValue() { [EOL] long instant = 1000L; // Example value [EOL] int value = Integer.MIN_VALUE; [EOL] long result = subtract(instant, value); [EOL] assertEquals("Subtract method should handle Integer.MIN_VALUE correctly", expectedValue, result); [EOL] }
public void testSubtractWithPositiveValue() { [EOL] long instant = 1000L; // Example value [EOL] int value = 1; [EOL] long result = subtract(instant, value); [EOL] assertEquals("Subtract method should subtract positive value correctly", 999L, result); [EOL] }
public void testSubtractWithNegativeValue() { [EOL] long instant = 1000L; // Example value [EOL] int value = -1; [EOL] long result = subtract(instant, value); [EOL] assertEquals("Subtract method should add negative value correctly", 1001L, result); [EOL] }
public void testSubtract_MinValue() { [EOL] long instant = 0L; [EOL] try { [EOL] subtract(instant, Long.MIN_VALUE); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Long.MIN_VALUE cannot be negated", e.getMessage()); [EOL] } [EOL] }
public void testSubtract_NegativeValue() { [EOL] long instant = 10L; [EOL] long value = -5L; [EOL] long expected = 15L; [EOL] long result = subtract(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSubtract_PositiveValue() { [EOL] long instant = 10L; [EOL] long value = 5L; [EOL] long expected = 5L; [EOL] long result = subtract(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testDefaultNameProviderConstructor() { [EOL] new DefaultNameProvider(); [EOL] }
public void testGetShortNameWithNullNameSet() { [EOL] String result = getShortName(new Locale("en"), "US", "short"); [EOL] assertNull(result); [EOL] }
public void testGetShortNameWithNonNullNameSet() { [EOL] String result = getShortName(new Locale("en"), "US", "validKey"); [EOL] assertNotNull(result); [EOL] assertEquals("ExpectedShortName", result); [EOL] }
public void testGetNameSetWithNullParameters() { [EOL] String[] result = getNameSet(null, null, null); [EOL] assertNull("The result should be null when any parameter is null", result); [EOL] }
public void testGetNameSetWithNewLocaleAndId() { [EOL] Locale testLocale = new Locale("en"); [EOL] String testId = "Test_ID"; [EOL] String testNameKey = "Test_NameKey"; [EOL] String[] result = getNameSet(testLocale, testId, testNameKey); [EOL] assertNotNull("Cache should be created and result should not be null", result); [EOL] }
public void testGetNameSetWithExistingLocaleAndId() { [EOL] Locale testLocale = new Locale("en"); [EOL] String testId = "Test_ID"; [EOL] String testNameKey = "Test_NameKey"; [EOL] getNameSet(testLocale, testId, testNameKey); // Call once to create cache [EOL] String[] result = getNameSet(testLocale, testId, testNameKey); // Call again to hit cache [EOL] assertNotNull("Result should be retrieved from cache", result); [EOL] }
public void testGetNameSetWithDifferentNameKey() { [EOL] Locale testLocale = new Locale("en"); [EOL] String testId = "Test_ID"; [EOL] String testNameKey = "Test_NameKey"; [EOL] String[] result = getNameSet(testLocale, testId, testNameKey); [EOL] assertNull("Result should be null for a nameKey that does not exist", result); [EOL] }
public void testGetNameSetWithMatchingZoneStrings() { [EOL] Locale testLocale = new Locale("en"); [EOL] String testId = "Test_ID"; [EOL] String testNameKey = "Test_NameKey"; [EOL] String[] result = getNameSet(testLocale, testId, testNameKey); [EOL] assertNotNull("Result should not be null for a matching nameKey", result); [EOL] assertEquals("Result should match the expected value from zoneStrings", "Expected_Value", result[0]); [EOL] }
public void testGetNameSetWithSummerTimeNameKey() { [EOL] Locale testLocale = new Locale("en"); [EOL] String testId = "Test_ID"; [EOL] String testNameKey = "Test_NameKey-Summer"; [EOL] String[] result = getNameSet(testLocale, testId, testNameKey); [EOL] assertNotNull("Result should not be null for a summer time nameKey", result); [EOL] assertEquals("Result should match the expected summer time value from zoneStrings", "Expected_Summer_Value", result[0]); [EOL] }
public void testMonthOfYearValueToShortText_January() { [EOL] String result = monthOfYearValueToShortText(1); [EOL] assertEquals("Jan", result); [EOL] }
public void testMonthOfYearValueToShortText_February() { [EOL] String result = monthOfYearValueToShortText(2); [EOL] assertEquals("Feb", result); [EOL] }
public void testMonthOfYearValueToShortText_December() { [EOL] String result = monthOfYearValueToShortText(12); [EOL] assertEquals("Dec", result); [EOL] }
public void testMonthOfYearValueToShortText_InvalidLow() { [EOL] try { [EOL] monthOfYearValueToShortText(0); [EOL] fail("Should have thrown an exception for invalid month value"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testMonthOfYearValueToShortText_InvalidHigh() { [EOL] try { [EOL] monthOfYearValueToShortText(13); [EOL] fail("Should have thrown an exception for invalid month value"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testMonthOfYearTextToValue_ValidMonth() { [EOL] String validMonthText = "January"; // Assuming "January" maps to 1 [EOL] int expectedValue = 1; [EOL] int actualValue = monthOfYearTextToValue(validMonthText); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testMonthOfYearTextToValue_InvalidMonth() { [EOL] String invalidMonthText = "NotAMonth"; [EOL] try { [EOL] monthOfYearTextToValue(invalidMonthText); [EOL] fail("Expected an IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException e) { [EOL] assertEquals(DateTimeFieldType.monthOfYear(), e.getFieldType()); [EOL] assertEquals(invalidMonthText, e.getIllegalValue()); [EOL] } [EOL] }
public void testGetDayOfWeekMaxShortTextLength() { [EOL] int expectedValue = 0; // Replace with the expected value of iMaxShortDayOfWeekLength [EOL] int actualValue = time.getDayOfWeekMaxShortTextLength(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testHalfdayValueToText_ValidValue0() { [EOL] String[] iHalfday = {"AM", "PM"}; // Assuming this is the array from the class context [EOL] String result = halfdayValueToText(0); [EOL] assertEquals("AM", result); [EOL] }
public void testHalfdayValueToText_ValidValue1() { [EOL] String[] iHalfday = {"AM", "PM"}; // Assuming this is the array from the class context [EOL] String result = halfdayValueToText(1); [EOL] assertEquals("PM", result); [EOL] }
public void testHalfdayValueToText_InvalidValue() { [EOL] try { [EOL] halfdayValueToText(-1); [EOL] fail("Should have thrown an exception for invalid index"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testHalfdayTextToValue_ValidHalfdayText() { [EOL] int result = halfdayTextToValue("AM"); [EOL] assertEquals(0, result); [EOL] result = halfdayTextToValue("PM"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testHalfdayTextToValue_InvalidHalfdayText() { [EOL] try { [EOL] halfdayTextToValue("invalid"); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] } [EOL] } [EOL] public void testHalfdayTextToValue_CaseInsensitive() { [EOL] int result = halfdayTextToValue("am"); [EOL] assertEquals(0, result); [EOL] result = halfdayTextToValue("pm"); [EOL] assertEquals(1, result); [EOL] }
public int getHalfdayMaxTextLength() { [EOL] return iMaxHalfdayLength; [EOL] }
public void testToDateTimeWithNullZone() { [EOL] DateTime dateTime = new DateTime(0L, GregorianChronology.getInstanceUTC()); // Use epoch in UTC for simplicity [EOL] DateTime result = dateTime.toDateTime(null); [EOL] assertNotNull(result); [EOL] assertEquals(GregorianChronology.getInstanceUTC(), result.getChronology()); [EOL] }
public void testToDateTimeWithSpecificZone() { [EOL] DateTime dateTime = new DateTime(0L, GregorianChronology.getInstanceUTC()); // Use epoch in UTC for simplicity [EOL] DateTimeZone specificZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime result = dateTime.toDateTime(specificZone); [EOL] assertNotNull(result); [EOL] assertEquals(specificZone, result.getChronology().getZone()); [EOL] }
public void testToMutableDateTimeWithNullChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTime(null); [EOL] assertNotNull(mutableDateTime); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] assertNull(mutableDateTime.getChronology()); [EOL] }
public void testToMutableDateTimeWithSpecificChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] MutableDateTime mutableDateTime = dateTime.toMutableDateTime(chronology); [EOL] assertNotNull(mutableDateTime); [EOL] assertEquals(dateTime.getMillis(), mutableDateTime.getMillis()); [EOL] assertEquals(chronology, mutableDateTime.getChronology()); [EOL] }
public Date toDate() { [EOL] return new Date(getMillis()); [EOL] }
public void testMutableIntervalDefaultConstructor() { [EOL] MutableInterval interval = new MutableInterval(); [EOL] assertNotNull(interval); [EOL] assertEquals(0L, interval.getStartMillis()); [EOL] assertEquals(0L, interval.getEndMillis()); [EOL] assertNull(interval.getChronology()); [EOL] }
public void testMutableIntervalWithValidStartAndEnd() { [EOL] ReadableInstant start = new DateTime(2021, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2021, 12, 31, 23, 59); [EOL] MutableInterval interval = new MutableInterval(start, end); [EOL] assertNotNull(interval); [EOL] assertEquals(start, interval.getStart()); [EOL] assertEquals(end, interval.getEnd()); [EOL] }
public void testMutableIntervalWithStartAfterEnd() { [EOL] ReadableInstant start = new DateTime(2021, 12, 31, 23, 59); [EOL] ReadableInstant end = new DateTime(2021, 1, 1, 0, 0); [EOL] try { [EOL] new MutableInterval(start, end); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMutableIntervalWithStartEqualsEnd() { [EOL] ReadableInstant start = new DateTime(2021, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2021, 1, 1, 0, 0); [EOL] MutableInterval interval = new MutableInterval(start, end); [EOL] assertNotNull(interval); [EOL] assertEquals(start, interval.getStart()); [EOL] assertEquals(end, interval.getEnd()); [EOL] }
public void testMutableIntervalWithNullStart() { [EOL] ReadableInstant end = new DateTime(2021, 12, 31, 23, 59); [EOL] try { [EOL] new MutableInterval(null, end); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableIntervalWithNullEnd() { [EOL] ReadableInstant start = new DateTime(2021, 1, 1, 0, 0); [EOL] try { [EOL] new MutableInterval(start, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testMutableIntervalWithNull() { [EOL] try { [EOL] new MutableInterval(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMutableIntervalWithValidInterval() { [EOL] Interval interval = new Interval(0, 10); [EOL] MutableInterval mutableInterval = new MutableInterval(interval); [EOL] assertEquals(interval.getStartMillis(), mutableInterval.getStartMillis()); [EOL] assertEquals(interval.getEndMillis(), mutableInterval.getEndMillis()); [EOL] }
public void testCopy() { [EOL] MutableInterval mutableInterval = new MutableInterval(0, 100); [EOL] MutableInterval copiedInterval = mutableInterval.copy(); [EOL] assertNotSame(mutableInterval, copiedInterval); [EOL] assertEquals(mutableInterval.getStartMillis(), copiedInterval.getStartMillis()); [EOL] assertEquals(mutableInterval.getEndMillis(), copiedInterval.getEndMillis()); [EOL] }
public void testNow() { [EOL] DateMidnight result = ClassName.now(); [EOL] assertNotNull(result); [EOL] assertEquals(new DateMidnight().toLocalDate(), result.toLocalDate()); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] Time.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateMidnight result = Time.now(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testDateMidnightWithNullZone() { [EOL] try { [EOL] new DateMidnight((DateTimeZone) null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeZone"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDateMidnightWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] DateMidnight dateMidnight = new DateMidnight(zone); [EOL] assertNotNull("DateMidnight should not be null", dateMidnight); [EOL] assertEquals("Time zone should match the one provided", zone, dateMidnight.getZone()); [EOL] }
public void testDateMidnightWithNullChronology() { [EOL] DateMidnight dateMidnight = new DateMidnight((Chronology) null); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(GregorianChronology.getInstanceUTC(), dateMidnight.getChronology()); [EOL] }
public void testDateMidnightWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateMidnight dateMidnight = new DateMidnight(chronology); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(chronology, dateMidnight.getChronology()); [EOL] }
public void testDateMidnight_ValidDate() { [EOL] DateMidnight dateMidnight = new DateMidnight(2023, 3, 15); [EOL] assertNotNull(dateMidnight); [EOL] assertEquals(2023, dateMidnight.getYear()); [EOL] assertEquals(3, dateMidnight.getMonthOfYear()); [EOL] assertEquals(15, dateMidnight.getDayOfMonth()); [EOL] }
public void testDateMidnight_InvalidDate() { [EOL] try { [EOL] new DateMidnight(2023, 13, 32); [EOL] fail("Should have thrown an exception due to invalid date"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPlusYears_ZeroYears() { [EOL] DateMidnight originalDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = originalDateMidnight.plusYears(0); [EOL] assertEquals("The date should be the same when adding zero years", originalDateMidnight, resultDateMidnight); [EOL] }
public void testPlusYears_PositiveYears() { [EOL] DateMidnight originalDateMidnight = new DateMidnight(); [EOL] int yearsToAdd = 5; [EOL] DateMidnight resultDateMidnight = originalDateMidnight.plusYears(yearsToAdd); [EOL] DateMidnight expectedDateMidnight = originalDateMidnight.plusYears(yearsToAdd); [EOL] assertEquals("The date should be correctly added when adding positive years", expectedDateMidnight, resultDateMidnight); [EOL] }
public void testPlusYears_NegativeYears() { [EOL] DateMidnight originalDateMidnight = new DateMidnight(); [EOL] int yearsToSubtract = -5; [EOL] DateMidnight resultDateMidnight = originalDateMidnight.plusYears(yearsToSubtract); [EOL] DateMidnight expectedDateMidnight = originalDateMidnight.plusYears(yearsToSubtract); [EOL] assertEquals("The date should be correctly subtracted when adding negative years", expectedDateMidnight, resultDateMidnight); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] DateMidnight original = new DateMidnight(); [EOL] DateMidnight result = original.plusDays(0); [EOL] assertSame("Expected the same instance when adding zero days.", original, result); [EOL] }
public void testPlusDays_PositiveDays() { [EOL] DateMidnight original = new DateMidnight(); [EOL] DateMidnight result = original.plusDays(5); [EOL] assertFalse("Expected a different instance when adding positive days.", original.equals(result)); [EOL] assertEquals("Expected the days to be added correctly.", original.plusDays(5).getMillis(), result.getMillis()); [EOL] }
public void testPlusDays_NegativeDays() { [EOL] DateMidnight original = new DateMidnight(); [EOL] DateMidnight result = original.plusDays(-5); [EOL] assertFalse("Expected a different instance when subtracting days.", original.equals(result)); [EOL] assertEquals("Expected the days to be subtracted correctly.", original.plusDays(-5).getMillis(), result.getMillis()); [EOL] }
public void testYearOfEra() { [EOL] DateTime testDateTime = new DateTime(); [EOL] Property yearOfEraProperty = testDateTime.yearOfEra(); [EOL] assertNotNull(yearOfEraProperty); [EOL] assertEquals(testDateTime.getChronology().yearOfEra(), yearOfEraProperty.getField()); [EOL] }
public void testPropertyWithValidDateMidnightAndField() { [EOL] DateMidnight instant = new DateMidnight(); [EOL] DateTimeField field = DateTimeFieldType.dayOfMonth().getField(DateTimeZone.UTC); [EOL] Property property = new Property(instant, field); [EOL] assertNotNull(property); [EOL] assertEquals(instant, property.iInstant); [EOL] assertEquals(field, property.iField); [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] DateMidnight initialDateMidnight = new DateMidnight(2020, 1, 1); [EOL] DateTimeField field = ISODateTimeFormat.yearMonthDay().getField(0); [EOL] DateMidnightProperty property = new DateMidnight.Property(initialDateMidnight, field); [EOL] Locale locale = Locale.ENGLISH; [EOL] String validText = "2021-01-01"; [EOL] DateMidnight updatedDateMidnight = property.setCopy(validText, locale); [EOL] DateMidnight expectedDateMidnight = formatter.parseDateTime(validText).toDateMidnight(); [EOL] assertEquals(expectedDateMidnight, updatedDateMidnight); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(2020, 1, 1); [EOL] DateTimeField field = ISODateTimeFormat.yearMonthDay().getField(0); [EOL] DateMidnightProperty property = new DateMidnight.Property(initialDateMidnight, field); [EOL] Locale locale = Locale.ENGLISH; [EOL] String invalidText = "invalid-date"; [EOL] try { [EOL] property.setCopy(invalidText, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] DateMidnight initialDateMidnight = new DateMidnight(2020, 1, 1); [EOL] DateTimeField field = ISODateTimeFormat.yearMonthDay().getField(0); [EOL] DateMidnightProperty property = new DateMidnight.Property(initialDateMidnight, field); [EOL] String validText = "2021-01-01"; [EOL] try { [EOL] property.setCopy(validText, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetCopyWithText() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] String text = "2000-01-01"; [EOL] DateMidnight result = dateMidnight.setCopy(text); [EOL] assertNotNull(result); [EOL] assertEquals(new DateMidnight(text), result); [EOL] }
public void testSetCopyWithNullText() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] String text = null; [EOL] try { [EOL] dateMidnight.setCopy(text); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRoundHalfCeilingCopy() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] Instant mockInstant = Mockito.mock(Instant.class); [EOL] long testMillis = 1000L; [EOL] long expectedMillis = 2000L; [EOL] Mockito.when(mockInstant.getMillis()).thenReturn(testMillis); [EOL] Mockito.when(mockField.roundHalfCeiling(testMillis)).thenReturn(expectedMillis); [EOL] DateMidnight testDateMidnight = new DateMidnight(mockInstant, mockField); [EOL] DateMidnight result = testDateMidnight.roundHalfCeilingCopy(); [EOL] Mockito.verify(mockField).roundHalfCeiling(testMillis); [EOL] Mockito.verify(mockInstant).getMillis(); [EOL] assertNotNull(result); [EOL] assertEquals(new DateMidnight(expectedMillis), result); [EOL] }
public void testBasePartialConstructor() { [EOL] BasePartial basePartial = new BasePartial(); [EOL] assertNotNull("BasePartial instance should be created", basePartial); [EOL] assertEquals("The chronology should be null by default", null, basePartial.getChronology()); [EOL] assertEquals("The time should be current time millis", DateTimeUtils.currentTimeMillis(), basePartial.getMillis()); [EOL] }
public void testBasePartialWithValidInput() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int[] values = new int[] {1, 2, 3, 4}; [EOL] BasePartial base = new BasePartial(chronology, values); [EOL] int[] newValues = new int[] {5, 6, 7, 8}; [EOL] BasePartial newBasePartial = new BasePartial(base, newValues); [EOL] assertNotNull(newBasePartial); [EOL] assertSame(chronology, newBasePartial.getChronology()); [EOL] assertArrayEquals(newValues, newBasePartial.getValues()); [EOL] }
public void testBasePartialWithNonNullChrono() { [EOL] DateTimeZone originalTimeZone = DateTimeZone.getDefault(); [EOL] try { [EOL] DateTimeZone.setDefault(DateTimeZone.forID("Europe/Paris")); [EOL] BasePartial base = new BasePartial(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] BasePartial newBase = new BasePartial(base, chrono); [EOL] assertEquals(chrono.withUTC(), newBase.getChronology()); [EOL] assertArrayEquals(base.getValues(), newBase.getValues()); [EOL] } finally { [EOL] DateTimeZone.setDefault(originalTimeZone); [EOL] } [EOL] }
public void testBasePartialWithNullChrono() { [EOL] BasePartial base = new BasePartial(); [EOL] try { [EOL] new BasePartial(base, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetValues() { [EOL] Time time = new Time(); [EOL] int[] expectedValues = new int[] { /* some expected values based on the Time object state */ }; [EOL] int[] actualValues = time.getValues(); [EOL] assertArrayEquals(expectedValues, actualValues); [EOL] }
