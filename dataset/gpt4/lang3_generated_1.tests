public void testIsNotTrue_WhenBoolIsNull() { [EOL] boolean result = isNotTrue(null); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNotTrue_WhenBoolIsTrue() { [EOL] boolean result = isNotTrue(true); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsNotTrue_WhenBoolIsFalse() { [EOL] boolean result = isNotTrue(false); [EOL] assertTrue(result); [EOL] }
public void testToBooleanWithTrue() { [EOL] Boolean input = Boolean.TRUE; [EOL] boolean result = StringUtils.toBoolean(input); [EOL] assertTrue(result); [EOL] }
public void testToBooleanWithFalse() { [EOL] Boolean input = Boolean.FALSE; [EOL] boolean result = StringUtils.toBoolean(input); [EOL] assertFalse(result); [EOL] }
public void testToBooleanWithNull() { [EOL] Boolean input = null; [EOL] boolean result = StringUtils.toBoolean(input); [EOL] assertFalse(result); [EOL] }
public void testToBoolean_True() { [EOL] assertTrue(toBoolean(1, 1, 0)); [EOL] } [EOL] public void testToBoolean_False() { [EOL] assertFalse(toBoolean(0, 1, 0)); [EOL] } [EOL] public void testToBoolean_IllegalArgumentException() { [EOL] try { [EOL] toBoolean(2, 1, 0); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToBoolean_ValueIsNullTrueValueIsNull() { [EOL] assertTrue(StringUtils.toBoolean(null, null, Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueIsNullFalseValueIsNull() { [EOL] assertFalse(StringUtils.toBoolean(null, Integer.valueOf(1), null)); [EOL] } [EOL] public void testToBoolean_ValueIsNullTrueValueIsNotNull() { [EOL] assertFalse(StringUtils.toBoolean(null, Integer.valueOf(1), Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueIsNullFalseValueIsNotNull() { [EOL] assertFalse(StringUtils.toBoolean(null, Integer.valueOf(1), Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueEqualsTrueValue() { [EOL] assertTrue(StringUtils.toBoolean(Integer.valueOf(1), Integer.valueOf(1), Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueEqualsFalseValue() { [EOL] assertFalse(StringUtils.toBoolean(Integer.valueOf(0), Integer.valueOf(1), Integer.valueOf(0))); [EOL] } [EOL] public void testToBoolean_ValueDoesNotMatchAny() { [EOL] try { [EOL] StringUtils.toBoolean(Integer.valueOf(2), Integer.valueOf(1), Integer.valueOf(0)); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testToStringTrueFalse_WithTrue() { [EOL] String result = StringUtils.toStringTrueFalse(Boolean.TRUE); [EOL] assertEquals("true", result); [EOL] } [EOL] public void testToStringTrueFalse_WithFalse() { [EOL] String result = StringUtils.toStringTrueFalse(Boolean.FALSE); [EOL] assertEquals("false", result); [EOL] } [EOL] public void testToStringTrueFalse_WithNull() { [EOL] String result = StringUtils.toStringTrueFalse(null); [EOL] assertEquals(null, result); [EOL] }
public void testToString_BooleanTrue() { [EOL] String result = StringUtils.toString(true, "Yes", "No", "N/A"); [EOL] assertEquals("Yes", result); [EOL] } [EOL] public void testToString_BooleanFalse() { [EOL] String result = StringUtils.toString(false, "Yes", "No", "N/A"); [EOL] assertEquals("No", result); [EOL] } [EOL] public void testToString_BooleanNull() { [EOL] String result = StringUtils.toString(null, "Yes", "No", "N/A"); [EOL] assertEquals("N/A", result); [EOL] }
public void testAnd_NullArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.and(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_EmptyArray_ThrowsException() { [EOL] try { [EOL] boolean result = Lang3.and(new boolean[]{}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testAnd_AllTrue_ReturnsTrue() { [EOL] boolean result = Lang3.and(new boolean[]{true, true, true}); [EOL] assertTrue(result); [EOL] }
public void testAnd_OneFalse_ReturnsFalse() { [EOL] boolean result = Lang3.and(new boolean[]{true, false, true}); [EOL] assertFalse(result); [EOL] }
public void testAnd_AllFalse_ReturnsFalse() { [EOL] boolean result = Lang3.and(new boolean[]{false, false, false}); [EOL] assertFalse(result); [EOL] }
public void testOr_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testOr_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.or(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testOr_ValidArray_AllTrue() { [EOL] Boolean result = Lang3.or(new Boolean[]{true, true, true}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testOr_ValidArray_AllFalse() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testOr_ValidArray_MixedValues() { [EOL] Boolean result = Lang3.or(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testXor_NullArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor((Boolean[]) null); [EOL] fail("Should have thrown IllegalArgumentException for null array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The Array must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testXor_EmptyArray_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor(new Boolean[0]); [EOL] fail("Should have thrown IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Array is empty", ex.getMessage()); [EOL] } [EOL] }
public void testXor_ArrayWithNull_ThrowsException() { [EOL] try { [EOL] Boolean result = Lang3.xor(new Boolean[]{true, null, false}); [EOL] fail("Should have thrown IllegalArgumentException for array with null"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The array must not contain any null elements", ex.getMessage()); [EOL] } [EOL] }
public void testXor_ValidArrayWithSingleTrue_ReturnsTrue() { [EOL] Boolean result = Lang3.xor(new Boolean[]{false, true, false}); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testXor_ValidArrayWithMultipleTrue_ReturnsFalse() { [EOL] Boolean result = Lang3.xor(new Boolean[]{true, true, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testXor_ValidArrayWithNoTrue_ReturnsFalse() { [EOL] Boolean result = Lang3.xor(new Boolean[]{false, false, false}); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testCreateNumberWithNullInput() { [EOL] Number result = NumberUtils.createNumber(null); [EOL] assertNull(result); [EOL] }
public void testCreateNumberWithBlankString() { [EOL] try { [EOL] NumberUtils.createNumber(" "); [EOL] fail("Should have thrown NumberFormatException for blank string"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateNumberWithHexPrefix() { [EOL] Number result = NumberUtils.createNumber("0xFF"); [EOL] assertNotNull(result); [EOL] assertEquals("Hex number not parsed correctly", 255, result.intValue()); [EOL] }
public void testCreateNumberWithInvalidHex() { [EOL] try { [EOL] NumberUtils.createNumber("0xG"); [EOL] fail("Should have thrown NumberFormatException for invalid hex"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateNumberWithLongHex() { [EOL] Number result = NumberUtils.createNumber("0x8000000000000000"); [EOL] assertNotNull(result); [EOL] assertTrue("Long hex number not parsed to BigInteger", result instanceof BigInteger); [EOL] }
public void testCreateNumberWithTooLongHex() { [EOL] Number result = NumberUtils.createNumber("0x80000000000000000"); [EOL] assertNotNull(result); [EOL] assertTrue("Too long hex number not parsed to BigInteger", result instanceof BigInteger); [EOL] }
public void testCreateNumberWithDecimal() { [EOL] Number result = NumberUtils.createNumber("123.456"); [EOL] assertNotNull(result); [EOL] assertTrue("Decimal number not parsed to Double", result instanceof Double); [EOL] }
public void testCreateNumberWithInvalidDecimal() { [EOL] try { [EOL] NumberUtils.createNumber("123.45.6"); [EOL] fail("Should have thrown NumberFormatException for invalid decimal"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateNumberWithExponent() { [EOL] Number result = NumberUtils.createNumber("123e10"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with exponent not parsed to Double", result instanceof Double); [EOL] }
public void testCreateNumberWithInvalidExponent() { [EOL] try { [EOL] NumberUtils.createNumber("123e10.5"); [EOL] fail("Should have thrown NumberFormatException for invalid exponent"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateNumberWithLongSuffix() { [EOL] Number result = NumberUtils.createNumber("123L"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with long suffix not parsed to Long", result instanceof Long); [EOL] }
public void testCreateNumberWithInvalidLongSuffix() { [EOL] try { [EOL] NumberUtils.createNumber("123ABCL"); [EOL] fail("Should have thrown NumberFormatException for invalid long suffix"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateNumberWithFloatSuffix() { [EOL] Number result = NumberUtils.createNumber("123.4F"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with float suffix not parsed to Float", result instanceof Float); [EOL] }
public void testCreateNumberWithDoubleSuffix() { [EOL] Number result = NumberUtils.createNumber("123.4D"); [EOL] assertNotNull(result); [EOL] assertTrue("Number with double suffix not parsed to Double", result instanceof Double); [EOL] }
public void testCreateNumberWithInvalidSuffix() { [EOL] try { [EOL] NumberUtils.createNumber("123.4A"); [EOL] fail("Should have thrown NumberFormatException for invalid suffix"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateNumberWithBigDecimal() { [EOL] Number result = NumberUtils.createNumber("12345678901234567890.12345678901234567890"); [EOL] assertNotNull(result); [EOL] assertTrue("Number not parsed to BigDecimal", result instanceof BigDecimal); [EOL] }
public void testCreateFloatWithNull() { [EOL] Float result = createFloat(null); [EOL] assertNull(result); [EOL] }
public void testCreateFloatWithValidString() { [EOL] Float expected = 1.23f; [EOL] Float result = createFloat("1.23"); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateFloatWithInvalidString() { [EOL] try { [EOL] createFloat("invalid"); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testCreateBigIntegerWithNull() { [EOL] BigInteger result = Lang3.createBigInteger(null); [EOL] assertNull(result); [EOL] }
public void testCreateBigIntegerWithNegativeHex() { [EOL] BigInteger result = Lang3.createBigInteger("-0x1A"); [EOL] assertEquals(new BigInteger("-26"), result); [EOL] }
public void testCreateBigIntegerWithPositiveHex() { [EOL] BigInteger result = Lang3.createBigInteger("0x1A"); [EOL] assertEquals(new BigInteger("26"), result); [EOL] }
public void testCreateBigIntegerWithHashPrefix() { [EOL] BigInteger result = Lang3.createBigInteger("#1A"); [EOL] assertEquals(new BigInteger("26"), result); [EOL] }
public void testCreateBigIntegerWithOctal() { [EOL] BigInteger result = Lang3.createBigInteger("075"); [EOL] assertEquals(new BigInteger("61"), result); [EOL] }
public void testCreateBigIntegerWithNegative() { [EOL] BigInteger result = Lang3.createBigInteger("-123"); [EOL] assertEquals(new BigInteger("-123"), result); [EOL] }
public void testCreateBigIntegerWithPositive() { [EOL] BigInteger result = Lang3.createBigInteger("123"); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testCreateBigIntegerWithZero() { [EOL] BigInteger result = Lang3.createBigInteger("0"); [EOL] assertEquals(BigInteger.ZERO, result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] int[] array = new int[]{5}; [EOL] int result = min(array); [EOL] assertEquals(5, result); [EOL] }
public void testMinWithMultipleElementsArray() { [EOL] int[] array = new int[]{5, 3, 7, 1, 4}; [EOL] int result = min(array); [EOL] assertEquals(1, result); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] int[] array = new int[]{2, 2, 2, 2, 2}; [EOL] int result = min(array); [EOL] assertEquals(2, result); [EOL] }
public void testMinWithNegativeElementsArray() { [EOL] int[] array = new int[]{-3, -1, -4, -2, -5}; [EOL] int result = min(array); [EOL] assertEquals(-5, result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] byte[] array = {42}; [EOL] byte result = min(array); [EOL] assertEquals(42, result); [EOL] }
public void testMinWithMultipleElementArray() { [EOL] byte[] array = {42, 35, 89, 7, 28}; [EOL] byte result = min(array); [EOL] assertEquals(7, result); [EOL] }
public void testMinWithAllEqualElementsArray() { [EOL] byte[] array = {15, 15, 15}; [EOL] byte result = min(array); [EOL] assertEquals(15, result); [EOL] }
public void testMinWithNegativeValues() { [EOL] byte[] array = {-10, -20, -5, -15}; [EOL] byte result = min(array); [EOL] assertEquals(-20, result); [EOL] }
public void testMaxWithSingleElementArray() { [EOL] int[] array = new int[]{42}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(42, result); [EOL] }
public void testMaxWithMultipleElementsArray() { [EOL] int[] array = new int[]{1, 3, 5, 4, 2}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(5, result); [EOL] }
public void testMaxWithAllNegativeElementsArray() { [EOL] int[] array = new int[]{-1, -3, -5, -4, -2}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(-1, result); [EOL] }
public void testMaxWithMixedElementsArray() { [EOL] int[] array = new int[]{-1, 3, 0, -4, 2}; [EOL] int result = ClassName.max(array); [EOL] assertEquals(3, result); [EOL] }
public void testMaxWithSingleElementArray() { [EOL] double[] array = new double[]{42.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testMaxWithMultipleElementArray() { [EOL] double[] array = new double[]{1.0, 42.0, 3.0, 7.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testMaxWithNaNInArray() { [EOL] double[] array = new double[]{1.0, Double.NaN, 3.0, 7.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testMaxWithNegativeInfinity() { [EOL] double[] array = new double[]{Double.NEGATIVE_INFINITY, 0.0, 1.0, 42.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(42.0, result, 0.0); [EOL] }
public void testMaxWithAllNegativeNumbers() { [EOL] double[] array = new double[]{-1.0, -42.0, -3.0, -7.0}; [EOL] double result = ArrayUtils.max(array); [EOL] assertEquals(-1.0, result, 0.0); [EOL] }
public void testMaxWithEmptyArray() { [EOL] double[] array = new double[]{}; [EOL] try { [EOL] ArrayUtils.max(array); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMax_AllEqual() { [EOL] int a = 1; [EOL] int b = 1; [EOL] int c = 1; [EOL] int result = YourClass.max(a, b, c); [EOL] assertEquals(a, result); [EOL] } [EOL] public void testMax_AGreater() { [EOL] int a = 3; [EOL] int b = 2; [EOL] int c = 1; [EOL] int result = YourClass.max(a, b, c); [EOL] assertEquals(a, result); [EOL] } [EOL] public void testMax_BGreater() { [EOL] int a = 1; [EOL] int b = 3; [EOL] int c = 2; [EOL] int result = YourClass.max(a, b, c); [EOL] assertEquals(b, result); [EOL] } [EOL] public void testMax_CGreater() { [EOL] int a = 1; [EOL] int b = 2; [EOL] int c = 3; [EOL] int result = YourClass.max(a, b, c); [EOL] assertEquals(c, result); [EOL] }
public void testMaxWithFirstByteMax() { [EOL] byte a = 10; [EOL] byte b = 8; [EOL] byte c = 9; [EOL] byte result = YourClass.max(a, b, c); [EOL] assertEquals(a, result); [EOL] } [EOL] public void testMaxWithSecondByteMax() { [EOL] byte a = 7; [EOL] byte b = 12; [EOL] byte c = 9; [EOL] byte result = YourClass.max(a, b, c); [EOL] assertEquals(b, result); [EOL] } [EOL] public void testMaxWithThirdByteMax() { [EOL] byte a = 7; [EOL] byte b = 6; [EOL] byte c = 15; [EOL] byte result = YourClass.max(a, b, c); [EOL] assertEquals(c, result); [EOL] } [EOL] public void testMaxWithAllBytesEqual() { [EOL] byte a = 5; [EOL] byte b = 5; [EOL] byte c = 5; [EOL] byte result = YourClass.max(a, b, c); [EOL] assertEquals(a, result); [EOL] }
public void testIsDigitsWithEmptyString() { [EOL] boolean result = StringUtils.isDigits(""); [EOL] assertFalse(result); [EOL] }
public void testIsDigitsWithNullString() { [EOL] boolean result = StringUtils.isDigits(null); [EOL] assertFalse(result); [EOL] }
public void testIsDigitsWithDigitsString() { [EOL] boolean result = StringUtils.isDigits("12345"); [EOL] assertTrue(result); [EOL] }
public void testIsDigitsWithNonDigitsString() { [EOL] boolean result = StringUtils.isDigits("123a45"); [EOL] assertFalse(result); [EOL] }
public short getShortValue(final short holder) { [EOL] return (short) getValue(holder); [EOL] }
public int getRawValueTestWithZero() { [EOL] int holder = 0; [EOL] int result = getRawValue(holder); [EOL] assert result == 0 : "Expected result to be 0 for holder 0"; [EOL] } [EOL] public int getRawValueTestWithPositiveHolder() { [EOL] int holder = 1; [EOL] int result = getRawValue(holder); [EOL] assert result == (1 & _mask) : "Expected result to be " + (1 & _mask) + " for holder 1"; [EOL] } [EOL] public int getRawValueTestWithNegativeHolder() { [EOL] int holder = -1; [EOL] int result = getRawValue(holder); [EOL] assert result == (-1 & _mask) : "Expected result to be " + (-1 & _mask) + " for holder -1"; [EOL] } [EOL] public int getRawValueTestWithMaxInt() { [EOL] int holder = Integer.MAX_VALUE; [EOL] int result = getRawValue(holder); [EOL] assert result == (Integer.MAX_VALUE & _mask) : "Expected result to be " + (Integer.MAX_VALUE & _mask) + " for holder Integer.MAX_VALUE"; [EOL] } [EOL] public int getRawValueTestWithMinInt() { [EOL] int holder = Integer.MIN_VALUE; [EOL] int result = getRawValue(holder); [EOL] assert result == (Integer.MIN_VALUE & _mask) : "Expected result to be " + (Integer.MIN_VALUE & _mask) + " for holder Integer.MIN_VALUE"; [EOL] }
public short getShortRawValue(final short holder) { [EOL] return (short) getRawValue(holder); [EOL] }
public void testIsAllSet_AllBitsSet() { [EOL] final int holder = _mask; // Assuming _mask is a predefined mask with all bits set that are of interest [EOL] boolean result = isAllSet(holder); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsAllSet_NoBitsSet() { [EOL] final int holder = 0; // No bits set [EOL] boolean result = isAllSet(holder); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsAllSet_SomeBitsSet() { [EOL] final int holder = _mask & ~(1 << bitPosition); // Assuming bitPosition is the position of a bit that should not be set [EOL] boolean result = isAllSet(holder); [EOL] assertFalse(result); [EOL] }

public void testSetShortValueWithValidValues() { [EOL] final short initialHolder = 10; [EOL] final short newValue = 20; [EOL] final short result = setShortValue(initialHolder, newValue); [EOL] assertEquals(newValue, result); [EOL] }
public void testSetShortValueWithMaxShortValue() { [EOL] final short initialHolder = 10; [EOL] final short newValue = Short.MAX_VALUE; [EOL] final short result = setShortValue(initialHolder, newValue); [EOL] assertEquals(Short.MAX_VALUE, result); [EOL] }
public void testSetShortValueWithMinShortValue() { [EOL] final short initialHolder = 10; [EOL] final short newValue = Short.MIN_VALUE; [EOL] final short result = setShortValue(initialHolder, newValue); [EOL] assertEquals(Short.MIN_VALUE, result); [EOL] }
public void testClearWithZero() { [EOL] int holder = 0; [EOL] int result = clear(holder); [EOL] assertEquals("Clearing a zero holder should result in zero", 0, result); [EOL] } [EOL] public void testClearWithPositiveHolder() { [EOL] int holder = 123; [EOL] int result = clear(holder); [EOL] int expected = holder & ~_mask; // Assuming _mask is a valid bitmask constant or variable in the scope [EOL] assertEquals("Clearing a positive holder should result in the holder AND NOT the mask", expected, result); [EOL] } [EOL] public void testClearWithNegativeHolder() { [EOL] int holder = -123; [EOL] int result = clear(holder); [EOL] int expected = holder & ~_mask; // Assuming _mask is a valid bitmask constant or variable in the scope [EOL] assertEquals("Clearing a negative holder should result in the holder AND NOT the mask", expected, result); [EOL] } [EOL] public void testClearWithMaxInt() { [EOL] int holder = Integer.MAX_VALUE; [EOL] int result = clear(holder); [EOL] int expected = holder & ~_mask; // Assuming _mask is a valid bitmask constant or variable in the scope [EOL] assertEquals("Clearing the max integer should result in the holder AND NOT the mask", expected, result); [EOL] } [EOL] public void testClearWithMinInt() { [EOL] int holder = Integer.MIN_VALUE; [EOL] int result = clear(holder); [EOL] int expected = holder & ~_mask; // Assuming _mask is a valid bitmask constant or variable in the scope [EOL] assertEquals("Clearing the min integer should result in the holder AND NOT the mask", expected, result); [EOL] }
public int set(final int holder) { [EOL] return holder | _mask; [EOL] }
public int setBoolean(final int holder, final boolean flag) { [EOL] return flag ? set(holder) : clear(holder); [EOL] }
public void testExtendedMessageFormatWithDefaultLocale() { [EOL] String pattern = "test pattern"; [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern); [EOL] assertNotNull(emf); [EOL] assertEquals(pattern, emf.toPattern()); [EOL] }
public void testExtendedMessageFormatWithGivenLocale() { [EOL] String pattern = "test pattern"; [EOL] Locale locale = new Locale("en", "US"); [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, locale); [EOL] assertNotNull(emf); [EOL] assertEquals(pattern, emf.toPattern()); [EOL] assertEquals(locale, emf.getLocale()); [EOL] }
public void testExtendedMessageFormatWithRegistry() { [EOL] String pattern = "test pattern"; [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL] assertNotNull(emf); [EOL] assertEquals(pattern, emf.toPattern()); [EOL] }
public void testExtendedMessageFormatWithLocaleAndRegistry() { [EOL] String pattern = "test pattern"; [EOL] Locale locale = new Locale("en", "US"); [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, locale, registry); [EOL] assertNotNull(emf); [EOL] assertEquals(pattern, emf.toPattern()); [EOL] assertEquals(locale, emf.getLocale()); [EOL] }
public void testApplyPattern() { [EOL] String pattern = "test pattern"; [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(""); [EOL] emf.applyPattern(pattern); [EOL] assertEquals(pattern, emf.toPattern()); [EOL] }
public void testSetFormat() { [EOL] String pattern = "test pattern {0}"; [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern); [EOL] Format format = NumberFormat.getInstance(); [EOL] emf.setFormat(0, format); [EOL] }
public void testSetFormatByArgumentIndex() { [EOL] String pattern = "test pattern {0}"; [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern); [EOL] Format format = NumberFormat.getInstance(); [EOL] emf.setFormatByArgumentIndex(0, format); [EOL] }
public void testSetFormats() { [EOL] String pattern = "test pattern {0}, {1}"; [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern); [EOL] Format[] formats = {NumberFormat.getInstance(), DateFormat.getInstance()}; [EOL] emf.setFormats(formats); [EOL] }
public void testSetFormatsByArgumentIndex() { [EOL] String pattern = "test pattern {0}, {1}"; [EOL] ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern); [EOL] Format[] formats = {NumberFormat.getInstance(), DateFormat.getInstance()}; [EOL] emf.setFormatsByArgumentIndex(formats); [EOL] }
public void testEqualsAndHashCode() { [EOL] String pattern = "test pattern"; [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat(pattern); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat(pattern); [EOL] assertEquals(emf1, emf2); [EOL] assertEquals(emf1.hashCode(), emf2.hashCode()); [EOL] }
public void testNotEquals() { [EOL] String pattern1 = "test pattern"; [EOL] String pattern2 = "another pattern"; [EOL] ExtendedMessageFormat emf1 = new ExtendedMessageFormat(pattern1); [EOL] ExtendedMessageFormat emf2 = new ExtendedMessageFormat(pattern2); [EOL] assertNotEquals(emf1, emf2); [EOL] }
public void testExtendedMessageFormatWithLocale() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern, locale); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] }
public void testExtendedMessageFormatWithPattern() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] }
public void testExtendedMessageFormatWithRegistry() { [EOL] String pattern = "pattern"; [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern, registry); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] }
public void testExtendedMessageFormatWithLocaleAndRegistry() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String pattern = "pattern"; [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern, locale, registry); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] }
public void testApplyPattern() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] String newPattern = "new pattern"; [EOL] extendedMessageFormat.applyPattern(newPattern); [EOL] assertEquals(newPattern, extendedMessageFormat.toPattern()); [EOL] }
public void testSetFormat() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] Format newFormat = NumberFormat.getInstance(); [EOL] extendedMessageFormat.setFormat(0, newFormat); [EOL] }
public void testSetFormatByArgumentIndex() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] Format newFormat = NumberFormat.getInstance(); [EOL] extendedMessageFormat.setFormatByArgumentIndex(0, newFormat); [EOL] }
public void testSetFormats() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] Format[] newFormats = {NumberFormat.getInstance()}; [EOL] extendedMessageFormat.setFormats(newFormats); [EOL] }
public void testSetFormatsByArgumentIndex() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] Format[] newFormats = {NumberFormat.getInstance()}; [EOL] extendedMessageFormat.setFormatsByArgumentIndex(newFormats); [EOL] }
public void testEqualsAndHashCode() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(pattern); [EOL] ExtendedMessageFormat extendedMessageFormat2 = new ExtendedMessageFormat(pattern); [EOL] assertEquals(extendedMessageFormat1, extendedMessageFormat2); [EOL] assertEquals(extendedMessageFormat1.hashCode(), extendedMessageFormat2.hashCode()); [EOL] }
public void testExtendedMessageFormatWithPatternAndLocale() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern, locale); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(locale, extendedMessageFormat.getLocale()); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] } [EOL] public void testExtendedMessageFormatWithPatternAndRegistry() { [EOL] String pattern = "pattern"; [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern, registry); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] } [EOL] public void testExtendedMessageFormatWithPatternLocaleAndRegistry() { [EOL] Locale locale = Locale.ENGLISH; [EOL] String pattern = "pattern"; [EOL] Map<String, FormatFactory> registry = new HashMap<>(); [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern, locale, registry); [EOL] assertNotNull(extendedMessageFormat); [EOL] assertEquals(locale, extendedMessageFormat.getLocale()); [EOL] assertEquals(pattern, extendedMessageFormat.toPattern()); [EOL] } [EOL] public void testExtendedMessageFormatWithNullPattern() { [EOL] try { [EOL] new ExtendedMessageFormat(null, Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException for null pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testExtendedMessageFormatWithNullLocale() { [EOL] String pattern = "pattern"; [EOL] try { [EOL] new ExtendedMessageFormat(pattern, (Locale) null); [EOL] fail("Should have thrown IllegalArgumentException for null locale"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testExtendedMessageFormatWithNullRegistry() { [EOL] String pattern = "pattern"; [EOL] try { [EOL] new ExtendedMessageFormat(pattern, (Map<String, FormatFactory>) null); [EOL] fail("Should have thrown IllegalArgumentException for null registry"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testApplyPattern() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] String newPattern = "new pattern"; [EOL] extendedMessageFormat.applyPattern(newPattern); [EOL] assertEquals(newPattern, extendedMessageFormat.toPattern()); [EOL] } [EOL] public void testApplyPatternWithInvalidPattern() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] try { [EOL] extendedMessageFormat.applyPattern(null); [EOL] fail("Should have thrown IllegalArgumentException for null pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetFormatByArgumentIndex() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] Format newFormat = NumberFormat.getInstance(); [EOL] extendedMessageFormat.setFormatByArgumentIndex(0, newFormat); [EOL] } [EOL] public void testSetFormatByArgumentIndexWithInvalidIndex() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat = new ExtendedMessageFormat(pattern); [EOL] Format newFormat = NumberFormat.getInstance(); [EOL] try { [EOL] extendedMessageFormat.setFormatByArgumentIndex(-1, newFormat); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException for invalid index"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testEqualsAndHashCode() { [EOL] String pattern = "pattern"; [EOL] ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(pattern); [EOL] ExtendedMessageFormat extendedMessageFormat2 = new ExtendedMessageFormat(pattern); [EOL] assertEquals(extendedMessageFormat1, extendedMessageFormat2); [EOL] assertEquals(extendedMessageFormat1.hashCode(), extendedMessageFormat2.hashCode()); [EOL] } [EOL] public void testNotEqualsAndHashCode() { [EOL] String pattern1 = "pattern1"; [EOL] String pattern2 = "pattern2"; [EOL] ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(pattern1); [EOL] ExtendedMessageFormat extendedMessageFormat2 = new ExtendedMessageFormat(pattern2); [EOL] assertNotEquals(extendedMessageFormat1, extendedMessageFormat2); [EOL] assertNotEquals(extendedMessageFormat1.hashCode(), extendedMessageFormat2.hashCode()); [EOL] }
@Override [EOL] public String toPattern() { [EOL] return toPattern; [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}'];
@Override [EOL] public final void applyPattern(final String pattern) { [EOL] if (registry == null) { [EOL] super.applyPattern(pattern); [EOL] toPattern = super.toPattern(); [EOL] return; [EOL] } [EOL] final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL] final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL] final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL] final ParsePosition pos = new ParsePosition(0); [EOL] final char[] c = pattern.toCharArray(); [EOL] int fmtCount = 0; [EOL] while (pos.getIndex() < pattern.length()) { [EOL] switch(c[pos.getIndex()]) { [EOL] case QUOTE: [EOL] appendQuotedString(pattern, pos, stripCustom, true); [EOL] break; [EOL] case START_FE: [EOL] fmtCount++; [EOL] seekNonWs(pattern, pos); [EOL] final int start = pos.getIndex(); [EOL] final int index = readArgumentIndex(pattern, next(pos)); [EOL] stripCustom.append(START_FE).append(index); [EOL] seekNonWs(pattern, pos); [EOL] Format format = null; [EOL] String formatDescription = null; [EOL] if (c[pos.getIndex()] == START_FMT) { [EOL] formatDescription = parseFormatDescription(pattern, next(pos)); [EOL] format = getFormat(formatDescription); [EOL] if (format == null) { [EOL] stripCustom.append(START_FMT).append(formatDescription); [EOL] } [EOL] } [EOL] foundFormats.add(format); [EOL] foundDescriptions.add(format == null ? null : formatDescription); [EOL] Validate.isTrue(foundFormats.size() == fmtCount); [EOL] Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL] if (c[pos.getIndex()] != END_FE) { [EOL] throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL] } [EOL] default: [EOL] stripCustom.append(c[pos.getIndex()]); [EOL] next(pos); [EOL] } [EOL] } [EOL] super.applyPattern(stripCustom.toString()); [EOL] toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL] if (containsElements(foundFormats)) { [EOL] final Format[] origFormats = getFormats(); [EOL] int i = 0; [EOL] for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL] final Format f = it.next(); [EOL] if (f != null) { [EOL] origFormats[i] = f; [EOL] } [EOL] } [EOL] super.setFormats(origFormats); [EOL] } [EOL] } public ExtendedMessageFormat(final String pattern); public ExtendedMessageFormat(final String pattern, final Locale locale); public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry); public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry); public String toPattern(); public final void applyPattern(final String pattern); public void setFormat(final int formatElementIndex, final Format newFormat); public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat); public void setFormats(final Format[] newFormats); public void setFormatsByArgumentIndex(final Format[] newFormats); public boolean equals(final Object obj); public int hashCode(); private Format getFormat(final String desc); private int readArgumentIndex(final String pattern, final ParsePosition pos); private String parseFormatDescription(final String pattern, final ParsePosition pos); private String insertFormats(final String pattern, final ArrayList<String> customPatterns); private void seekNonWs(final String pattern, final ParsePosition pos); private ParsePosition next(final ParsePosition pos); private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn); private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn); private boolean containsElements(final Collection<?> coll); long serialVersionUID=Optional[-2362048321261811743L]; int HASH_SEED=Optional[31]; String DUMMY_PATTERN=Optional[""]; String ESCAPED_QUOTE=Optional["''"]; char START_FMT=Optional[',']; char END_FE=Optional['}'];
public void testToString() { [EOL] Pair<Integer, String> pair = new ImmutablePair<>(1, "one"); [EOL] String result = pair.toString(); [EOL] assertEquals("(1,one)", result); [EOL] }
public void testToStringWithNullValues() { [EOL] Pair<Integer, String> pair = new ImmutablePair<>(null, null); [EOL] String result = pair.toString(); [EOL] assertEquals("(null,null)", result); [EOL] }
public void testToStringWithValidFormat() { [EOL] Pair<Integer, String> pair = Pair.of(1, "one"); [EOL] String result = pair.toString("%d: %s"); [EOL] assertEquals("1: one", result); [EOL] }
public void testToStringWithNullFormat() { [EOL] Pair<Integer, String> pair = Pair.of(1, "one"); [EOL] try { [EOL] pair.toString(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public T testGetSuccess() throws ConcurrentException { [EOL] SomeClass instance = new SomeClass(); [EOL] T expected = instance.getObject(); [EOL] T result = instance.get(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetThrowsException() { [EOL] SomeClass instance = new SomeClass() { [EOL] @Override [EOL] public T getObject() throws ConcurrentException { [EOL] throw new ConcurrentException(); [EOL] } [EOL] }; [EOL] try { [EOL] instance.get(); [EOL] fail("Expected an ConcurrentException to be thrown"); [EOL] } catch (ConcurrentException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testUncaughtExceptionHandlerWithNonNullHandler() { [EOL] Thread.UncaughtExceptionHandler handler = (t, e) -> { /* No-op handler */ }; [EOL] Builder builder = new Builder(); [EOL] Builder result = builder.uncaughtExceptionHandler(handler); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); // Verify that 'this' is returned [EOL] assertSame(handler, builder.getExceptionHandler()); [EOL] } [EOL] public void testUncaughtExceptionHandlerWithNullHandler() { [EOL] try { [EOL] new Builder().uncaughtExceptionHandler(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Uncaught exception handler must not be null!", e.getMessage()); [EOL] } [EOL] }
public void testTimedSemaphoreConstructorWithValidArguments() { [EOL] long timePeriod = 1000; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = 10; [EOL] TimedSemaphore semaphore = new TimedSemaphore(timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getTimePeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] }
public void testTimedSemaphoreConstructorWithZeroLimit() { [EOL] long timePeriod = 1000; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = 0; [EOL] try { [EOL] new TimedSemaphore(timePeriod, timeUnit, limit); [EOL] fail("Expected IllegalArgumentException for zero limit"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testTimedSemaphoreConstructorWithNegativeLimit() { [EOL] long timePeriod = 1000; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = -1; [EOL] try { [EOL] new TimedSemaphore(timePeriod, timeUnit, limit); [EOL] fail("Expected IllegalArgumentException for negative limit"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testTimedSemaphoreConstructorWithNegativeTimePeriod() { [EOL] long timePeriod = -1000; [EOL] TimeUnit timeUnit = TimeUnit.MILLISECONDS; [EOL] int limit = 10; [EOL] try { [EOL] new TimedSemaphore(timePeriod, timeUnit, limit); [EOL] fail("Expected IllegalArgumentException for negative time period"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testTimedSemaphoreConstructorWithValidArguments() { [EOL] long timePeriod = 1; [EOL] TimeUnit timeUnit = TimeUnit.SECONDS; [EOL] int limit = 10; [EOL] ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); [EOL] TimedSemaphore semaphore = new TimedSemaphore(service, timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getPeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] assertFalse(semaphore.isShutdown()); [EOL] }
public void testTimedSemaphoreConstructorWithInvalidTimePeriod() { [EOL] long timePeriod = 0; [EOL] TimeUnit timeUnit = TimeUnit.SECONDS; [EOL] int limit = 10; [EOL] ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); [EOL] try { [EOL] new TimedSemaphore(service, timePeriod, timeUnit, limit); [EOL] fail("Expected IllegalArgumentException for time period <= 0"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testTimedSemaphoreConstructorWithNullService() { [EOL] long timePeriod = 1; [EOL] TimeUnit timeUnit = TimeUnit.SECONDS; [EOL] int limit = 10; [EOL] TimedSemaphore semaphore = new TimedSemaphore(null, timePeriod, timeUnit, limit); [EOL] assertNotNull(semaphore); [EOL] assertEquals(timePeriod, semaphore.getPeriod()); [EOL] assertEquals(timeUnit, semaphore.getTimeUnit()); [EOL] assertEquals(limit, semaphore.getLimit()); [EOL] assertTrue(semaphore.isShutdown()); [EOL] }
public void testShutdown_NotAlreadyShutdown_OwnExecutor() { [EOL] MyClass testClass = new MyClass(true); // Assuming constructor that sets ownExecutor to true [EOL] testClass.startTask(); // Assuming a method that starts a task [EOL] testClass.shutdown(); [EOL] assertTrue(testClass.isShutdown()); // Assuming isShutdown() method to check the shutdown status [EOL] assertNull(testClass.getExecutorService()); // Assuming getExecutorService() returns null after shutdown [EOL] }
public void testShutdown_NotAlreadyShutdown_NotOwnExecutor() { [EOL] MyClass testClass = new MyClass(false); // Assuming constructor that sets ownExecutor to false [EOL] testClass.startTask(); // Assuming a method that starts a task [EOL] testClass.shutdown(); [EOL] assertTrue(testClass.isShutdown()); // Assuming isShutdown() method to check the shutdown status [EOL] assertNotNull(testClass.getExecutorService()); // Assuming getExecutorService() still returns the executor service [EOL] assertTrue(testClass.getTask().isCancelled()); // Assuming getTask() returns the task and we can check if it's cancelled [EOL] }
public void testShutdown_AlreadyShutdown() { [EOL] MyClass testClass = new MyClass(true); // Assuming constructor that sets ownExecutor to true [EOL] testClass.startTask(); // Assuming a method that starts a task [EOL] testClass.shutdown(); // First call to shutdown [EOL] testClass.shutdown(); [EOL] assertTrue(testClass.isShutdown()); // Assuming isShutdown() method to check the shutdown status [EOL] }
public synchronized int getAcquireCount() { [EOL] return acquireCount; [EOL] }
public void testGetAvailablePermitsWithNoAcquires() { [EOL] Semaphore semaphore = new Semaphore(10); [EOL] int availablePermits = semaphore.getAvailablePermits(); [EOL] assertEquals(10, availablePermits); [EOL] }
public void testGetAvailablePermitsWithSomeAcquires() { [EOL] Semaphore semaphore = new Semaphore(10); [EOL] semaphore.acquire(5); [EOL] int availablePermits = semaphore.getAvailablePermits(); [EOL] assertEquals(5, availablePermits); [EOL] }
public void testGetAvailablePermitsAfterRelease() { [EOL] Semaphore semaphore = new Semaphore(10); [EOL] semaphore.acquire(5); [EOL] semaphore.release(2); [EOL] int availablePermits = semaphore.getAvailablePermits(); [EOL] assertEquals(7, availablePermits); [EOL] }
public void testStartTimerWithValidPeriodAndUnit() { [EOL] setPeriod(1L); // Assuming setPeriod is a method to set the period for the timer [EOL] setUnit(TimeUnit.SECONDS); // Assuming setUnit is a method to set the time unit for the timer [EOL] ScheduledFuture<?> future = startTimer(); [EOL] assertNotNull(future); [EOL] assertFalse(future.isDone()); [EOL] assertFalse(future.isCancelled()); [EOL] }
public void testStartTimerWithZeroPeriod() { [EOL] setPeriod(0L); // Assuming setPeriod is a method to set the period for the timer [EOL] setUnit(TimeUnit.SECONDS); // Assuming setUnit is a method to set the time unit for the timer [EOL] ScheduledFuture<?> future = startTimer(); [EOL] assertNotNull(future); [EOL] assertFalse(future.isDone()); [EOL] assertFalse(future.isCancelled()); [EOL] }
public void testStartTimerWithNegativePeriod() { [EOL] setPeriod(-1L); // Assuming setPeriod is a method to set the period for the timer [EOL] setUnit(TimeUnit.SECONDS); // Assuming setUnit is a method to set the time unit for the timer [EOL] ScheduledFuture<?> future = startTimer(); [EOL] assertNotNull(future); [EOL] assertFalse(future.isDone()); [EOL] assertFalse(future.isCancelled()); [EOL] }
public void testEndOfPeriod() { [EOL] RateLimiter rateLimiter = new RateLimiter(); [EOL] rateLimiter.acquire(); // Assuming acquire() increments acquireCount [EOL] rateLimiter.endOfPeriod(); [EOL] assertEquals("lastCallsPerPeriod should be updated to acquireCount", 1, rateLimiter.getLastCallsPerPeriod()); [EOL] assertEquals("totalAcquireCount should be incremented by acquireCount", 1, rateLimiter.getTotalAcquireCount()); [EOL] assertEquals("periodCount should be incremented", 1, rateLimiter.getPeriodCount()); [EOL] assertEquals("acquireCount should be reset to 0", 0, rateLimiter.getAcquireCount()); [EOL] }
public void testContextedRuntimeException() { [EOL] ContextedRuntimeException exception = new ContextedRuntimeException(); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getExceptionContext() instanceof DefaultExceptionContext); [EOL] }
public void testCreateWithValidInterface() { [EOL] Class<SomeListenerInterface> listenerInterface = SomeListenerInterface.class; [EOL] EventListenerSupport<SomeListenerInterface> support = EventListenerSupport.create(listenerInterface); [EOL] assertNotNull(support); [EOL] }
public void testCreateWithNullInterface() { [EOL] try { [EOL] EventListenerSupport.create(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testEventListenerSupportWithValidInterface() { [EOL] Class<EventListener> listenerInterface = EventListener.class; [EOL] EventListenerSupport<EventListener> support = new EventListenerSupport<>(listenerInterface); [EOL] assertNotNull(support); [EOL] }
public void testEventListenerSupportWithNullInterface() { [EOL] try { [EOL] new EventListenerSupport<>(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testEventListenerSupportWithValidArguments() { [EOL] Class<?> listenerInterface = EventListener.class; [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] EventListenerSupport<?> eventListenerSupport = new EventListenerSupport<>(listenerInterface, classLoader); [EOL] assertNotNull(eventListenerSupport); [EOL] } [EOL] public void testEventListenerSupportWithNullListenerInterface() { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] try { [EOL] new EventListenerSupport<>(null, classLoader); [EOL] fail("Should have thrown IllegalArgumentException because listenerInterface is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Listener interface cannot be null.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testEventListenerSupportWithNullClassLoader() { [EOL] Class<?> listenerInterface = EventListener.class; [EOL] try { [EOL] new EventListenerSupport<>(listenerInterface, null); [EOL] fail("Should have thrown IllegalArgumentException because classLoader is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ClassLoader cannot be null.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testEventListenerSupportWithNonInterfaceClass() { [EOL] Class<?> nonInterfaceClass = String.class; [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] try { [EOL] new EventListenerSupport<>(nonInterfaceClass, classLoader); [EOL] fail("Should have thrown IllegalArgumentException because nonInterfaceClass is not an interface"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("is not an interface")); [EOL] } [EOL] }
public void testPrivateConstructor() throws Exception { [EOL] Constructor<EventListenerSupport> constructor = EventListenerSupport.class.getDeclaredConstructor(); [EOL] assertTrue(Modifier.isPrivate(constructor.getModifiers())); [EOL] constructor.setAccessible(true); [EOL] try { [EOL] constructor.newInstance(); [EOL] fail("Expected IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testAddListenerWithNonNullListener() { [EOL] MyObservable observable = new MyObservable(); [EOL] Listener mockListener = mock(Listener.class); [EOL] observable.addListener(mockListener); [EOL] assertTrue(observable.listeners.contains(mockListener)); [EOL] } [EOL] public void testAddListenerWithNullListener() { [EOL] MyObservable observable = new MyObservable(); [EOL] try { [EOL] observable.addListener(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Listener object cannot be null.", e.getMessage()); [EOL] } [EOL] }
public void testInitializeTransientFieldsWithValidArguments() { [EOL] Class<MyListener> listenerInterface = MyListener.class; [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] MyEventSource eventSource = new MyEventSource(); [EOL] eventSource.initializeTransientFields(listenerInterface, classLoader); [EOL] assertNotNull(eventSource.getPrototypeArray()); [EOL] assertTrue(Proxy.isProxyClass(eventSource.getPrototypeArray().getClass().getComponentType())); [EOL] }
public void testInitializeTransientFieldsWithNullListenerInterface() { [EOL] ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); [EOL] MyEventSource eventSource = new MyEventSource(); [EOL] try { [EOL] eventSource.initializeTransientFields(null, classLoader); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testInitializeTransientFieldsWithNullClassLoader() { [EOL] Class<MyListener> listenerInterface = MyListener.class; [EOL] MyEventSource eventSource = new MyEventSource(); [EOL] try { [EOL] eventSource.initializeTransientFields(listenerInterface, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) { [EOL] proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader, new Class[] { listenerInterface }, createInvocationHandler())); [EOL] }
protected InvocationHandler createInvocationHandler() { [EOL] return new ProxyInvocationHandler(); [EOL] }
public void testMutableFloatWithValidString() { [EOL] String validString = "10.5"; [EOL] MutableFloat mutableFloat = new MutableFloat(validString); [EOL] assertEquals(10.5f, mutableFloat.floatValue(), 0.0f); [EOL] }
public void testMutableFloatWithInvalidString() { [EOL] String invalidString = "invalid"; [EOL] try { [EOL] new MutableFloat(invalidString); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testMutableFloatWithNullString() { [EOL] String nullString = null; [EOL] try { [EOL] new MutableFloat(nullString); [EOL] fail("Should have thrown NumberFormatException for null string"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testEquals_withSameMutableFloatObject() { [EOL] MutableFloat mutableFloat1 = new MutableFloat(1.0f); [EOL] assertTrue(mutableFloat1.equals(mutableFloat1)); [EOL] } [EOL] public void testEquals_withDifferentMutableFloatObjectSameValue() { [EOL] MutableFloat mutableFloat1 = new MutableFloat(1.0f); [EOL] MutableFloat mutableFloat2 = new MutableFloat(1.0f); [EOL] assertTrue(mutableFloat1.equals(mutableFloat2)); [EOL] } [EOL] public void testEquals_withDifferentMutableFloatObjectDifferentValue() { [EOL] MutableFloat mutableFloat1 = new MutableFloat(1.0f); [EOL] MutableFloat mutableFloat2 = new MutableFloat(2.0f); [EOL] assertFalse(mutableFloat1.equals(mutableFloat2)); [EOL] } [EOL] public void testEquals_withNull() { [EOL] MutableFloat mutableFloat1 = new MutableFloat(1.0f); [EOL] assertFalse(mutableFloat1.equals(null)); [EOL] } [EOL] public void testEquals_withDifferentClass() { [EOL] MutableFloat mutableFloat1 = new MutableFloat(1.0f); [EOL] Object differentClassObject = new Object(); [EOL] assertFalse(mutableFloat1.equals(differentClassObject)); [EOL] }
public void testHashCode_PositiveValue() { [EOL] float testValue = 123.456f; [EOL] Float testFloat = new Float(testValue); [EOL] int expectedHashCode = Float.floatToIntBits(testValue); [EOL] assertEquals(expectedHashCode, testFloat.hashCode()); [EOL] }
public void testHashCode_NegativeValue() { [EOL] float testValue = -123.456f; [EOL] Float testFloat = new Float(testValue); [EOL] int expectedHashCode = Float.floatToIntBits(testValue); [EOL] assertEquals(expectedHashCode, testFloat.hashCode()); [EOL] }
public void testHashCode_ZeroValue() { [EOL] float testValue = 0.0f; [EOL] Float testFloat = new Float(testValue); [EOL] int expectedHashCode = Float.floatToIntBits(testValue); [EOL] assertEquals(expectedHashCode, testFloat.hashCode()); [EOL] }
public void testHashCode_NaNValue() { [EOL] float testValue = Float.NaN; [EOL] Float testFloat = new Float(testValue); [EOL] int expectedHashCode = Float.floatToIntBits(testValue); [EOL] assertEquals(expectedHashCode, testFloat.hashCode()); [EOL] }
public void testHashCode_PositiveInfinity() { [EOL] float testValue = Float.POSITIVE_INFINITY; [EOL] Float testFloat = new Float(testValue); [EOL] int expectedHashCode = Float.floatToIntBits(testValue); [EOL] assertEquals(expectedHashCode, testFloat.hashCode()); [EOL] }
public void testHashCode_NegativeInfinity() { [EOL] float testValue = Float.NEGATIVE_INFINITY; [EOL] Float testFloat = new Float(testValue); [EOL] int expectedHashCode = Float.floatToIntBits(testValue); [EOL] assertEquals(expectedHashCode, testFloat.hashCode()); [EOL] }
public void testGetPackageNameWithNullClass() { [EOL] String result = ClassNameUtils.getPackageName(null); [EOL] assertEquals("", result); [EOL] }
public void testGetPackageNameWithNonNullClass() { [EOL] String result = ClassNameUtils.getPackageName(Object.class); [EOL] assertEquals("java.lang", result); [EOL] }
public void testGetPackageName_NullOrEmpty() { [EOL] assertEquals("", ClassUtils.getPackageName(null)); [EOL] assertEquals("", ClassUtils.getPackageName("")); [EOL] } [EOL] public void testGetPackageName_WithoutPackage() { [EOL] assertEquals("", ClassUtils.getPackageName("ClassWithoutPackage")); [EOL] } [EOL] public void testGetPackageName_WithPackage() { [EOL] assertEquals("java.lang", ClassUtils.getPackageName("java.lang.String")); [EOL] } [EOL] public void testGetPackageName_Array() { [EOL] assertEquals("java.lang", ClassUtils.getPackageName("[Ljava.lang.String;")); [EOL] } [EOL] public void testGetPackageName_PrimitiveArray() { [EOL] assertEquals("", ClassUtils.getPackageName("[I")); [EOL] } [EOL] public void testGetPackageName_ObjectArray() { [EOL] assertEquals("java.lang", ClassUtils.getPackageName("[Ljava.lang.Object;")); [EOL] } [EOL] public void testGetPackageName_NestedArray() { [EOL] assertEquals("java.lang", ClassUtils.getPackageName("[[[Ljava.lang.String;")); [EOL] } [EOL] public void testGetPackageName_ClassInDefaultPackage() { [EOL] assertEquals("", ClassUtils.getPackageName("NoPackage")); [EOL] }
public void testGetAllInterfaces_WithNullInput() { [EOL] List<Class<?>> interfaces = ClassUtils.getAllInterfaces(null); [EOL] assertNull(interfaces); [EOL] } [EOL] public void testGetAllInterfaces_WithClassHavingNoInterfaces() { [EOL] List<Class<?>> interfaces = ClassUtils.getAllInterfaces(Object.class); [EOL] assertNotNull(interfaces); [EOL] assertTrue(interfaces.isEmpty()); [EOL] } [EOL] public void testGetAllInterfaces_WithClassHavingInterfaces() { [EOL] List<Class<?>> interfaces = ClassUtils.getAllInterfaces(ArrayList.class); [EOL] assertNotNull(interfaces); [EOL] assertFalse(interfaces.isEmpty()); [EOL] assertTrue(interfaces.contains(List.class)); [EOL] assertTrue(interfaces.contains(RandomAccess.class)); [EOL] assertTrue(interfaces.contains(Cloneable.class)); [EOL] assertTrue(interfaces.contains(Serializable.class)); [EOL] } [EOL] public void testGetAllInterfaces_WithInterfaceInput() { [EOL] List<Class<?>> interfaces = ClassUtils.getAllInterfaces(Serializable.class); [EOL] assertNotNull(interfaces); [EOL] assertTrue(interfaces.isEmpty()); [EOL] }
public void testGetAllInterfacesWithNullClass() { [EOL] HashSet<Class<?>> interfacesFound = new HashSet<>(); [EOL] getAllInterfaces(null, interfacesFound); [EOL] assertTrue(interfacesFound.isEmpty()); [EOL] }
public void testGetAllInterfacesWithNoInterfaces() { [EOL] HashSet<Class<?>> interfacesFound = new HashSet<>(); [EOL] getAllInterfaces(Object.class, interfacesFound); [EOL] assertTrue(interfacesFound.isEmpty()); [EOL] }
public void testGetAllInterfacesWithSingleInterface() { [EOL] HashSet<Class<?>> interfacesFound = new HashSet<>(); [EOL] getAllInterfaces(SingleInterfaceImplementer.class, interfacesFound); [EOL] assertEquals(1, interfacesFound.size()); [EOL] assertTrue(interfacesFound.contains(SingleInterface.class)); [EOL] }
public void testGetAllInterfacesWithMultipleInterfaces() { [EOL] HashSet<Class<?>> interfacesFound = new HashSet<>(); [EOL] getAllInterfaces(MultipleInterfacesImplementer.class, interfacesFound); [EOL] assertEquals(2, interfacesFound.size()); [EOL] assertTrue(interfacesFound.contains(FirstInterface.class)); [EOL] assertTrue(interfacesFound.contains(SecondInterface.class)); [EOL] }
public void testGetAllInterfacesWithInheritedInterfaces() { [EOL] HashSet<Class<?>> interfacesFound = new HashSet<>(); [EOL] getAllInterfaces(InheritingInterfaceImplementer.class, interfacesFound); [EOL] assertEquals(3, interfacesFound.size()); [EOL] assertTrue(interfacesFound.contains(FirstInterface.class)); [EOL] assertTrue(interfacesFound.contains(SecondInterface.class)); [EOL] assertTrue(interfacesFound.contains(InheritedInterface.class)); [EOL] }
public void testGetShortCanonicalNameWithNullObject() { [EOL] String result = ClassName.getShortCanonicalName(null, "DefaultValue"); [EOL] assertEquals("DefaultValue", result); [EOL] }
public void testGetShortCanonicalNameWithNonNullObject() { [EOL] Object obj = new Object(); [EOL] String result = ClassName.getShortCanonicalName(obj, "DefaultValue"); [EOL] String expected = obj.getClass().getSimpleName(); [EOL] assertEquals(expected, result); [EOL] }
public void testGetShortCanonicalName_NullClass() { [EOL] String result = ClassUtils.getShortCanonicalName(null); [EOL] assertEquals("", result); [EOL] }
public void testGetShortCanonicalName_NonNullClass() { [EOL] String result = ClassUtils.getShortCanonicalName(Object.class); [EOL] assertEquals("Object", result); [EOL] }
public static String[][] HTML40_EXTENDED_ESCAPE() { [EOL] return HTML40_EXTENDED_ESCAPE.clone(); [EOL] }
public void testNumericEntityEscaperConstructor() { [EOL] NumericEntityEscaper escaper = new NumericEntityEscaper(); [EOL] assertNotNull(escaper); [EOL] assertTrue(escaper.isSet(Integer.MIN_VALUE)); [EOL] assertTrue(escaper.isSet(Integer.MAX_VALUE)); [EOL] }
public void testHandleCauseWithConcurrentException() throws ExecutionException { [EOL] ExecutionException ex = new ExecutionException(new ConcurrentException()); [EOL] try { [EOL] ConcurrentUtils.handleCause(ex); [EOL] fail("Should have thrown ConcurrentException"); [EOL] } catch (ConcurrentException cex) { [EOL] } [EOL] }
public void testHandleCauseWithNullException() throws ExecutionException { [EOL] ExecutionException ex = new ExecutionException(null); [EOL] ConcurrentUtils.handleCause(ex); [EOL] }
public void testHandleCauseWithNonConcurrentException() throws ExecutionException { [EOL] ExecutionException ex = new ExecutionException(new RuntimeException()); [EOL] try { [EOL] ConcurrentUtils.handleCause(ex); [EOL] fail("Should have thrown ExecutionException"); [EOL] } catch (ConcurrentException cex) { [EOL] fail("Should not have wrapped a non-ConcurrentException"); [EOL] } catch (RuntimeException rex) { [EOL] } [EOL] }
public void testCheckedExceptionWithCheckedException() { [EOL] Exception checkedException = new Exception(); [EOL] Throwable result = YourClass.checkedException(checkedException); [EOL] assertSame("Expected the checked exception to be returned as is", checkedException, result); [EOL] }
public void testCheckedExceptionWithRuntimeException() { [EOL] try { [EOL] YourClass.checkedException(new RuntimeException()); [EOL] fail("Expected IllegalArgumentException to be thrown for RuntimeException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Not a checked exception: java.lang.RuntimeException", e.getMessage()); [EOL] } [EOL] }
public void testCheckedExceptionWithError() { [EOL] try { [EOL] YourClass.checkedException(new Error()); [EOL] fail("Expected IllegalArgumentException to be thrown for Error"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Not a checked exception: java.lang.Error", e.getMessage()); [EOL] } [EOL] }
public void testCheckedExceptionWithNull() { [EOL] try { [EOL] YourClass.checkedException(null); [EOL] fail("Expected IllegalArgumentException to be thrown for null"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Not a checked exception: null", e.getMessage()); [EOL] } [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL] return timeZone; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; };
@Override [EOL] public int hashCode() { [EOL] return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode()); [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public String toString() { [EOL] return "FastDateParser[" + pattern + "," + locale + "," + timeZone.getID() + "]"; [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException { [EOL] in.defaultReadObject(); [EOL] init(); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale) { [EOL] return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
boolean isNumber() { [EOL] return false; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);  CopyQuotedStrategy(final String formatField);  TextStrategy(final int field, final Calendar definingCalendar, final Locale locale);  NumberStrategy(final int field);  TimeZoneStrategy(final Locale locale); private void init(); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale();  Pattern getParsePattern(); public boolean equals(final Object obj); public int hashCode(); public String toString(); private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; public Object parseObject(final String source) throws ParseException; public Date parse(final String source) throws ParseException; public Object parseObject(final String source, final ParsePosition pos); public Date parse(final String source, final ParsePosition pos); private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale);  int adjustYear(final int twoDigitYear);  boolean isNextNumber();  int getFieldWidth();  boolean isNumber();  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  abstract boolean addRegex(FastDateParser parser, StringBuilder regex); private Strategy getStrategy(String formatField, final Calendar definingCalendar); private static ConcurrentMap<Locale, Strategy> getCache(final int field); private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean isNumber();  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  boolean addRegex(final FastDateParser parser, final StringBuilder regex);  void setCalendar(final FastDateParser parser, final Calendar cal, final String value);  int modify(final int iValue);  int modify(final int iValue);  int modify(final int iValue); long serialVersionUID=1L; Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); String pattern; TimeZone timeZone; Locale locale; Pattern parsePattern; Strategy[] strategies; int thisYear; String currentFormatField; Strategy nextStrategy; Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) {; ;     void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {;         int iValue = Integer.parseInt(value);;         if (iValue < 100) {;             iValue = parser.adjustYear(iValue);;         };         cal.set(Calendar.YEAR, iValue);;     }; }; Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) {; ;     int modify(final int iValue) {;         return iValue - 1;;     }; }; Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) {; ;     int modify(final int iValue) {;         return iValue % 24;;     }; }; Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) {; ;     int modify(final int iValue) {;         return iValue % 12;;     }; };
public void testGetStrategyWithSingleQuote() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("'SingleQuote'", definingCalendar); [EOL] assertTrue(result instanceof CopyQuotedStrategy); [EOL] } [EOL] public void testGetStrategyWithDayOfYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("D", definingCalendar); [EOL] assertSame(DAY_OF_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithDayOfWeek() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("E", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithDayOfWeekInMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("F", definingCalendar); [EOL] assertSame(DAY_OF_WEEK_IN_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithEra() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("G", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithHourOfDay() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("H", definingCalendar); [EOL] assertSame(MODULO_HOUR_OF_DAY_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHour() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("K", definingCalendar); [EOL] assertSame(HOUR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("M", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithMillisecond() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("S", definingCalendar); [EOL] assertSame(MILLISECOND_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithWeekOfMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("W", definingCalendar); [EOL] assertSame(WEEK_OF_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithAmPm() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("a", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithDayOfMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("d", definingCalendar); [EOL] assertSame(DAY_OF_MONTH_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHourInAmPm() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("h", definingCalendar); [EOL] assertSame(MODULO_HOUR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithHourOfDayOneBased() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("k", definingCalendar); [EOL] assertSame(HOUR_OF_DAY_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithMinute() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("m", definingCalendar); [EOL] assertSame(MINUTE_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithSecond() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("s", definingCalendar); [EOL] assertSame(SECOND_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithWeekOfYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("w", definingCalendar); [EOL] assertSame(WEEK_OF_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("y", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithTimeZoneOffset() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("Z", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithTimeZone() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("z", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithLongMonth() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("MMM", definingCalendar); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetStrategyWithLongYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("yyyy", definingCalendar); [EOL] assertSame(LITERAL_YEAR_STRATEGY, result); [EOL] } [EOL] public void testGetStrategyWithShortYear() { [EOL] Calendar definingCalendar = Calendar.getInstance(); [EOL] Strategy result = getStrategy("yy", definingCalendar); [EOL] assertSame(ABBREVIATED_YEAR_STRATEGY, result); [EOL] }
TextStrategy(final int field, final Calendar definingCalendar, final Locale locale) { [EOL] this.field = field; [EOL] this.keyValues = getDisplayNames(field, definingCalendar, locale); [EOL] } [EOL] protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] }; [EOL] cal.set(Calendar.YEAR, iValue); [EOL] }; [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] }; [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] }; [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] }; [EOL] };
public void testSetCalendarWithPlusTimezone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "+0200"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("GMT+0200", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithMinusTimezone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "-0200"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("GMT-0200", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithGMTTimezone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "GMT+0200"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("GMT+0200", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithNamedTimezone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "Europe/Paris"; [EOL] parser.setCalendar(parser, cal, value); [EOL] assertEquals("Europe/Paris", cal.getTimeZone().getID()); [EOL] }
public void testSetCalendarWithInvalidTimezone() { [EOL] FastDateParser parser = new FastDateParser("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] Calendar cal = Calendar.getInstance(); [EOL] String value = "Invalid/Timezone"; [EOL] try { [EOL] parser.setCalendar(parser, cal, value); [EOL] fail("Should have thrown IllegalArgumentException for invalid timezone"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
@Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] CopyQuotedStrategy(final String formatField); [EOL] TextStrategy(final int field, final Calendar definingCalendar, final Locale locale); [EOL] NumberStrategy(final int field); [EOL] TimeZoneStrategy(final Locale locale); [EOL] private void init(); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] Pattern getParsePattern(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException; [EOL] public Object parseObject(final String source) throws ParseException; [EOL] public Date parse(final String source) throws ParseException; [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote); [EOL] private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale); [EOL] int adjustYear(final int twoDigitYear); [EOL] boolean isNextNumber(); [EOL] int getFieldWidth(); [EOL] boolean isNumber(); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] abstract boolean addRegex(FastDateParser parser, StringBuilder regex); [EOL] private Strategy getStrategy(String formatField, final Calendar definingCalendar); [EOL] private static ConcurrentMap<Locale, Strategy> getCache(final int field); [EOL] private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean isNumber(); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] boolean addRegex(final FastDateParser parser, final StringBuilder regex); [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] int modify(final int iValue); [EOL] long serialVersionUID=1L; [EOL] Locale JAPANESE_IMPERIAL=new Locale("ja", "JP", "JP"); [EOL] String pattern; [EOL] TimeZone timeZone; [EOL] Locale locale; [EOL] Pattern parsePattern; [EOL] Strategy[] strategies; [EOL] int thisYear; [EOL] String currentFormatField; [EOL] Strategy nextStrategy; [EOL] Pattern formatPattern=Pattern.compile("D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++"); [EOL] ConcurrentMap<Locale, Strategy>[] caches=new ConcurrentMap[Calendar.FIELD_COUNT]; [EOL] Strategy ABBREVIATED_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR) { [EOL] @Override [EOL] void setCalendar(final FastDateParser parser, final Calendar cal, final String value) { [EOL] int iValue = Integer.parseInt(value); [EOL] if (iValue < 100) { [EOL] iValue = parser.adjustYear(iValue); [EOL] } [EOL] cal.set(Calendar.YEAR, iValue); [EOL] } [EOL] }; [EOL] Strategy NUMBER_MONTH_STRATEGY=new NumberStrategy(Calendar.MONTH) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue - 1; [EOL] } [EOL] }; [EOL] Strategy LITERAL_YEAR_STRATEGY=new NumberStrategy(Calendar.YEAR); [EOL] Strategy WEEK_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_YEAR); [EOL] Strategy WEEK_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.WEEK_OF_MONTH); [EOL] Strategy DAY_OF_YEAR_STRATEGY=new NumberStrategy(Calendar.DAY_OF_YEAR); [EOL] Strategy DAY_OF_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_MONTH); [EOL] Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY=new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH); [EOL] Strategy HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY); [EOL] Strategy MODULO_HOUR_OF_DAY_STRATEGY=new NumberStrategy(Calendar.HOUR_OF_DAY) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 24; [EOL] } [EOL] }; [EOL] Strategy MODULO_HOUR_STRATEGY=new NumberStrategy(Calendar.HOUR) { [EOL] @Override [EOL] int modify(final int iValue) { [EOL] return iValue % 12; [EOL] } [EOL] };
public void testReplaceWithNullSourceAndEmptyValueMap() { [EOL] String result = StringUtils.replace(null, Collections.emptyMap()); [EOL] assertNull(result); [EOL] } [EOL] public void testReplaceWithEmptyStringSourceAndEmptyValueMap() { [EOL] String result = StringUtils.replace("", Collections.emptyMap()); [EOL] assertEquals("", result); [EOL] } [EOL] public void testReplaceWithNonEmptyStringSourceAndEmptyValueMap() { [EOL] String result = StringUtils.replace("test", Collections.emptyMap()); [EOL] assertEquals("test", result); [EOL] } [EOL] public void testReplaceWithNonEmptyStringSourceAndNonEmptyValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", "pass"); [EOL] String result = StringUtils.replace("This is a test.", valueMap); [EOL] assertEquals("This is a pass.", result); [EOL] } [EOL] public void testReplaceWithNonEmptyStringSourceAndNonMatchingValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("none", "pass"); [EOL] String result = StringUtils.replace("This is a test.", valueMap); [EOL] assertEquals("This is a test.", result); [EOL] } [EOL] public void testReplaceWithSpecialCharactersInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", "pa$$"); [EOL] String result = StringUtils.replace("This is a test.", valueMap); [EOL] assertEquals("This is a pa$$.", result); [EOL] } [EOL] public void testReplaceWithPrefixAndSuffixInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", "pass"); [EOL] String result = StringUtils.replace("This is a ${test}.", valueMap, "${", "}"); [EOL] assertEquals("This is a pass.", result); [EOL] } [EOL] public void testReplaceWithEscapeCharacterInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", "pass"); [EOL] String result = StringUtils.replace("This is a $${test}.", valueMap, "${", "}", '$'); [EOL] assertEquals("This is a ${test}.", result); [EOL] } [EOL] public void testReplaceWithNullValueInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", null); [EOL] String result = StringUtils.replace("This is a ${test}.", valueMap, "${", "}"); [EOL] assertEquals("This is a .", result); [EOL] } [EOL] public void testReplaceWithEmptyValueInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", ""); [EOL] String result = StringUtils.replace("This is a ${test}.", valueMap, "${", "}"); [EOL] assertEquals("This is a .", result); [EOL] } [EOL] public void testReplaceWithRecursiveValueInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", "${nested}"); [EOL] valueMap.put("nested", "pass"); [EOL] String result = StringUtils.replace("This is a ${test}.", valueMap, "${", "}"); [EOL] assertEquals("This is a pass.", result); [EOL] } [EOL] public void testReplaceWithCyclicValueInValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("test", "${nested}"); [EOL] valueMap.put("nested", "${test}"); [EOL] try { [EOL] StringUtils.replace("This is a ${test}.", valueMap, "${", "}"); [EOL] fail("Should have thrown IllegalStateException due to cyclic substitution"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testReplaceWithMapAndPrefixSuffix() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String result = StringUtils.replace("prefix_key_suffix", valueMap, "prefix_", "_suffix"); [EOL] assertEquals("value", result); [EOL] }
public void testReplaceWithNullSource() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String result = StringUtils.replace(null, valueMap, "prefix_", "_suffix"); [EOL] assertNull(result); [EOL] }
public void testReplaceWithEmptyMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] String result = StringUtils.replace("prefix_key_suffix", valueMap, "prefix_", "_suffix"); [EOL] assertEquals("prefix_key_suffix", result); [EOL] }
public void testReplaceWithNullMap() { [EOL] String result = StringUtils.replace("prefix_key_suffix", null, "prefix_", "_suffix"); [EOL] assertEquals("prefix_key_suffix", result); [EOL] }
public void testReplaceWithEmptyPrefixSuffix() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String result = StringUtils.replace("key", valueMap, "", ""); [EOL] assertEquals("value", result); [EOL] }
public void testReplaceWithNullPrefixSuffix() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String result = StringUtils.replace("key", valueMap, null, null); [EOL] assertEquals("value", result); [EOL] }
public void testReplaceWithNullProperties() { [EOL] Object source = "The quick brown fox jumps over the lazy dog."; [EOL] String result = StrSubstitutor.replace(source, (Properties) null); [EOL] assertEquals("The quick brown fox jumps over the lazy dog.", result); [EOL] }
public void testReplaceWithEmptyProperties() { [EOL] Object source = "The quick brown fox jumps over the lazy dog."; [EOL] Properties valueProperties = new Properties(); [EOL] String result = StrSubstitutor.replace(source, valueProperties); [EOL] assertEquals("The quick brown fox jumps over the lazy dog.", result); [EOL] }
public void testReplaceWithNonEmptyProperties() { [EOL] Object source = "The quick brown ${animal} jumps over the lazy dog."; [EOL] Properties valueProperties = new Properties(); [EOL] valueProperties.setProperty("animal", "fox"); [EOL] String result = StrSubstitutor.replace(source, valueProperties); [EOL] assertEquals("The quick brown fox jumps over the lazy dog.", result); [EOL] }
public void testStrSubstitutorConstructorWithMapPrefixSuffix() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String prefix = "${"; [EOL] String suffix = "}"; [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, prefix, suffix); [EOL] assertNotNull(substitutor); [EOL] assertEquals(prefix, substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals(suffix, substitutor.getVariableSuffixMatcher().toString()); [EOL] }

public void testStrSubstitutorConstructorWithVariableResolverPrefixSuffixEscape() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] String prefix = "${"; [EOL] String suffix = "}"; [EOL] char escape = '$'; [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, prefix, suffix, escape); [EOL] assertEquals("VariableResolver should be set", variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals("Prefix should be set", prefix, substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("Suffix should be set", suffix, substitutor.getVariableSuffixMatcher().toString()); [EOL] assertEquals("Escape char should be set", escape, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorDefaultConstructor() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] assertNull("VariableResolver should be null", substitutor.getVariableResolver()); [EOL] assertEquals("Prefix should be default", StrSubstitutor.DEFAULT_PREFIX, substitutor.getVariablePrefixMatcher()); [EOL] assertEquals("Suffix should be default", StrSubstitutor.DEFAULT_SUFFIX, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals("Escape char should be default", StrSubstitutor.DEFAULT_ESCAPE, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithValueMap() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap); [EOL] assertNotNull("VariableResolver should be set", substitutor.getVariableResolver()); [EOL] }
public void testStrSubstitutorConstructorWithValueMapPrefixSuffix() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String prefix = "${"; [EOL] String suffix = "}"; [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, prefix, suffix); [EOL] assertNotNull("VariableResolver should be set", substitutor.getVariableResolver()); [EOL] assertEquals("Prefix should be set", prefix, substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("Suffix should be set", suffix, substitutor.getVariableSuffixMatcher().toString()); [EOL] }
public void testStrSubstitutorConstructorWithValueMapPrefixSuffixEscape() { [EOL] Map<String, String> valueMap = new HashMap<>(); [EOL] valueMap.put("key", "value"); [EOL] String prefix = "${"; [EOL] String suffix = "}"; [EOL] char escape = '$'; [EOL] StrSubstitutor substitutor = new StrSubstitutor(valueMap, prefix, suffix, escape); [EOL] assertNotNull("VariableResolver should be set", substitutor.getVariableResolver()); [EOL] assertEquals("Prefix should be set", prefix, substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("Suffix should be set", suffix, substitutor.getVariableSuffixMatcher().toString()); [EOL] assertEquals("Escape char should be set", escape, substitutor.getEscapeChar()); [EOL] }
public void testStrSubstitutorConstructorWithVariableResolver() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver); [EOL] assertEquals("VariableResolver should be set", variableResolver, substitutor.getVariableResolver()); [EOL] }
public void testStrSubstitutorConstructorWithVariableResolverPrefixSuffix() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] String prefix = "${"; [EOL] String suffix = "}"; [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, prefix, suffix); [EOL] assertEquals("VariableResolver should be set", variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals("Prefix should be set", prefix, substitutor.getVariablePrefixMatcher().toString()); [EOL] assertEquals("Suffix should be set", suffix, substitutor.getVariableSuffixMatcher().toString()); [EOL] }
public void testStrSubstitutorConstructorWithVariableResolverPrefixMatcherSuffixMatcherEscape() { [EOL] StrLookup<?> variableResolver = StrLookup.systemPropertiesLookup(); [EOL] StrMatcher prefixMatcher = StrMatcher.stringMatcher("${"); [EOL] StrMatcher suffixMatcher = StrMatcher.stringMatcher("}"); [EOL] char escape = '$'; [EOL] StrSubstitutor substitutor = new StrSubstitutor(variableResolver, prefixMatcher, suffixMatcher, escape); [EOL] assertEquals("VariableResolver should be set", variableResolver, substitutor.getVariableResolver()); [EOL] assertEquals("PrefixMatcher should be set", prefixMatcher, substitutor.getVariablePrefixMatcher()); [EOL] assertEquals("SuffixMatcher should be set", suffixMatcher, substitutor.getVariableSuffixMatcher()); [EOL] assertEquals("Escape char should be set", escape, substitutor.getEscapeChar()); [EOL] }
private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) { [EOL] final StrMatcher prefixMatcher = getVariablePrefixMatcher(); [EOL] final StrMatcher suffixMatcher = getVariableSuffixMatcher(); [EOL] final char escape = getEscapeChar(); [EOL] final boolean top = priorVariables == null; [EOL] boolean altered = false; [EOL] int lengthChange = 0; [EOL] char[] chars = buf.buffer; [EOL] int bufEnd = offset + length; [EOL] int pos = offset; [EOL] while (pos < bufEnd) { [EOL] final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL] if (startMatchLen == 0) { [EOL] pos++; [EOL] } else { [EOL] if (pos > offset && chars[pos - 1] == escape) { [EOL] buf.deleteCharAt(pos - 1); [EOL] chars = buf.buffer; [EOL] lengthChange--; [EOL] altered = true; [EOL] bufEnd--; [EOL] } else { [EOL] final int startPos = pos; [EOL] pos += startMatchLen; [EOL] int endMatchLen = 0; [EOL] int nestedVarCount = 0; [EOL] while (pos < bufEnd) { [EOL] if (isEnableSubstitutionInVariables() && (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) { [EOL] nestedVarCount++; [EOL] pos += endMatchLen; [EOL] continue; [EOL] } [EOL] endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd); [EOL] if (endMatchLen == 0) { [EOL] pos++; [EOL] } else { [EOL] if (nestedVarCount == 0) { [EOL] String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen); [EOL] if (isEnableSubstitutionInVariables()) { [EOL] final StrBuilder bufName = new StrBuilder(varName); [EOL] substitute(bufName, 0, bufName.length()); [EOL] varName = bufName.toString(); [EOL] } [EOL] pos += endMatchLen; [EOL] final int endPos = pos; [EOL] if (priorVariables == null) { [EOL] priorVariables = new ArrayList<String>(); [EOL] priorVariables.add(new String(chars, offset, length)); [EOL] } [EOL] checkCyclicSubstitution(varName, priorVariables); [EOL] priorVariables.add(varName); [EOL] final String varValue = resolveVariable(varName, buf, startPos, endPos); [EOL] if (varValue != null) { [EOL] final int varLen = varValue.length(); [EOL] buf.replace(startPos, endPos, varValue); [EOL] altered = true; [EOL] int change = substitute(buf, startPos, varLen, priorVariables); [EOL] change = change + varLen - (endPos - startPos); [EOL] pos += change; [EOL] bufEnd += change; [EOL] lengthChange += change; [EOL] chars = buf.buffer; [EOL] } [EOL] priorVariables.remove(priorVariables.size() - 1); [EOL] break; [EOL] } else { [EOL] nestedVarCount--; [EOL] pos += endMatchLen; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] } [EOL] if (top) { [EOL] return altered ? 1 : 0; [EOL] } [EOL] return lengthChange; [EOL] } [EOL] public StrSubstitutor(); [EOL] public StrSubstitutor(final Map<String, V> valueMap); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape); [EOL] public StrSubstitutor(final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape); [EOL] public static String replace(final Object source, final Map<String, V> valueMap); [EOL] public static String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix); [EOL] public static String replace(final Object source, final Properties valueProperties); [EOL] public static String replaceSystemProperties(final Object source); [EOL] public String replace(final String source); [EOL] public String replace(final String source, final int offset, final int length); [EOL] public String replace(final char[] source); [EOL] public String replace(final char[] source, final int offset, final int length); [EOL] public String replace(final StringBuffer source); [EOL] public String replace(final StringBuffer source, final int offset, final int length); [EOL] public String replace(CharSequence source); [EOL] public String replace(CharSequence source, int offset, int length); [EOL] public String replace(final StrBuilder source); [EOL] public String replace(final StrBuilder source, final int offset, final int length); [EOL] public String replace(final Object source); [EOL] public boolean replaceIn(final StringBuffer source); [EOL] public boolean replaceIn(final StringBuffer source, final int offset, final int length); [EOL] public boolean replaceIn(StringBuilder source); [EOL] public boolean replaceIn(StringBuilder source, int offset, int length); [EOL] public boolean replaceIn(final StrBuilder source); [EOL] public boolean replaceIn(final StrBuilder source, final int offset, final int length); [EOL] protected boolean substitute(final StrBuilder buf, final int offset, final int length); [EOL] private void checkCyclicSubstitution(final String varName, final List<String> priorVariables); [EOL] protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos); [EOL] public char getEscapeChar(); [EOL] public void setEscapeChar(final char escapeCharacter); [EOL] public StrMatcher getVariablePrefixMatcher(); [EOL] public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher); [EOL] public StrSubstitutor setVariablePrefix(final char prefix); [EOL] public StrSubstitutor setVariablePrefix(final String prefix); [EOL] public StrMatcher getVariableSuffixMatcher(); [EOL] public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher); [EOL] public StrSubstitutor setVariableSuffix(final char suffix); [EOL] public StrSubstitutor setVariableSuffix(final String suffix); [EOL] public StrLookup<?> getVariableResolver(); [EOL] public void setVariableResolver(final StrLookup<?> variableResolver); [EOL] public boolean isEnableSubstitutionInVariables(); [EOL] public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables); [EOL] char DEFAULT_ESCAPE=Optional['$']; [EOL] StrMatcher DEFAULT_PREFIX=Optional[StrMatcher.stringMatcher("${")]; [EOL] StrMatcher DEFAULT_SUFFIX=Optional[StrMatcher.stringMatcher("}")];
public void testSetVariablePrefixMatcherWithNonNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] StrMatcher prefixMatcher = StrMatcher.stringMatcher("<<"); [EOL] substitutor.setVariablePrefixMatcher(prefixMatcher); [EOL] assertEquals(prefixMatcher, substitutor.getVariablePrefixMatcher()); [EOL] }
public void testSetVariablePrefixMatcherWithNull() { [EOL] StrSubstitutor substitutor = new StrSubstitutor(); [EOL] try { [EOL] substitutor.setVariablePrefixMatcher(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetVariablePrefixWithChar() { [EOL] StrSubstitutor sub = new StrSubstitutor(); [EOL] char prefix = '#'; [EOL] sub.setVariablePrefix(prefix); [EOL] assertEquals(StrMatcher.charMatcher(prefix), sub.getVariablePrefixMatcher()); [EOL] }
public void testSetVariablePrefixWithNullPrefix() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] try { [EOL] strSubstitutor.setVariablePrefix(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Variable prefix must not be null!", ex.getMessage()); [EOL] } [EOL] }
public void testSetVariablePrefixWithValidPrefix() { [EOL] StrSubstitutor strSubstitutor = new StrSubstitutor(); [EOL] String prefix = "prefix"; [EOL] StrSubstitutor result = strSubstitutor.setVariablePrefix(prefix); [EOL] assertNotNull(result); [EOL] assertEquals(prefix, result.getVariablePrefixMatcher().toString()); [EOL] }
public void testGetFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(1, 0); [EOL] fail("Expected ArithmeticException due to zero denominator"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_NegativeDenominator() { [EOL] Fraction result = Fraction.getFraction(-1, -2); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] }
public void testGetFraction_PositiveDenominator() { [EOL] Fraction result = Fraction.getFraction(1, 2); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] }
public void testGetFraction_NumeratorMinValue_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(Integer.MIN_VALUE, -1); [EOL] fail("Expected ArithmeticException due to numerator being Integer.MIN_VALUE"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetFraction_DenominatorMinValue_ThrowsException() { [EOL] try { [EOL] Fraction.getFraction(-1, Integer.MIN_VALUE); [EOL] fail("Expected ArithmeticException due to denominator being Integer.MIN_VALUE"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_ZeroDenominator_ThrowsException() { [EOL] try { [EOL] Fraction.getReducedFraction(1, 0); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("The denominator must not be zero", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_ZeroNumerator_ReturnsZero() { [EOL] Fraction result = Fraction.getReducedFraction(0, 1); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_NegativeDenominator_PositiveNumerator() { [EOL] Fraction result = Fraction.getReducedFraction(1, -1); [EOL] assertNotNull(result); [EOL] assertEquals(-1, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_NegativeDenominator_NegativeNumerator() { [EOL] Fraction result = Fraction.getReducedFraction(-1, -1); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testGetReducedFraction_MinValueDenominator_EvenNumerator() { [EOL] Fraction result = Fraction.getReducedFraction(2, Integer.MIN_VALUE); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(Integer.MIN_VALUE / 2, result.getDenominator()); [EOL] }
public void testGetReducedFraction_MinValueDenominator_OddNumerator() { [EOL] try { [EOL] Fraction.getReducedFraction(1, Integer.MIN_VALUE); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_MinValueNumerator_NegativeDenominator() { [EOL] try { [EOL] Fraction.getReducedFraction(Integer.MIN_VALUE, -1); [EOL] fail("Expected ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate", ae.getMessage()); [EOL] } [EOL] }
public void testGetReducedFraction_RegularFraction_ReducedProperly() { [EOL] Fraction result = Fraction.getReducedFraction(2, 4); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getNumerator()); [EOL] assertEquals(2, result.getDenominator()); [EOL] }
public void testGetFractionWithPositiveValue() { [EOL] double value = 0.5; [EOL] Fraction result = Fraction.getFraction(value); [EOL] assertEquals("The fraction should be 1/2", Fraction.getFraction(1, 2), result); [EOL] }
public void testGetFractionWithNegativeValue() { [EOL] double value = -0.5; [EOL] Fraction result = Fraction.getFraction(value); [EOL] assertEquals("The fraction should be -1/2", Fraction.getFraction(-1, 2), result); [EOL] }
public void testGetFractionWithZeroValue() { [EOL] double value = 0.0; [EOL] Fraction result = Fraction.getFraction(value); [EOL] assertEquals("The fraction should be 0/1", Fraction.getFraction(0, 1), result); [EOL] }
public void testGetFractionWithValueGreaterThanMaxInt() { [EOL] double value = Integer.MAX_VALUE + 1.0; [EOL] try { [EOL] Fraction.getFraction(value); [EOL] fail("Should have thrown an ArithmeticException because the value is too large."); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testGetFractionWithNaN() { [EOL] double value = Double.NaN; [EOL] try { [EOL] Fraction.getFraction(value); [EOL] fail("Should have thrown an ArithmeticException because the value is NaN."); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testGetFractionWithInfiniteValue() { [EOL] double value = Double.POSITIVE_INFINITY; [EOL] try { [EOL] Fraction.getFraction(value); [EOL] fail("Should have thrown an ArithmeticException because the value is infinite."); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testGetFractionWithMaxIterations() { [EOL] double value = 1.0 / 3.0; [EOL] try { [EOL] Fraction.getFraction(value); [EOL] fail("Should have thrown an ArithmeticException because the maximum number of iterations was reached."); [EOL] } catch (ArithmeticException ae) { [EOL] } [EOL] }
public void testGetFraction_NullString() { [EOL] try { [EOL] Fraction.getFraction(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The string must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testGetFraction_DecimalString() { [EOL] Fraction fraction = Fraction.getFraction("0.5"); [EOL] assertNotNull(fraction); [EOL] assertEquals(1, fraction.getNumerator()); [EOL] assertEquals(2, fraction.getDenominator()); [EOL] }
public void testGetFraction_WholeWithFractionString() { [EOL] Fraction fraction = Fraction.getFraction("1 2/3"); [EOL] assertNotNull(fraction); [EOL] assertEquals(5, fraction.getNumerator()); [EOL] assertEquals(3, fraction.getDenominator()); [EOL] }
public void testGetFraction_InvalidWholeWithFractionString() { [EOL] try { [EOL] Fraction.getFraction("1 2"); [EOL] fail("Expected NumberFormatException"); [EOL] } catch (NumberFormatException ex) { [EOL] assertEquals("The fraction could not be parsed as the format X Y/Z", ex.getMessage()); [EOL] } [EOL] }
public void testGetFraction_SimpleFractionString() { [EOL] Fraction fraction = Fraction.getFraction("3/4"); [EOL] assertNotNull(fraction); [EOL] assertEquals(3, fraction.getNumerator()); [EOL] assertEquals(4, fraction.getDenominator()); [EOL] }
public void testGetFraction_WholeNumberString() { [EOL] Fraction fraction = Fraction.getFraction("5"); [EOL] assertNotNull(fraction); [EOL] assertEquals(5, fraction.getNumerator()); [EOL] assertEquals(1, fraction.getDenominator()); [EOL] }
public void testReduce_ZeroNumerator() { [EOL] Fraction zeroFraction = new Fraction(0, 3); [EOL] Fraction result = zeroFraction.reduce(); [EOL] assertEquals(Fraction.ZERO, result); [EOL] } [EOL] public void testReduce_AlreadyInLowestTerms() { [EOL] Fraction fraction = new Fraction(1, 3); [EOL] Fraction result = fraction.reduce(); [EOL] assertSame(fraction, result); [EOL] } [EOL] public void testReduce_NeedsReduction() { [EOL] Fraction fraction = new Fraction(2, 4); [EOL] Fraction result = fraction.reduce(); [EOL] assertEquals(new Fraction(1, 2), result); [EOL] } [EOL] public void testReduce_NegativeNumerator() { [EOL] Fraction fraction = new Fraction(-2, 4); [EOL] Fraction result = fraction.reduce(); [EOL] assertEquals(new Fraction(-1, 2), result); [EOL] } [EOL] public void testReduce_NegativeDenominator() { [EOL] Fraction fraction = new Fraction(2, -4); [EOL] Fraction result = fraction.reduce(); [EOL] assertEquals(new Fraction(-1, 2), result); [EOL] } [EOL] public void testReduce_NegativeBoth() { [EOL] Fraction fraction = new Fraction(-2, -4); [EOL] Fraction result = fraction.reduce(); [EOL] assertEquals(new Fraction(1, 2), result); [EOL] } [EOL] public void testReduce_LargeNumbers() { [EOL] Fraction fraction = new Fraction(100, 200); [EOL] Fraction result = fraction.reduce(); [EOL] assertEquals(new Fraction(1, 2), result); [EOL] }
public void testInvert_ZeroNumerator() { [EOL] Fraction fraction = new Fraction(0, 1); [EOL] try { [EOL] fraction.invert(); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("Unable to invert zero.", ae.getMessage()); [EOL] } [EOL] }
public void testInvert_MinValueNumerator() { [EOL] Fraction fraction = new Fraction(Integer.MIN_VALUE, 1); [EOL] try { [EOL] fraction.invert(); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException ae) { [EOL] assertEquals("overflow: can't negate numerator", ae.getMessage()); [EOL] } [EOL] }
public void testInvert_NegativeNumerator() { [EOL] Fraction fraction = new Fraction(-1, 2); [EOL] Fraction result = fraction.invert(); [EOL] assertEquals(2, result.getNumerator()); [EOL] assertEquals(-1, result.getDenominator()); [EOL] }
public void testInvert_PositiveNumerator() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] Fraction result = fraction.invert(); [EOL] assertEquals(2, result.getNumerator()); [EOL] assertEquals(1, result.getDenominator()); [EOL] }
public void testPowPowerOne() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.pow(1); [EOL] assertEquals(fraction, result); [EOL] }
public void testPowPowerZero() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.pow(0); [EOL] assertEquals(Fraction.ONE, result); [EOL] }
public void testPowNegativePower() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.pow(-1); [EOL] assertEquals(fraction.invert(), result); [EOL] }
public void testPowNegativePowerMinValue() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.pow(Integer.MIN_VALUE); [EOL] Fraction expected = fraction.invert().pow(2).pow(-(Integer.MIN_VALUE / 2)); [EOL] assertEquals(expected, result); [EOL] }
public void testPowEvenPositivePower() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.pow(2); [EOL] Fraction expected = fraction.multiplyBy(fraction); [EOL] assertEquals(expected, result); [EOL] }
public void testPowOddPositivePower() { [EOL] Fraction fraction = new Fraction(3, 4); [EOL] Fraction result = fraction.pow(3); [EOL] Fraction expected = fraction.multiplyBy(fraction).multiplyBy(fraction); [EOL] assertEquals(expected, result); [EOL] }
public void testGreatestCommonDivisor_bothZero() { [EOL] try { [EOL] greatestCommonDivisor(0, 0); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] } [EOL] public void testGreatestCommonDivisor_oneZero() { [EOL] assertEquals(10, greatestCommonDivisor(0, 10)); [EOL] assertEquals(10, greatestCommonDivisor(10, 0)); [EOL] } [EOL] public void testGreatestCommonDivisor_oneMinValue() { [EOL] try { [EOL] greatestCommonDivisor(Integer.MIN_VALUE, 0); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] try { [EOL] greatestCommonDivisor(0, Integer.MIN_VALUE); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] } [EOL] public void testGreatestCommonDivisor_absOne() { [EOL] assertEquals(1, greatestCommonDivisor(1, 10)); [EOL] assertEquals(1, greatestCommonDivisor(-1, 10)); [EOL] assertEquals(1, greatestCommonDivisor(10, 1)); [EOL] assertEquals(1, greatestCommonDivisor(10, -1)); [EOL] } [EOL] public void testGreatestCommonDivisor_positiveNumbers() { [EOL] assertEquals(2, greatestCommonDivisor(-2, -4)); [EOL] } [EOL] public void testGreatestCommonDivisor_negativeNumbers() { [EOL] assertEquals(2, greatestCommonDivisor(2, 4)); [EOL] } [EOL] public void testGreatestCommonDivisor_shiftOverflow() { [EOL] try { [EOL] greatestCommonDivisor(Integer.MIN_VALUE, Integer.MIN_VALUE); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("overflow: gcd is 2^31", e.getMessage()); [EOL] } [EOL] } [EOL] public void testGreatestCommonDivisor_generalCase() { [EOL] assertEquals(6, greatestCommonDivisor(-54, -24)); [EOL] }

public void testMulAndCheckNoOverflow() { [EOL] int x = 10000; [EOL] int y = 20000; [EOL] int result = mulAndCheck(x, y); [EOL] assertEquals(200000000, result); [EOL] } [EOL] public void testMulAndCheckOverflowPositive() { [EOL] int x = Integer.MAX_VALUE; [EOL] int y = 2; [EOL] try { [EOL] mulAndCheck(x, y); [EOL] fail("Expected ArithmeticException for overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testMulAndCheckOverflowNegative() { [EOL] int x = Integer.MIN_VALUE; [EOL] int y = 2; [EOL] try { [EOL] mulAndCheck(x, y); [EOL] fail("Expected ArithmeticException for overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testMultiplyBy_NullFraction() { [EOL] final Fraction fraction = new Fraction(1, 2); [EOL] try { [EOL] fraction.multiplyBy(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("The fraction must not be null", iae.getMessage()); [EOL] } [EOL] }
public void testMultiplyBy_ZeroNumeratorInFirstFraction() { [EOL] final Fraction fraction1 = new Fraction(0, 3); [EOL] final Fraction fraction2 = new Fraction(2, 3); [EOL] Fraction result = fraction1.multiplyBy(fraction2); [EOL] assertEquals(Fraction.ZERO, result); [EOL] }
public void testMultiplyBy_ZeroNumeratorInSecondFraction() { [EOL] final Fraction fraction1 = new Fraction(2, 3); [EOL] final Fraction fraction2 = new Fraction(0, 3); [EOL] Fraction result = fraction1.multiplyBy(fraction2); [EOL] assertEquals(Fraction.ZERO, result); [EOL] }
public void testMultiplyBy_NonZeroNumerators() { [EOL] final Fraction fraction1 = new Fraction(1, 3); [EOL] final Fraction fraction2 = new Fraction(2, 3); [EOL] Fraction result = fraction1.multiplyBy(fraction2); [EOL] assertEquals(new Fraction(2, 9), result); [EOL] }
public void testCompareTo_SameObject() { [EOL] Fraction fraction = new Fraction(1, 2); [EOL] int result = fraction.compareTo(fraction); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_EqualValue() { [EOL] Fraction fraction1 = new Fraction(1, 2); [EOL] Fraction fraction2 = new Fraction(1, 2); [EOL] int result = fraction1.compareTo(fraction2); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LessThan() { [EOL] Fraction fraction1 = new Fraction(1, 3); [EOL] Fraction fraction2 = new Fraction(1, 2); [EOL] int result = fraction1.compareTo(fraction2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_GreaterThan() { [EOL] Fraction fraction1 = new Fraction(2, 3); [EOL] Fraction fraction2 = new Fraction(1, 2); [EOL] int result = fraction1.compareTo(fraction2); [EOL] assertEquals(1, result); [EOL] }
public void testGetTSVInstanceWithNullInput() { [EOL] StrTokenizer tokenizer = StrTokenizer.getTSVInstance(null); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetTSVInstanceWithEmptyString() { [EOL] StrTokenizer tokenizer = StrTokenizer.getTSVInstance(""); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetTSVInstanceWithNonEmptyString() { [EOL] StrTokenizer tokenizer = StrTokenizer.getTSVInstance("a\tb\tc"); [EOL] assertNotNull(tokenizer); [EOL] assertTrue(tokenizer.hasNext()); [EOL] assertEquals("a", tokenizer.next()); [EOL] }
public void testGetTSVInstanceWithNullInput() { [EOL] StrTokenizer tokenizer = StrTokenizer.getTSVInstance(null); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetTSVInstanceWithEmptyInput() { [EOL] char[] input = new char[0]; [EOL] StrTokenizer tokenizer = StrTokenizer.getTSVInstance(input); [EOL] assertNotNull(tokenizer); [EOL] assertFalse(tokenizer.hasNext()); [EOL] }
public void testGetTSVInstanceWithNonEmptyInput() { [EOL] char[] input = {'a', '\t', 'b'}; [EOL] StrTokenizer tokenizer = StrTokenizer.getTSVInstance(input); [EOL] assertNotNull(tokenizer); [EOL] assertTrue(tokenizer.hasNext()); [EOL] assertEquals("a", tokenizer.next()); [EOL] assertEquals("b", tokenizer.next()); [EOL] }
public void testStrTokenizerWithNonNullInput() { [EOL] String input = "test"; [EOL] StrTokenizer tokenizer = new StrTokenizer(input); [EOL] char[] expectedChars = input.toCharArray(); [EOL] char[] actualChars = tokenizer.getTokenArray(); [EOL] assertArrayEquals(expectedChars, actualChars); [EOL] }
public void testStrTokenizerWithNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer(null); [EOL] char[] actualChars = tokenizer.getTokenArray(); [EOL] assertNull(actualChars); [EOL] }
public void testStrTokenizerWithNullInputAndDelimiter() { [EOL] char delimiter = ','; [EOL] StrTokenizer tokenizer = new StrTokenizer(null, delimiter); [EOL] assertNull(tokenizer.nextToken()); [EOL] assertEquals(delimiter, tokenizer.getDelimiterChar()); [EOL] }
public void testStrTokenizerWithEmptyStringAndDelimiter() { [EOL] char delimiter = ','; [EOL] StrTokenizer tokenizer = new StrTokenizer("", delimiter); [EOL] assertFalse(tokenizer.hasNext()); [EOL] assertEquals(delimiter, tokenizer.getDelimiterChar()); [EOL] }
public void testStrTokenizerWithNonEmptyStringAndDelimiter() { [EOL] char delimiter = ','; [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c", delimiter); [EOL] assertTrue(tokenizer.hasNext()); [EOL] assertEquals("a", tokenizer.nextToken()); [EOL] assertEquals(delimiter, tokenizer.getDelimiterChar()); [EOL] }
public void testStrTokenizerWithDelimAndQuote() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c", ',', '"'); [EOL] assertEquals(',', tokenizer.getDelimiterChar()); [EOL] assertEquals('"', tokenizer.getQuoteChar()); [EOL] }
public void testStrTokenizerWithNullInput() { [EOL] StrTokenizer tokenizer = new StrTokenizer(null, ',', '"'); [EOL] assertNull(tokenizer.next()); [EOL] assertEquals(',', tokenizer.getDelimiterChar()); [EOL] assertEquals('"', tokenizer.getQuoteChar()); [EOL] }
public void testNextToken_HasNextToken() { [EOL] StringTokenizer tokenizer = new StringTokenizer("token1 token2 token3"); [EOL] String token = tokenizer.nextToken(); [EOL] assertEquals("token1", token); [EOL] token = tokenizer.nextToken(); [EOL] assertEquals("token2", token); [EOL] }
public void testNextToken_NoNextToken() { [EOL] StringTokenizer tokenizer = new StringTokenizer(""); [EOL] String token = tokenizer.nextToken(); [EOL] assertNull(token); [EOL] }
public void testPreviousTokenWithPrevious() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.nextToken(); [EOL] tokenizer.nextToken(); [EOL] String previousToken = tokenizer.previousToken(); [EOL] assertEquals("a", previousToken); [EOL] }
public void testPreviousTokenWithoutPrevious() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] String previousToken = tokenizer.previousToken(); [EOL] assertNull(previousToken); [EOL] }
public void testGetTokenList_NonEmptyTokens() { [EOL] Tokenizer tokenizer = new Tokenizer(new String[] {"token1", "token2", "token3"}); [EOL] List<String> result = tokenizer.getTokenList(); [EOL] assertNotNull(result); [EOL] assertEquals(3, result.size()); [EOL] assertEquals("token1", result.get(0)); [EOL] assertEquals("token2", result.get(1)); [EOL] assertEquals("token3", result.get(2)); [EOL] }
public void testGetTokenList_EmptyTokens() { [EOL] Tokenizer tokenizer = new Tokenizer(new String[] {}); [EOL] List<String> result = tokenizer.getTokenList(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testHasNext_WhenTokenPosLessThanTokensLength_ShouldReturnTrue() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.nextToken(); // Move to first token to initialize tokenPos [EOL] boolean result = tokenizer.hasNext(); [EOL] assertTrue(result); [EOL] } [EOL] public void testHasNext_WhenTokenPosEqualToTokensLength_ShouldReturnFalse() { [EOL] StrTokenizer tokenizer = new StrTokenizer(""); [EOL] boolean result = tokenizer.hasNext(); [EOL] assertFalse(result); [EOL] }
public void testNext_WhenHasNextIsTrue_ShouldReturnNextToken() { [EOL] String[] tokens = {"token1", "token2", "token3"}; [EOL] Tokenizer tokenizer = new Tokenizer(tokens); // Assuming Tokenizer is the class containing the next() method [EOL] String result = tokenizer.next(); [EOL] assertEquals("token1", result); [EOL] assertEquals(1, tokenizer.getTokenPos()); // Assuming getTokenPos() is a method to get the current token position [EOL] }
public void testNext_WhenHasNextIsFalse_ShouldThrowException() { [EOL] String[] tokens = {}; [EOL] Tokenizer tokenizer = new Tokenizer(tokens); // Assuming Tokenizer is the class containing the next() method [EOL] try { [EOL] tokenizer.next(); [EOL] fail("Expected an NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] assertEquals("No more tokens are available", e.getMessage()); // Assuming the exception message is as such [EOL] } [EOL] }
public void testNextIndexAtStart() { [EOL] StringTokenizer tokenizer = new StringTokenizer("a b c"); [EOL] assertEquals(0, tokenizer.nextIndex()); [EOL] }
public void testNextIndexAfterNextToken() { [EOL] StringTokenizer tokenizer = new StringTokenizer("a b c"); [EOL] tokenizer.nextToken(); [EOL] assertEquals(1, tokenizer.nextIndex()); [EOL] }
public void testNextIndexAtEnd() { [EOL] StringTokenizer tokenizer = new StringTokenizer("a b c"); [EOL] while (tokenizer.hasMoreTokens()) { [EOL] tokenizer.nextToken(); [EOL] } [EOL] assertEquals(3, tokenizer.nextIndex()); [EOL] }
public void testPrevious_WithHasPrevious() { [EOL] String[] tokens = {"token1", "token2", "token3"}; [EOL] int tokenPos = 2; // Set to the last token's position [EOL] YourIteratorClass iterator = new YourIteratorClass(tokens, tokenPos); [EOL] String result = iterator.previous(); [EOL] assertEquals("token2", result); [EOL] assertEquals(1, iterator.tokenPos); [EOL] }
public void testPrevious_WithoutHasPrevious() { [EOL] String[] tokens = {"token1"}; [EOL] int tokenPos = 0; // Set to the first token's position which means no previous [EOL] YourIteratorClass iterator = new YourIteratorClass(tokens, tokenPos); [EOL] try { [EOL] iterator.previous(); [EOL] fail("Expected NoSuchElementException to be thrown"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testPreviousIndex_AtStart() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.next(); [EOL] int previousIndex = tokenizer.previousIndex(); [EOL] assertEquals(-1, previousIndex); [EOL] }
public void testPreviousIndex_Middle() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.next(); [EOL] tokenizer.next(); [EOL] int previousIndex = tokenizer.previousIndex(); [EOL] assertEquals(0, previousIndex); [EOL] }
public void testPreviousIndex_End() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a b c"); [EOL] tokenizer.next(); [EOL] tokenizer.next(); [EOL] tokenizer.next(); [EOL] int previousIndex = tokenizer.previousIndex(); [EOL] assertEquals(1, previousIndex); [EOL] }
public void testCheckTokenizedWithNullTokensAndNullChars() { [EOL] this.tokens = null; [EOL] this.chars = null; [EOL] this.checkTokenized(); [EOL] assertNotNull("Tokens should not be null after checkTokenized", this.tokens); [EOL] assertArrayEquals("Tokens should be empty when chars is null", new String[0], this.tokens); [EOL] }
public void testCheckTokenizedWithNullTokensAndNonNullChars() { [EOL] this.tokens = null; [EOL] this.chars = new char[]{'a', 'b', 'c'}; [EOL] this.checkTokenized(); [EOL] assertNotNull("Tokens should not be null after checkTokenized", this.tokens); [EOL] assertArrayEquals("Tokens should contain all characters", new String[]{"a", "b", "c"}, this.tokens); [EOL] }
public void testCheckTokenizedWithNonNullTokens() { [EOL] this.tokens = new String[]{"existing"}; [EOL] this.checkTokenized(); [EOL] assertArrayEquals("Tokens should not be modified", new String[]{"existing"}, this.tokens); [EOL] }
public void testTokenize_NullInput() { [EOL] List<String> result = tokenize(null, 0, 0); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testTokenize_EmptyCount() { [EOL] List<String> result = tokenize(new char[]{'a', 'b', 'c'}, 0, 0); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testTokenize_ValidInput() { [EOL] List<String> result = tokenize(new char[]{'a', ' ', 'b'}, 0, 3); [EOL] assertEquals(2, result.size()); [EOL] assertEquals("a", result.get(0)); [EOL] assertEquals("b", result.get(1)); [EOL] }
public void testTokenize_OffsetBeyondCount() { [EOL] List<String> result = tokenize(new char[]{'a', ' ', 'b'}, 4, 3); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testTokenize_PosAtCountBoundary() { [EOL] List<String> result = tokenize(new char[]{'a', ' ', 'b'}, 0, 2); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("a", result.get(0)); [EOL] }
public void testAddTokenWithEmptyTokenAndIgnoreEmpty() { [EOL] List<String> list = new ArrayList<>(); [EOL] addToken(list, ""); [EOL] assertTrue(list.isEmpty()); [EOL] } [EOL] public void testAddTokenWithEmptyTokenAndNotIgnoreEmpty() { [EOL] List<String> list = new ArrayList<>(); [EOL] setIsIgnoreEmptyTokens(false); [EOL] addToken(list, ""); [EOL] assertEquals(1, list.size()); [EOL] assertNull(list.get(0)); [EOL] } [EOL] public void testAddTokenWithEmptyTokenAndEmptyTokenAsNull() { [EOL] List<String> list = new ArrayList<>(); [EOL] setIsIgnoreEmptyTokens(false); [EOL] setIsEmptyTokenAsNull(true); [EOL] addToken(list, ""); [EOL] assertEquals(1, list.size()); [EOL] assertNull(list.get(0)); [EOL] } [EOL] public void testAddTokenWithNonEmptyToken() { [EOL] List<String> list = new ArrayList<>(); [EOL] addToken(list, "token"); [EOL] assertEquals(1, list.size()); [EOL] assertEquals("token", list.get(0)); [EOL] }

public void testReadNextTokenAtEndOfString() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = new char[] {}; [EOL] int start = 0; [EOL] int len = 0; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(-1, result); [EOL] assertTrue(tokens.isEmpty()); [EOL] } [EOL] public void testReadNextTokenWithIgnoredAndTrimmerMatchers() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = new char[] {' ', '\t', 'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(2, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("", tokens.get(0)); [EOL] } [EOL] public void testReadNextTokenWithDelimiterMatcher() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = new char[] {',', 'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("", tokens.get(0)); [EOL] } [EOL] public void testReadNextTokenWithQuoteMatcher() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = new char[] {'"', 'a', 'b', 'c', '"'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(len, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("abc", tokens.get(0)); [EOL] } [EOL] public void testReadNextTokenWithoutMatchers() { [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] char[] chars = new char[] {'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] int result = readNextToken(chars, start, len, workArea, tokens); [EOL] assertEquals(len, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("abc", tokens.get(0)); [EOL] }
public void testReadWithQuotes_Quoting() { [EOL] char[] chars = new char[]{'a', '"', 'b', '"', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 1; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("abc", tokens.get(0)); [EOL] }
public void testReadWithQuotes_NonQuoting() { [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("abc", tokens.get(0)); [EOL] }
public void testReadWithQuotes_QuotingWithEscapedQuote() { [EOL] char[] chars = new char[]{'a', '"', '"', 'b', '"', '"', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 1; [EOL] int quoteLen = 1; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("a\"b\"c", tokens.get(0)); [EOL] }
public void testReadWithQuotes_DelimiterEncountered() { [EOL] char[] chars = new char[]{'a', ',', 'b', ',', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(2, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("a", tokens.get(0)); [EOL] }
public void testReadWithQuotes_IgnoredEncountered() { [EOL] char[] chars = new char[]{' ', 'a', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("abc", tokens.get(0)); [EOL] }
public void testReadWithQuotes_TrimmedEncountered() { [EOL] char[] chars = new char[]{' ', 'a', ' ', 'b', 'c'}; [EOL] int start = 0; [EOL] int len = chars.length; [EOL] StrBuilder workArea = new StrBuilder(); [EOL] List<String> tokens = new ArrayList<>(); [EOL] int quoteStart = 0; [EOL] int quoteLen = 0; [EOL] int result = readWithQuotes(chars, start, len, workArea, tokens, quoteStart, quoteLen); [EOL] assertEquals(-1, result); [EOL] assertEquals(1, tokens.size()); [EOL] assertEquals("a bc", tokens.get(0)); [EOL] }
public void testIsQuote_AllCharsMatch() { [EOL] char[] chars = new char[]{'a', 'b', 'c', 'a', 'b', 'c'}; [EOL] int pos = 3; [EOL] int len = chars.length; [EOL] int quoteStart = 0; [EOL] int quoteLen = 3; [EOL] boolean result = isQuote(chars, pos, len, quoteStart, quoteLen); [EOL] assertTrue(result); [EOL] }
public void testIsQuote_PosPlusIEqualsLen() { [EOL] char[] chars = new char[]{'a', 'b', 'c', 'a', 'b', 'c'}; [EOL] int pos = 3; [EOL] int len = 6; [EOL] int quoteStart = 0; [EOL] int quoteLen = 4; [EOL] boolean result = isQuote(chars, pos, len, quoteStart, quoteLen); [EOL] assertFalse(result); [EOL] }
public void testIsQuote_CharMismatch() { [EOL] char[] chars = new char[]{'a', 'b', 'c', 'd', 'e', 'f'}; [EOL] int pos = 3; [EOL] int len = chars.length; [EOL] int quoteStart = 0; [EOL] int quoteLen = 3; [EOL] boolean result = isQuote(chars, pos, len, quoteStart, quoteLen); [EOL] assertFalse(result); [EOL] }
public void testGetDelimiterMatcher() { [EOL] StrMatcher expectedDelimMatcher = StrMatcher.commaMatcher(); // Example instantiation, actual code may vary [EOL] MyClass myClassInstance = new MyClass(expectedDelimMatcher); // Assuming MyClass is the containing class and has such a constructor [EOL] StrMatcher actualDelimMatcher = myClassInstance.getDelimiterMatcher(); [EOL] assertEquals(expectedDelimMatcher, actualDelimMatcher); [EOL] }
public void testSetDelimiterMatcherWithNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] StrMatcher delimMatcher = null; [EOL] tokenizer.setDelimiterMatcher(delimMatcher); [EOL] assertEquals(StrMatcher.noneMatcher(), tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetDelimiterMatcherWithNonNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c"); [EOL] StrMatcher delimMatcher = StrMatcher.commaMatcher(); [EOL] tokenizer.setDelimiterMatcher(delimMatcher); [EOL] assertEquals(delimMatcher, tokenizer.getDelimiterMatcher()); [EOL] }
public void testSetDelimiterChar() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,c", ','); [EOL] StrMatcher delimMatcher = StrMatcher.charMatcher(','); [EOL] tokenizer.setDelimiterChar(','); [EOL] assertEquals(delimMatcher.isMatch("a,b,c".toCharArray(), 0), tokenizer.getDelimiterMatcher().isMatch("a,b,c".toCharArray(), 0)); [EOL] }
public void testSetDelimiterCharDifferentDelimiter() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a-b-c", ','); [EOL] StrMatcher delimMatcher = StrMatcher.charMatcher('-'); [EOL] tokenizer.setDelimiterChar('-'); [EOL] assertEquals(delimMatcher.isMatch("a-b-c".toCharArray(), 0), tokenizer.getDelimiterMatcher().isMatch("a-b-c".toCharArray(), 0)); [EOL] }
public void testGetQuoteMatcher() { [EOL] StrMatcher matcher = StrMatcher.getQuoteMatcher(); [EOL] assertNotNull("The quoteMatcher should not be null", matcher); [EOL] }
public void testSetQuoteMatcherWithNonNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrMatcher quoteMatcher = StrMatcher.doubleQuoteMatcher(); [EOL] tokenizer.setQuoteMatcher(quoteMatcher); [EOL] assertEquals(quoteMatcher, tokenizer.getQuoteMatcher()); [EOL] }
public void testSetQuoteMatcherWithNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] tokenizer.setQuoteMatcher(null); [EOL] assertNotNull(tokenizer.getQuoteMatcher()); [EOL] }
public void testSetQuoteChar() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] char quoteChar = '\"'; [EOL] tokenizer.setQuoteChar(quoteChar); [EOL] assertEquals(StrMatcher.charMatcher(quoteChar), tokenizer.getQuoteMatcher()); [EOL] }
public void testSetQuoteCharWithDifferentChar() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] char quoteChar = '\''; [EOL] tokenizer.setQuoteChar(quoteChar); [EOL] assertEquals(StrMatcher.charMatcher(quoteChar), tokenizer.getQuoteMatcher()); [EOL] }
public void testGetIgnoredMatcher() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StrMatcher ignoredMatcher = strBuilder.getIgnoredMatcher(); [EOL] assertNull(ignoredMatcher); [EOL] }
public void testSetAndGetIgnoredMatcher() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StrMatcher matcher = StrMatcher.noneMatcher(); [EOL] strBuilder.setIgnoredMatcher(matcher); [EOL] assertSame(matcher, strBuilder.getIgnoredMatcher()); [EOL] }
public void testGetTrimmerMatcher() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] StrMatcher trimmerMatcher = strBuilder.getTrimmerMatcher(); [EOL] assertNotNull(trimmerMatcher); [EOL] }
public void testSetTrimmerMatcherWithNonNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrMatcher trimmer = StrMatcher.spaceMatcher(); [EOL] StrTokenizer result = tokenizer.setTrimmerMatcher(trimmer); [EOL] assertSame("Expected the same StrMatcher to be set", trimmer, result.getTrimmerMatcher()); [EOL] }
public void testSetTrimmerMatcherWithNull() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrMatcher defaultTrimmer = tokenizer.getTrimmerMatcher(); [EOL] StrTokenizer result = tokenizer.setTrimmerMatcher(null); [EOL] assertSame("Expected the default StrMatcher to remain", defaultTrimmer, result.getTrimmerMatcher()); [EOL] }
public void testIsEmptyTokenAsNullTrue() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] tokenizer.setEmptyTokenAsNull(true); [EOL] assertTrue(tokenizer.isEmptyTokenAsNull()); [EOL] }
public void testIsEmptyTokenAsNullFalse() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] tokenizer.setEmptyTokenAsNull(false); [EOL] assertFalse(tokenizer.isEmptyTokenAsNull()); [EOL] }
public void testSetEmptyTokenAsNull_True() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrTokenizer result = tokenizer.setEmptyTokenAsNull(true); [EOL] assertTrue(tokenizer.isEmptyTokenAsNull()); [EOL] assertSame(tokenizer, result); [EOL] }
public void testSetEmptyTokenAsNull_False() { [EOL] StrTokenizer tokenizer = new StrTokenizer(); [EOL] StrTokenizer result = tokenizer.setEmptyTokenAsNull(false); [EOL] assertFalse(tokenizer.isEmptyTokenAsNull()); [EOL] assertSame(tokenizer, result); [EOL] }
public void testIsIgnoreEmptyTokensTrue() { [EOL] Tokenizer tokenizer = new Tokenizer(); [EOL] tokenizer.ignoreEmptyTokens = true; [EOL] assertTrue(tokenizer.isIgnoreEmptyTokens()); [EOL] }
public void testIsIgnoreEmptyTokensFalse() { [EOL] Tokenizer tokenizer = new Tokenizer(); [EOL] tokenizer.ignoreEmptyTokens = false; [EOL] assertFalse(tokenizer.isIgnoreEmptyTokens()); [EOL] }
public void testSetIgnoreEmptyTokensTrue() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,,c"); [EOL] tokenizer.setIgnoreEmptyTokens(true); [EOL] assertTrue(tokenizer.isIgnoreEmptyTokens()); [EOL] }
public void testSetIgnoreEmptyTokensFalse() { [EOL] StrTokenizer tokenizer = new StrTokenizer("a,b,,c"); [EOL] tokenizer.setIgnoreEmptyTokens(false); [EOL] assertFalse(tokenizer.isIgnoreEmptyTokens()); [EOL] }
public void testDateFormatUtilsConstructor() { [EOL] new DateFormatUtils(); [EOL] }
public void testFastDatePrinterConstructorWithValidInputs() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] FastDatePrinter printer = new FastDatePrinter(pattern, timeZone, locale); [EOL] assertNotNull(printer); [EOL] assertEquals(pattern, printer.getPattern()); [EOL] assertEquals(timeZone, printer.getTimeZone()); [EOL] assertEquals(locale, printer.getLocale()); [EOL] }
public void testFastDatePrinterConstructorWithNullPattern() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.US; [EOL] try { [EOL] FastDatePrinter printer = new FastDatePrinter(null, timeZone, locale); [EOL] fail("Should have thrown IllegalArgumentException for null pattern"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFastDatePrinterConstructorWithNullTimeZone() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] Locale locale = Locale.US; [EOL] FastDatePrinter printer = new FastDatePrinter(pattern, null, locale); [EOL] assertNotNull(printer); [EOL] assertEquals(pattern, printer.getPattern()); [EOL] assertNotNull(printer.getTimeZone()); [EOL] assertEquals(locale, printer.getLocale()); [EOL] }
public void testFastDatePrinterConstructorWithNullLocale() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDatePrinter printer = new FastDatePrinter(pattern, timeZone, null); [EOL] assertNotNull(printer); [EOL] assertEquals(pattern, printer.getPattern()); [EOL] assertEquals(timeZone, printer.getTimeZone()); [EOL] assertNotNull(printer.getLocale()); [EOL] }
public void testInitWithEmptyRulesList() { [EOL] setEmptyPattern(); [EOL] init(); [EOL] assertEquals(0, mRules.length); [EOL] assertEquals(0, mMaxLengthEstimate); [EOL] } [EOL] public void testInitWithNonEmptyRulesList() { [EOL] setNonEmptyPattern(); [EOL] init(); [EOL] assertTrue(mRules.length > 0); [EOL] assertTrue(mMaxLengthEstimate > 0); [EOL] }
protected List<Rule> parsePattern() { [EOL] final DateFormatSymbols symbols = new DateFormatSymbols(mLocale); [EOL] final List<Rule> rules = new ArrayList<Rule>(); [EOL] final String[] ERAs = symbols.getEras(); [EOL] final String[] months = symbols.getMonths(); [EOL] final String[] shortMonths = symbols.getShortMonths(); [EOL] final String[] weekdays = symbols.getWeekdays(); [EOL] final String[] shortWeekdays = symbols.getShortWeekdays(); [EOL] final String[] AmPmStrings = symbols.getAmPmStrings(); [EOL] final int length = mPattern.length(); [EOL] final int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] final String token = parseToken(mPattern, indexRef); [EOL] i = indexRef[0]; [EOL] final int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] Rule rule; [EOL] final char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] rule = new TextField(Calendar.ERA, ERAs); [EOL] break; [EOL] case 'y': [EOL] if (tokenLen == 2) { [EOL] rule = TwoDigitYearField.INSTANCE; [EOL] } else { [EOL] rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen); [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 4) { [EOL] rule = new TextField(Calendar.MONTH, months); [EOL] } else if (tokenLen == 3) { [EOL] rule = new TextField(Calendar.MONTH, shortMonths); [EOL] } else if (tokenLen == 2) { [EOL] rule = TwoDigitMonthField.INSTANCE; [EOL] } else { [EOL] rule = UnpaddedMonthField.INSTANCE; [EOL] } [EOL] break; [EOL] case 'd': [EOL] rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); [EOL] break; [EOL] case 'h': [EOL] rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); [EOL] break; [EOL] case 'H': [EOL] rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); [EOL] break; [EOL] case 'm': [EOL] rule = selectNumberRule(Calendar.MINUTE, tokenLen); [EOL] break; [EOL] case 's': [EOL] rule = selectNumberRule(Calendar.SECOND, tokenLen); [EOL] break; [EOL] case 'S': [EOL] rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); [EOL] break; [EOL] case 'E': [EOL] rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); [EOL] break; [EOL] case 'D': [EOL] rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); [EOL] break; [EOL] case 'F': [EOL] rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); [EOL] break; [EOL] case 'w': [EOL] rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); [EOL] break; [EOL] case 'W': [EOL] rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); [EOL] break; [EOL] case 'a': [EOL] rule = new TextField(Calendar.AM_PM, AmPmStrings); [EOL] break; [EOL] case 'k': [EOL] rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); [EOL] break; [EOL] case 'K': [EOL] rule = selectNumberRule(Calendar.HOUR, tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG); [EOL] } else { [EOL] rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] rule = TimeZoneNumberRule.INSTANCE_NO_COLON; [EOL] } else { [EOL] rule = TimeZoneNumberRule.INSTANCE_COLON; [EOL] } [EOL] break; [EOL] case '\'': [EOL] final String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] rule = new CharacterLiteral(sub.charAt(0)); [EOL] } else { [EOL] rule = new StringLiteral(sub); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] rules.add(rule); [EOL] } [EOL] return rules; [EOL] }
public void testParseTokenWithSingleLetter() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("A", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithMultipleSameLetters() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("AAA", indexRef); [EOL] assertEquals("AAA", result); [EOL] assertEquals(3, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithDifferentLetters() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("AB", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithSingleQuote() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("'", indexRef); [EOL] assertEquals("'", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithEscapedQuote() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("''", indexRef); [EOL] assertEquals("'", result); [EOL] assertEquals(2, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithMixedContent() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("A'BC'D", indexRef); [EOL] assertEquals("A", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithNonLetter() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("#", indexRef); [EOL] assertEquals("'#", result); [EOL] assertEquals(1, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithNonLetterAndLiteral() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("#'A'", indexRef); [EOL] assertEquals("'#'", result); [EOL] assertEquals(2, indexRef[0]); [EOL] } [EOL] public void testParseTokenWithNonLetterAndEscapedLiteral() { [EOL] int[] indexRef = new int[]{0}; [EOL] String result = parseToken("#''A", indexRef); [EOL] assertEquals("'#'", result); [EOL] assertEquals(3, indexRef[0]); [EOL] }
public void testSelectNumberRuleWithPaddingOne() { [EOL] final int field = 0; [EOL] NumberRule result = selectNumberRule(field, 1); [EOL] assertTrue(result instanceof UnpaddedNumberField); [EOL] }
public void testSelectNumberRuleWithPaddingTwo() { [EOL] final int field = 0; [EOL] NumberRule result = selectNumberRule(field, 2); [EOL] assertTrue(result instanceof TwoDigitNumberField); [EOL] }
public void testSelectNumberRuleWithPaddingDefault() { [EOL] final int field = 0; [EOL] final int padding = 3; [EOL] NumberRule result = selectNumberRule(field, padding); [EOL] assertTrue(result instanceof PaddedNumberField); [EOL] assertEquals(padding, ((PaddedNumberField) result).getPadding()); [EOL] }
public void testFormatWithZeroMillis() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] String formatted = fdf.format(0L); [EOL] assertNotNull("The formatted string should not be null", formatted); [EOL] assertEquals("The formatted string should match the expected output for 0 millis", "expectedStringForZeroMillis", formatted); [EOL] }
public void testFormatWithPositiveMillis() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] String formatted = fdf.format(123456789L); [EOL] assertNotNull("The formatted string should not be null", formatted); [EOL] assertEquals("The formatted string should match the expected output for 123456789 millis", "expectedStringForPositiveMillis", formatted); [EOL] }
public void testFormatWithNegativeMillis() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] String formatted = fdf.format(-123456789L); [EOL] assertNotNull("The formatted string should not be null", formatted); [EOL] assertEquals("The formatted string should match the expected output for negative millis", "expectedStringForNegativeMillis", formatted); [EOL] }
public void testFormatWithNullCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] String result = fdf.format((Calendar) null); [EOL] assertNull("The format method should return null for null calendar input", result); [EOL] }
public void testFormatWithNonNullCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] String result = fdf.format(calendar); [EOL] assertNotNull("The format method should not return null for non-null calendar input", result); [EOL] assertFalse("The formatted date should not be empty", result.isEmpty()); [EOL] }
public void testFormatWithNullCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] StringBuffer result = fdf.format((Calendar) null, buf); [EOL] assertNotNull(result); [EOL] assertEquals("", result.toString()); [EOL] }
public void testFormatWithNonNullCalendar() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] StringBuffer result = fdf.format(calendar, buf); [EOL] assertNotNull(result); [EOL] assertNotEquals("", result.toString()); [EOL] }
public void testApplyRulesWithEmptyRules() { [EOL] FastDateFormat fdf = FastDateFormat.getInstance(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] StringBuffer result = fdf.applyRules(calendar, buf); [EOL] assertEquals("", result.toString()); [EOL] }
public void testApplyRulesWithOneRule() { [EOL] FastDateFormat fdf = new FastDateFormat(null, null, null) { [EOL] protected Rule[] mRules = new Rule[] { [EOL] new Rule() { [EOL] public int estimateLength() { return 0; } [EOL] public void appendTo(StringBuffer buffer, Calendar calendar) { [EOL] buffer.append("Test"); [EOL] } [EOL] } [EOL] }; [EOL] }; [EOL] Calendar calendar = Calendar.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] StringBuffer result = fdf.applyRules(calendar, buf); [EOL] assertEquals("Test", result.toString()); [EOL] }
public void testApplyRulesWithMultipleRules() { [EOL] FastDateFormat fdf = new FastDateFormat(null, null, null) { [EOL] protected Rule[] mRules = new Rule[] { [EOL] new Rule() { [EOL] public int estimateLength() { return 0; } [EOL] public void appendTo(StringBuffer buffer, Calendar calendar) { [EOL] buffer.append("First"); [EOL] } [EOL] }, [EOL] new Rule() { [EOL] public int estimateLength() { return 0; } [EOL] public void appendTo(StringBuffer buffer, Calendar calendar) { [EOL] buffer.append("Second"); [EOL] } [EOL] } [EOL] }; [EOL] }; [EOL] Calendar calendar = Calendar.getInstance(); [EOL] StringBuffer buf = new StringBuffer(); [EOL] StringBuffer result = fdf.applyRules(calendar, buf); [EOL] assertEquals("FirstSecond", result.toString()); [EOL] }
public void testGetTimeZone() { [EOL] MyClass myClassInstance = new MyClass(); [EOL] TimeZone expectedTimeZone = TimeZone.getDefault(); [EOL] myClassInstance.setTimeZone(expectedTimeZone); [EOL] TimeZone actualTimeZone = myClassInstance.getTimeZone(); [EOL] assertEquals(expectedTimeZone, actualTimeZone); [EOL] }
public void testGetLocale() { [EOL] YourClass instance = new YourClass(Locale.ENGLISH); [EOL] Locale result = instance.getLocale(); [EOL] assertEquals(Locale.ENGLISH, result); [EOL] }
public void testCharacterLiteralWithValueA() { [EOL] CharacterLiteral charLiteral = new CharacterLiteral('A'); [EOL] assertEquals('A', charLiteral.getValue()); [EOL] }
public void testCharacterLiteralWithValueZ() { [EOL] CharacterLiteral charLiteral = new CharacterLiteral('Z'); [EOL] assertEquals('Z', charLiteral.getValue()); [EOL] }
public int estimateLengthTest() { [EOL] assertEquals(1, new YourClass().estimateLength()); [EOL] }
public void testTextFieldWithValidFieldAndValues() { [EOL] int field = 1; [EOL] String[] values = {"value1", "value2"}; [EOL] TextField textField = new TextField(field, values); [EOL] assertEquals(field, textField.mField); [EOL] assertArrayEquals(values, textField.mValues); [EOL] }
public void testTextFieldWithNullValues() { [EOL] int field = 1; [EOL] String[] values = null; [EOL] TextField textField = new TextField(field, values); [EOL] assertEquals(field, textField.mField); [EOL] assertNull(textField.mValues); [EOL] }
public void testEstimateLengthEmptyArray() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.mValues = new String[0]; [EOL] int result = strBuilder.estimateLength(); [EOL] assertEquals(0, result); [EOL] }
public void testEstimateLengthSingleElement() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.mValues = new String[]{"a"}; [EOL] int result = strBuilder.estimateLength(); [EOL] assertEquals(1, result); [EOL] }
public void testEstimateLengthMultipleElements() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] strBuilder.mValues = new String[]{"abc", "a", "abcd"}; [EOL] int result = strBuilder.estimateLength(); [EOL] assertEquals(4, result); [EOL] }
public void testAppendTo_NullBuffer_ThrowsNullPointerException() { [EOL] FastDateFormat.FieldValuePrinter printer = new FastDateFormat.FieldValuePrinter(new String[]{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}, Calendar.DAY_OF_WEEK); [EOL] try { [EOL] printer.appendTo(null, Calendar.getInstance()); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testAppendTo_ValidBufferAppendsValue() { [EOL] FastDateFormat.FieldValuePrinter printer = new FastDateFormat.FieldValuePrinter(new String[]{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}, Calendar.DAY_OF_WEEK); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); [EOL] printer.appendTo(buffer, calendar); [EOL] assertEquals("Mon", buffer.toString()); [EOL] }
public void testUnpaddedNumberFieldConstructor_ValidField() { [EOL] int field = 1; [EOL] UnpaddedNumberField unpaddedNumberField = new UnpaddedNumberField(field); [EOL] assertEquals(field, unpaddedNumberField.mField); [EOL] }
public void testUnpaddedNumberFieldConstructor_InvalidField() { [EOL] int field = -1; // Assuming the field should be non-negative, otherwise adjust accordingly [EOL] try { [EOL] new UnpaddedNumberField(field); [EOL] fail("Should have thrown an exception for invalid field value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendTo_SingleDigit() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 5; [EOL] appendTo(buffer, value); [EOL] assertEquals("5", buffer.toString()); [EOL] }
public void testAppendTo_TwoDigits() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 42; [EOL] appendTo(buffer, value); [EOL] assertEquals("42", buffer.toString()); [EOL] }
public void testAppendTo_ThreeOrMoreDigits() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 123; [EOL] appendTo(buffer, value); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testAppendTo_SingleDigitValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 9; // Single digit [EOL] appendTo(buffer, value); [EOL] assertEquals("9", buffer.toString()); [EOL] } [EOL] public void testAppendTo_MultiDigitValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 34; // Multi-digit [EOL] appendTo(buffer, value); [EOL] assertEquals("34", buffer.toString()); [EOL] }
public void testPaddedNumberFieldValidSize() { [EOL] int field = 1; [EOL] int size = 3; [EOL] PaddedNumberField pnf = new PaddedNumberField(field, size); [EOL] assertEquals(field, pnf.getField()); [EOL] assertEquals(size, pnf.getSize()); [EOL] }
public void testPaddedNumberFieldInvalidSize() { [EOL] int field = 1; [EOL] int size = 2; [EOL] try { [EOL] new PaddedNumberField(field, size); [EOL] fail("Should have thrown IllegalArgumentException for size < 3"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int estimateLengthTest() { [EOL] SomeClass instance = new SomeClass(); [EOL] int result = instance.estimateLength(); [EOL] assert result == 4; [EOL] }
public void testAppendToWithLessThan100() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 99; [EOL] appendTo(buffer, value); [EOL] assertEquals("0099", buffer.toString()); [EOL] }
public void testAppendToWithLessThan1000() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 999; [EOL] appendTo(buffer, value); [EOL] assertEquals("0999", buffer.toString()); [EOL] }
public void testAppendToWith1000OrMore() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 1000; [EOL] appendTo(buffer, value); [EOL] assertEquals("1000", buffer.toString()); [EOL] }
public void testAppendToWithNegativeValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = -1; [EOL] try { [EOL] appendTo(buffer, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTwoDigitNumberFieldValid() { [EOL] int expected = 42; [EOL] ClassName instance = new ClassName(expected); [EOL] assertEquals(expected, instance.getField()); [EOL] }
public void testAppendToWithNullBuffer() { [EOL] try { [EOL] FastDateFormat.Field mField = FastDateFormat.Field.DAY_OF_MONTH; [EOL] Calendar calendar = Calendar.getInstance(); [EOL] new FastDateFormat.Field(mField).appendTo(null, calendar); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAppendToWithNullCalendar() { [EOL] try { [EOL] FastDateFormat.Field mField = FastDateFormat.Field.DAY_OF_MONTH; [EOL] StringBuffer buffer = new StringBuffer(); [EOL] new FastDateFormat.Field(mField).appendTo(buffer, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAppendToWithValidBufferAndCalendar() { [EOL] FastDateFormat.Field mField = FastDateFormat.Field.DAY_OF_MONTH; [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] new FastDateFormat.Field(mField).appendTo(buffer, calendar); [EOL] assertTrue(buffer.length() > 0); [EOL] }
public void testAppendToWithLessThan100() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 99; [EOL] appendTo(buffer, value); [EOL] assertEquals("99", buffer.toString()); [EOL] }
public void testAppendToWith100OrMore() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 100; [EOL] appendTo(buffer, value); [EOL] assertEquals("100", buffer.toString()); [EOL] }
public void testAppendToWithNullBuffer() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] try { [EOL] appendTo(null, calendar); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testAppendToWithNullCalendar() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] try { [EOL] appendTo(buffer, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testAppendToWithValidBufferAndCalendar() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.YEAR, 2023); [EOL] appendTo(buffer, calendar); [EOL] assertEquals("23", buffer.toString()); [EOL] } [EOL] public void testAppendToWithYearLessThan100() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.YEAR, 99); [EOL] appendTo(buffer, calendar); [EOL] assertEquals("99", buffer.toString()); [EOL] } [EOL] public void testAppendToWithYearEqualTo100() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.YEAR, 100); [EOL] appendTo(buffer, calendar); [EOL] assertEquals("00", buffer.toString()); [EOL] }
public int estimateLengthTest() { [EOL] YourClass instance = new YourClass(); [EOL] int result = instance.estimateLength(); [EOL] assertEquals(2, result); [EOL] }
public void testAppendToWithNullBuffer() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] try { [EOL] appendTo(null, calendar); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAppendToWithNullCalendar() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] try { [EOL] appendTo(buffer, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAppendToWithValidBufferAndCalendar() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] int month = calendar.get(Calendar.MONTH) + 1; [EOL] appendTo(buffer, calendar); [EOL] assertTrue(buffer.toString().contains(String.valueOf(month))); [EOL] }
public void testAppendToWithPositiveValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 23; [EOL] appendTo(buffer, value); [EOL] assertEquals("23", buffer.toString()); [EOL] } [EOL] public void testAppendToWithNegativeValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = -45; [EOL] appendTo(buffer, value); [EOL] assertEquals("-45", buffer.toString()); [EOL] } [EOL] public void testAppendToWithSingleDigitValue() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 5; [EOL] appendTo(buffer, value); [EOL] assertEquals("05", buffer.toString()); [EOL] } [EOL] public void testAppendToWithZero() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] int value = 0; [EOL] appendTo(buffer, value); [EOL] assertEquals("00", buffer.toString()); [EOL] }
public void testGetTimeZoneDisplay_WithNullTimeZone() { [EOL] Locale locale = Locale.getDefault(); [EOL] String result = ClassName.getTimeZoneDisplay(null, true, TimeZone.SHORT, locale); [EOL] assertNull(result); [EOL] } [EOL] public void testGetTimeZoneDisplay_WithNonNullTimeZoneAndDaylightTrue() { [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] String result = ClassName.getTimeZoneDisplay(tz, true, TimeZone.SHORT, locale); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetTimeZoneDisplay_WithNonNullTimeZoneAndDaylightFalse() { [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] String result = ClassName.getTimeZoneDisplay(tz, false, TimeZone.SHORT, locale); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetTimeZoneDisplay_WithDifferentStyles() { [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] String resultShort = ClassName.getTimeZoneDisplay(tz, true, TimeZone.SHORT, locale); [EOL] String resultLong = ClassName.getTimeZoneDisplay(tz, true, TimeZone.LONG, locale); [EOL] assertNotNull(resultShort); [EOL] assertNotNull(resultLong); [EOL] assertNotEquals(resultShort, resultLong); [EOL] } [EOL] public void testGetTimeZoneDisplay_WithDifferentLocales() { [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] Locale localeEN = Locale.ENGLISH; [EOL] Locale localeFR = Locale.FRENCH; [EOL] String resultEN = ClassName.getTimeZoneDisplay(tz, true, TimeZone.SHORT, localeEN); [EOL] String resultFR = ClassName.getTimeZoneDisplay(tz, true, TimeZone.SHORT, localeFR); [EOL] assertNotNull(resultEN); [EOL] assertNotNull(resultFR); [EOL] assertNotEquals(resultEN, resultFR); [EOL] } [EOL] public void testGetTimeZoneDisplay_CacheHit() { [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] String result1 = ClassName.getTimeZoneDisplay(tz, true, TimeZone.SHORT, locale); [EOL] String result2 = ClassName.getTimeZoneDisplay(tz, true, TimeZone.SHORT, locale); [EOL] assertNotNull(result1); [EOL] assertNotNull(result2); [EOL] assertEquals(result1, result2); [EOL] }
public void testTimeZoneNameRule_StandardTime() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.ENGLISH; [EOL] int style = TimeZone.SHORT; [EOL] TimeZoneNameRule rule = new TimeZoneNameRule(timeZone, locale, style); [EOL] String expectedStandardName = timeZone.getDisplayName(false, style, locale); [EOL] assertEquals(expectedStandardName, rule.mStandard); [EOL] }
public void testTimeZoneNameRule_DaylightTime() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.ENGLISH; [EOL] int style = TimeZone.SHORT; [EOL] TimeZoneNameRule rule = new TimeZoneNameRule(timeZone, locale, style); [EOL] String expectedDaylightName = timeZone.getDisplayName(true, style, locale); [EOL] assertEquals(expectedDaylightName, rule.mDaylight); [EOL] }
public void testTimeZoneNameRule_DifferentLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.FRENCH; [EOL] int style = TimeZone.LONG; [EOL] TimeZoneNameRule rule = new TimeZoneNameRule(timeZone, locale, style); [EOL] String expectedStandardName = timeZone.getDisplayName(false, style, locale); [EOL] String expectedDaylightName = timeZone.getDisplayName(true, style, locale); [EOL] assertEquals(expectedStandardName, rule.mStandard); [EOL] assertEquals(expectedDaylightName, rule.mDaylight); [EOL] }
public void testTimeZoneNameRule_DifferentStyle() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.ENGLISH; [EOL] int style = TimeZone.LONG; [EOL] TimeZoneNameRule rule = new TimeZoneNameRule(timeZone, locale, style); [EOL] String expectedStandardName = timeZone.getDisplayName(false, style, locale); [EOL] String expectedDaylightName = timeZone.getDisplayName(true, style, locale); [EOL] assertEquals(expectedStandardName, rule.mStandard); [EOL] assertEquals(expectedDaylightName, rule.mDaylight); [EOL] }
public void testEstimateLength_StandardLongerThanDaylight() { [EOL] TimeZoneNameProvider mockProvider = Mockito.mock(TimeZoneNameProvider.class); [EOL] Mockito.when(mockProvider.getDisplayName("GMT", false, TimeZone.LONG)).thenReturn("Greenwich Mean Time"); [EOL] Mockito.when(mockProvider.getDisplayName("GMT", true, TimeZone.LONG)).thenReturn("British Summer Time"); [EOL] TimeZoneDisplayNames names = new TimeZoneDisplayNames(Locale.UK, mockProvider); [EOL] int estimatedLength = names.estimateLength(); [EOL] assertEquals("Greenwich Mean Time".length(), estimatedLength); [EOL] }
public void testEstimateLength_DaylightLongerThanStandard() { [EOL] TimeZoneNameProvider mockProvider = Mockito.mock(TimeZoneNameProvider.class); [EOL] Mockito.when(mockProvider.getDisplayName("GMT", false, TimeZone.LONG)).thenReturn("GMT"); [EOL] Mockito.when(mockProvider.getDisplayName("GMT", true, TimeZone.LONG)).thenReturn("Greenwich Mean Time Summer"); [EOL] TimeZoneDisplayNames names = new TimeZoneDisplayNames(Locale.UK, mockProvider); [EOL] int estimatedLength = names.estimateLength(); [EOL] assertEquals("Greenwich Mean Time Summer".length(), estimatedLength); [EOL] }
public void testAppendToWithDaylightTime() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTimeZone(TimeZone.getTimeZone("GMT+0")); [EOL] calendar.set(Calendar.MONTH, Calendar.JUNE); // Set to a month with daylight savings time [EOL] FastDateFormat instance = FastDateFormat.getInstance("yyyy-MM-dd", TimeZone.getTimeZone("GMT+0"), Locale.US); [EOL] instance.appendTo(buffer, calendar); [EOL] assertTrue("Buffer should contain daylight time info", buffer.toString().contains("GMT+01:00")); [EOL] } [EOL] public void testAppendToWithoutDaylightTime() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTimeZone(TimeZone.getTimeZone("GMT+0")); [EOL] calendar.set(Calendar.MONTH, Calendar.JANUARY); // Set to a month without daylight savings time [EOL] FastDateFormat instance = FastDateFormat.getInstance("yyyy-MM-dd", TimeZone.getTimeZone("GMT+0"), Locale.US); [EOL] instance.appendTo(buffer, calendar); [EOL] assertTrue("Buffer should not contain daylight time info", buffer.toString().contains("GMT+00:00")); [EOL] }
public int estimateLengthTest() { [EOL] SomeClass instance = new SomeClass(); [EOL] int expected = 5; [EOL] int actual = instance.estimateLength(); [EOL] assertEquals(expected, actual); [EOL] }
public void testAppendToWithNegativeOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, -3 * 60 * 60 * 1000); // Set timezone offset to -3 hours [EOL] calendar.set(Calendar.DST_OFFSET, 0); // No daylight saving time offset [EOL] appendTo(buffer, calendar); [EOL] String expected = "-03"; [EOL] assertEquals(expected, buffer.toString().substring(0, 3)); [EOL] }
public void testAppendToWithPositiveOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, 3 * 60 * 60 * 1000); // Set timezone offset to +3 hours [EOL] calendar.set(Calendar.DST_OFFSET, 0); // No daylight saving time offset [EOL] appendTo(buffer, calendar); [EOL] String expected = "+03"; [EOL] assertEquals(expected, buffer.toString().substring(0, 3)); [EOL] }
public void testAppendToWithColonInOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, 3 * 60 * 60 * 1000); // Set timezone offset to +3 hours [EOL] calendar.set(Calendar.DST_OFFSET, 0); // No daylight saving time offset [EOL] mColon = true; // Assuming mColon is a class member that determines if a colon should be included [EOL] appendTo(buffer, calendar); [EOL] String expected = "+03:"; [EOL] assertEquals(expected, buffer.toString().substring(0, 4)); [EOL] }
public void testAppendToWithMinutesInOffset() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(Calendar.ZONE_OFFSET, 3 * 60 * 60 * 1000 + 30 * 60 * 1000); // Set timezone offset to +3 hours and 30 minutes [EOL] calendar.set(Calendar.DST_OFFSET, 0); // No daylight saving time offset [EOL] appendTo(buffer, calendar); [EOL] String expected = "+0330"; [EOL] assertEquals(expected, buffer.toString().substring(0, 5)); [EOL] }
public void testTimeZoneDisplayKeyWithDaylightTrue() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] boolean daylight = true; [EOL] int style = TimeZone.SHORT; [EOL] Locale locale = Locale.getDefault(); [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(timeZone, daylight, style, locale); [EOL] assertEquals(timeZone, key.getTimeZone()); [EOL] assertTrue((key.getStyle() & 0x80000000) != 0); [EOL] assertEquals(locale, key.getLocale()); [EOL] } [EOL] public void testTimeZoneDisplayKeyWithDaylightFalse() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] boolean daylight = false; [EOL] int style = TimeZone.SHORT; [EOL] Locale locale = Locale.getDefault(); [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(timeZone, daylight, style, locale); [EOL] assertEquals(timeZone, key.getTimeZone()); [EOL] assertTrue((key.getStyle() & 0x80000000) == 0); [EOL] assertEquals(locale, key.getLocale()); [EOL] } [EOL] public void testTimeZoneDisplayKeyWithDifferentStyles() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] boolean daylight = false; [EOL] int[] styles = {TimeZone.SHORT, TimeZone.LONG}; [EOL] Locale locale = Locale.getDefault(); [EOL] for (int style : styles) { [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(timeZone, daylight, style, locale); [EOL] assertEquals(style, key.getStyle()); [EOL] assertEquals(locale, key.getLocale()); [EOL] } [EOL] } [EOL] public void testTimeZoneDisplayKeyWithDifferentLocales() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] boolean daylight = false; [EOL] int style = TimeZone.SHORT; [EOL] Locale[] locales = {Locale.US, Locale.FRANCE, Locale.JAPAN}; [EOL] for (Locale locale : locales) { [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(timeZone, daylight, style, locale); [EOL] assertEquals(locale, key.getLocale()); [EOL] } [EOL] }
public void testHashCode() { [EOL] StrMatcher matcher = new StrMatcher(); [EOL] int result = matcher.hashCode(); [EOL] int expected = (matcher.getStyle() * 31 + matcher.getLocale().hashCode()) * 31 + matcher.getTimeZone().hashCode(); [EOL] assertEquals(expected, result); [EOL] }
public void testEquals_Reflexive() { [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(TimeZone.getDefault(), 0, Locale.getDefault()); [EOL] assertTrue(key.equals(key)); [EOL] } [EOL] public void testEquals_Symmetric() { [EOL] TimeZoneDisplayKey key1 = new TimeZoneDisplayKey(TimeZone.getTimeZone("GMT"), 0, Locale.UK); [EOL] TimeZoneDisplayKey key2 = new TimeZoneDisplayKey(TimeZone.getTimeZone("GMT"), 0, Locale.UK); [EOL] assertTrue(key1.equals(key2)); [EOL] assertTrue(key2.equals(key1)); [EOL] } [EOL] public void testEquals_Null() { [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(TimeZone.getDefault(), 0, Locale.getDefault()); [EOL] assertFalse(key.equals(null)); [EOL] } [EOL] public void testEquals_IncompatibleType() { [EOL] TimeZoneDisplayKey key = new TimeZoneDisplayKey(TimeZone.getDefault(), 0, Locale.getDefault()); [EOL] Object other = new Object(); [EOL] assertFalse(key.equals(other)); [EOL] } [EOL] public void testEquals_DifferentTimeZone() { [EOL] TimeZoneDisplayKey key1 = new TimeZoneDisplayKey(TimeZone.getTimeZone("GMT"), 0, Locale.UK); [EOL] TimeZoneDisplayKey key2 = new TimeZoneDisplayKey(TimeZone.getTimeZone("PST"), 0, Locale.UK); [EOL] assertFalse(key1.equals(key2)); [EOL] } [EOL] public void testEquals_DifferentStyle() { [EOL] TimeZoneDisplayKey key1 = new TimeZoneDisplayKey(TimeZone.getDefault(), 0, Locale.getDefault()); [EOL] TimeZoneDisplayKey key2 = new TimeZoneDisplayKey(TimeZone.getDefault(), 1, Locale.getDefault()); [EOL] assertFalse(key1.equals(key2)); [EOL] } [EOL] public void testEquals_DifferentLocale() { [EOL] TimeZoneDisplayKey key1 = new TimeZoneDisplayKey(TimeZone.getDefault(), 0, Locale.UK); [EOL] TimeZoneDisplayKey key2 = new TimeZoneDisplayKey(TimeZone.getDefault(), 0, Locale.US); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testReflectionEquals_BothNull() { [EOL] boolean result = reflectionEquals(null, null, false, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_SameObject() { [EOL] Object obj = new Object(); [EOL] boolean result = reflectionEquals(obj, obj, false, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_OneNull() { [EOL] Object obj = new Object(); [EOL] boolean result = reflectionEquals(null, obj, false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_DifferentClasses() { [EOL] Object lhs = new Object(); [EOL] String rhs = "test"; [EOL] boolean result = reflectionEquals(lhs, rhs, false, null); [EOL] assertFalse(result); [EOL] } [EOL] public void testReflectionEquals_CompatibleClasses() { [EOL] Integer lhs = 1; [EOL] Number rhs = 1; [EOL] boolean result = reflectionEquals(lhs, rhs, false, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithExcludeFields() { [EOL] Integer lhs = 1; [EOL] Integer rhs = 1; [EOL] boolean result = reflectionEquals(lhs, rhs, false, null, "intValue"); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithReflectUpToClass() { [EOL] Integer lhs = 1; [EOL] Integer rhs = 1; [EOL] boolean result = reflectionEquals(lhs, rhs, false, Number.class); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_WithTestTransients() { [EOL] Integer lhs = 1; [EOL] Integer rhs = 1; [EOL] boolean result = reflectionEquals(lhs, rhs, true, null); [EOL] assertTrue(result); [EOL] } [EOL] public void testReflectionEquals_IllegalArgumentException() { [EOL] Object lhs = new Object() { [EOL] @Override [EOL] public boolean equals(Object obj) { [EOL] throw new IllegalArgumentException(); [EOL] } [EOL] }; [EOL] Object rhs = new Object(); [EOL] boolean result = reflectionEquals(lhs, rhs, false, null); [EOL] assertFalse(result); [EOL] }
public void testAppend_boolean_boolean_bothTrue() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(true, true); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_boolean_boolean_bothFalse() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(false, false); [EOL] assertTrue(builder.isEquals()); [EOL] }
public void testAppend_boolean_boolean_lhsTrueRhsFalse() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(true, false); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_boolean_boolean_lhsFalseRhsTrue() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(false, true); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_boolean_boolean_alreadyUnequal() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.append(true, false); [EOL] builder.append(true, true); // This should not change the isEquals to true since it's already false [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_Arrays_BothNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_Arrays_SameArray() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] array = new Object[] {1, 2, 3}; [EOL] builder.append(array, array); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_Arrays_DifferentLength() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_Arrays_DifferentElements() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 4}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_Arrays_SameElements() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_Arrays_OneNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_Arrays_EarlyExit() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testAppend_CharArray_Equal() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_NotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'a', 'b', 'd'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_LeftNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = null; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_RightNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_BothNull() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = null; [EOL] char[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_DifferentLength() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] char[] lhs = new char[]{'a', 'b'}; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] } [EOL] public void testAppend_CharArray_AlreadyNotEqual() { [EOL] EqualsBuilder builder = new EqualsBuilder(); [EOL] builder.setEquals(false); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertFalse(builder.isEquals()); [EOL] }
public void testTabMatcher() { [EOL] StrMatcher matcher = StrMatcher.tabMatcher(); [EOL] assertNotNull(matcher); [EOL] assertTrue(matcher.isMatch("\t".toCharArray(), 0, 0, 1)); [EOL] assertFalse(matcher.isMatch(" ".toCharArray(), 0, 0, 1)); [EOL] }
public void testRandomWithLettersOnly() { [EOL] String result = StringUtils.random(5, 0, 0, true, false); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[a-zA-Z]+")); [EOL] }
public void testRandomWithNumbersOnly() { [EOL] String result = StringUtils.random(5, 0, 0, false, true); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[0-9]+")); [EOL] }
public void testRandomWithLettersAndNumbers() { [EOL] String result = StringUtils.random(5, 0, 0, true, true); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[a-zA-Z0-9]+")); [EOL] }
public void testRandomWithSpecificChars() { [EOL] char[] chars = new char[] {'a', 'b', 'c', '1', '2', '3'}; [EOL] String result = StringUtils.random(5, 0, 0, false, false, chars); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[abc123]+")); [EOL] }
public void testRandomWithEmptyCharsArray() { [EOL] String result = StringUtils.random(5, 0, 0, false, false, new char[]{}); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.length()); [EOL] assertTrue(result.matches("[a-zA-Z0-9]+")); [EOL] }
public void testRandomWithZeroCount() { [EOL] String result = StringUtils.random(0, 0, 0, true, true); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length()); [EOL] }
public void testRandomWithNegativeCount() { [EOL] String result = StringUtils.random(-1, 0, 0, true, true); [EOL] assertNull(result); [EOL] }
public void testRandomWithInvalidRange() { [EOL] String result = StringUtils.random(5, 10, 2, true, true); [EOL] assertNull(result); [EOL] }
public void testRandomStringLengthZero() { [EOL] String result = RandomStringUtils.random(0, 0, 0, false, false, null, new Random()); [EOL] assertEquals("", result); [EOL] }
public void testRandomStringLengthNegative() { [EOL] try { [EOL] RandomStringUtils.random(-1, 0, 0, false, false, null, new Random()); [EOL] fail("Expected IllegalArgumentException for negative length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringCharsArrayEmpty() { [EOL] try { [EOL] RandomStringUtils.random(5, 0, 0, false, false, new char[]{}, new Random()); [EOL] fail("Expected IllegalArgumentException for empty chars array"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringInvalidRange() { [EOL] try { [EOL] RandomStringUtils.random(5, 10, 5, false, false, null, new Random()); [EOL] fail("Expected IllegalArgumentException for end <= start"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRandomStringLettersAndNumbers() { [EOL] String result = RandomStringUtils.random(5, 0, 0, true, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[a-zA-Z0-9]{5}")); [EOL] }
public void testRandomStringLettersOnly() { [EOL] String result = RandomStringUtils.random(5, 'a', 'z', true, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[a-zA-Z]{5}")); [EOL] }
public void testRandomStringNumbersOnly() { [EOL] String result = RandomStringUtils.random(5, '0', '9', false, true, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[0-9]{5}")); [EOL] }
public void testRandomStringCustomCharsArray() { [EOL] char[] customChars = {'a', 'b', 'c', '1', '2', '3'}; [EOL] String result = RandomStringUtils.random(5, 0, customChars.length, false, false, customChars, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("[abc123]{5}")); [EOL] }
public void testRandomStringSurrogatePairs() { [EOL] String result = RandomStringUtils.random(2, 55296, 56191, false, false, null, new Random()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length() == 2); [EOL] assertTrue(Character.isHighSurrogate(result.charAt(0))); [EOL] assertTrue(Character.isLowSurrogate(result.charAt(1))); [EOL] }
public void testRandomWithNullChars() { [EOL] String randomString = StringUtils.random(5, (String) null); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] }
public void testRandomWithEmptyChars() { [EOL] String randomString = StringUtils.random(5, ""); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] }
public void testRandomWithSpecificChars() { [EOL] String randomString = StringUtils.random(5, "abc"); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] assertTrue(randomString.matches("[abc]+")); [EOL] }
public void testRandomWithNullChars() { [EOL] String randomString = RandomStringUtils.random(5, (char[]) null); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] }
public void testRandomWithEmptyChars() { [EOL] String randomString = RandomStringUtils.random(5, new char[0]); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] }
public void testRandomWithSpecificChars() { [EOL] char[] chars = new char[] {'a', 'b', 'c'}; [EOL] String randomString = RandomStringUtils.random(5, chars); [EOL] assertNotNull(randomString); [EOL] assertEquals(5, randomString.length()); [EOL] for (char c : randomString.toCharArray()) { [EOL] assertTrue(ArrayUtils.contains(chars, c)); [EOL] } [EOL] }
public void testMutableByteConstructor() { [EOL] MutableByte mutableByte = new MutableByte(); [EOL] assertNotNull(mutableByte); [EOL] assertEquals(0, mutableByte.byteValue()); [EOL] }
public void testGetValueWhenValueIsSet() { [EOL] final byte testValue = 10; [EOL] ClassName classNameInstance = new ClassName(testValue); [EOL] Byte result = classNameInstance.getValue(); [EOL] assertEquals(Byte.valueOf(testValue), result); [EOL] }
public void testSetValue() { [EOL] MyClass instance = new MyClass(); [EOL] byte expectedValue = 10; [EOL] instance.setValue(expectedValue); [EOL] assertEquals(expectedValue, instance.value); [EOL] }
public void testSetValueWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(null); [EOL] assertEquals("Expected value to be the byte equivalent of null", 0, instance.getValue()); [EOL] }
public void testSetValueWithByteMaxValue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(Byte.MAX_VALUE); [EOL] assertEquals("Expected value to be the byte equivalent of Byte.MAX_VALUE", Byte.MAX_VALUE, instance.getValue()); [EOL] }
public void testSetValueWithByteMinValue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(Byte.MIN_VALUE); [EOL] assertEquals("Expected value to be the byte equivalent of Byte.MIN_VALUE", Byte.MIN_VALUE, instance.getValue()); [EOL] }
public void testIncrement() { [EOL] MutableInt mutableInt = new MutableInt(); [EOL] mutableInt.increment(); [EOL] assertEquals(1, mutableInt.intValue()); [EOL] }
public void testIncrementFromNonZero() { [EOL] MutableInt mutableInt = new MutableInt(5); [EOL] mutableInt.increment(); [EOL] assertEquals(6, mutableInt.intValue()); [EOL] }
public void testSubtractWithByteOperand() { [EOL] MutableByte instance = new MutableByte((byte) 10); [EOL] instance.subtract((Number) (byte) 1); [EOL] assertEquals((byte) 9, instance.byteValue()); [EOL] }
public void testSubtractWithShortOperand() { [EOL] MutableByte instance = new MutableByte((byte) 10); [EOL] instance.subtract((Number) (short) 1); [EOL] assertEquals((byte) 9, instance.byteValue()); [EOL] }
public void testSubtractWithIntegerOperand() { [EOL] MutableByte instance = new MutableByte((byte) 10); [EOL] instance.subtract((Number) 1); [EOL] assertEquals((byte) 9, instance.byteValue()); [EOL] }
public void testSubtractWithLongOperand() { [EOL] MutableByte instance = new MutableByte((byte) 10); [EOL] instance.subtract((Number) 1L); [EOL] assertEquals((byte) 9, instance.byteValue()); [EOL] }
public void testSubtractWithFloatOperand() { [EOL] MutableByte instance = new MutableByte((byte) 10); [EOL] instance.subtract((Number) 1.0f); [EOL] assertEquals((byte) 9, instance.byteValue()); [EOL] }
public void testSubtractWithDoubleOperand() { [EOL] MutableByte instance = new MutableByte((byte) 10); [EOL] instance.subtract((Number) 1.0d); [EOL] assertEquals((byte) 9, instance.byteValue()); [EOL] }
public void testByteValue_Positive() { [EOL] ByteUtils byteUtils = new ByteUtils((byte) 1); [EOL] byte result = byteUtils.byteValue(); [EOL] assertEquals((byte) 1, result); [EOL] }
public void testByteValue_Negative() { [EOL] ByteUtils byteUtils = new ByteUtils((byte) -1); [EOL] byte result = byteUtils.byteValue(); [EOL] assertEquals((byte) -1, result); [EOL] }
public void testByteValue_Zero() { [EOL] ByteUtils byteUtils = new ByteUtils((byte) 0); [EOL] byte result = byteUtils.byteValue(); [EOL] assertEquals((byte) 0, result); [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableByte mbFive = new MutableByte((byte) 5); [EOL] MutableByte mbTen = new MutableByte((byte) 10); [EOL] int result = mbFive.compareTo(mbTen); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_Equal() { [EOL] MutableByte mbFive1 = new MutableByte((byte) 5); [EOL] MutableByte mbFive2 = new MutableByte((byte) 5); [EOL] int result = mbFive1.compareTo(mbFive2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] MutableByte mbTen = new MutableByte((byte) 10); [EOL] MutableByte mbFive = new MutableByte((byte) 5); [EOL] int result = mbTen.compareTo(mbFive); [EOL] assertTrue(result > 0); [EOL] }
public void testAppendWithValidParameters() { [EOL] CharSequence seq = "Test"; [EOL] Formatter formatter = new Formatter(); [EOL] int flags = 0; [EOL] int width = 10; [EOL] int precision = 5; [EOL] char padChar = ' '; [EOL] Formatter result = StringUtils.append(seq, formatter, flags, width, precision, padChar); [EOL] assertNotNull(result); [EOL] assertEquals("Test      ", result.toString()); [EOL] }
It seems there has been a misunderstanding. The input text you've provided is a constructor for an `EnumUtils` class that appears to be empty. Since constructors that only contain an opening and closing bracket without any code (e.g., `{ [EOL] }`) do not contain any logic or branches, they do not require any test cases. There are no lines of executable code to cover in this constructor. [EOL] In Java, if a class does not explicitly define a constructor, the Java compiler automatically provides a default no-argument constructor, which is what this appears to be. Testing such a constructor would not provide any meaningful assertions or line coverage, as it does nothing. [EOL] If you have a different method with executable code that you would like to generate test cases for, please provide that method, and I can help generate the corresponding test cases.
public void testGenerateBitVectorWithValidEnumAndValues() { [EOL] EnumSet<TestEnum> values = EnumSet.of(TestEnum.FIRST, TestEnum.SECOND); [EOL] long bitVector = EnumUtils.generateBitVector(TestEnum.class, values); [EOL] long expectedBitVector = (1 << TestEnum.FIRST.ordinal()) | (1 << TestEnum.SECOND.ordinal()); [EOL] assertEquals(expectedBitVector, bitVector); [EOL] } [EOL] public void testGenerateBitVectorWithEmptyValues() { [EOL] EnumSet<TestEnum> values = EnumSet.noneOf(TestEnum.class); [EOL] long bitVector = EnumUtils.generateBitVector(TestEnum.class, values); [EOL] assertEquals(0L, bitVector); [EOL] } [EOL] public void testGenerateBitVectorWithNullValues() { [EOL] try { [EOL] EnumUtils.generateBitVector(TestEnum.class, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] } [EOL] public void testGenerateBitVectorWithNullElementInValues() { [EOL] List<TestEnum> values = Arrays.asList(TestEnum.FIRST, null); [EOL] try { [EOL] EnumUtils.generateBitVector(TestEnum.class, values); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testGenerateBitVectorWithNonEnumClass() { [EOL] try { [EOL] EnumUtils.generateBitVector(NonEnum.class, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] private enum TestEnum { [EOL] FIRST, SECOND, THIRD [EOL] } [EOL] private class NonEnum { [EOL] }
public void testGenerateBitVectorsWithNullEnumClass() { [EOL] try { [EOL] EnumUtils.generateBitVectors(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] }
public void testGenerateBitVectorsWithEmptyValues() { [EOL] long[] result = EnumUtils.generateBitVectors(SomeEnum.class); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(0L, result[0]); [EOL] }
public void testGenerateBitVectorsWithValidEnumAndValues() { [EOL] long[] result = EnumUtils.generateBitVectors(SomeEnum.class, SomeEnum.CONSTANT1, SomeEnum.CONSTANT2); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] assertEquals(3L, result[0]); // 3L represents the bit vector for CONSTANT1 and CONSTANT2 [EOL] }
public void testGenerateBitVectorsWithAllEnumValues() { [EOL] long[] result = EnumUtils.generateBitVectors(SomeEnum.class, SomeEnum.values()); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] assertEquals(7L, result[0]); // 7L represents the bit vector for all constants [EOL] }
public void testGetInstanceWithNullPattern() { [EOL] try { [EOL] getInstance(null, TimeZone.getDefault(), Locale.getDefault()); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("pattern must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testGetInstanceWithNullTimeZone() { [EOL] F result = getInstance("pattern", null, Locale.getDefault()); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetInstanceWithNullLocale() { [EOL] F result = getInstance("pattern", TimeZone.getDefault(), null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetInstanceWithAllNonNull() { [EOL] F result = getInstance("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(result); [EOL] } [EOL] public void testGetInstanceWithCachedInstance() { [EOL] F firstCall = getInstance("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] F secondCall = getInstance("pattern", TimeZone.getDefault(), Locale.getDefault()); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testGetDateTimeInstanceWithValidStylesAndTimeZoneAndLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.MEDIUM; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] DateFormat result = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] assertNotNull(result); [EOL] }
public void testGetDateTimeInstanceWithNullLocale() { [EOL] int dateStyle = DateFormat.SHORT; [EOL] int timeStyle = DateFormat.MEDIUM; [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] Locale locale = null; [EOL] DateFormat result = FastDateFormat.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] assertNotNull(result); [EOL] }
public void testGetTimeInstanceWithDifferentStyles() { [EOL] DateFormat df1 = FastDateFormat.getTimeInstance(DateFormat.SHORT, TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(df1); [EOL] DateFormat df2 = FastDateFormat.getTimeInstance(DateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(df2); [EOL] DateFormat df3 = FastDateFormat.getTimeInstance(DateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(df3); [EOL] DateFormat df4 = FastDateFormat.getTimeInstance(DateFormat.FULL, TimeZone.getDefault(), Locale.getDefault()); [EOL] assertNotNull(df4); [EOL] }
public void testGetTimeInstanceWithDifferentTimeZones() { [EOL] TimeZone tz1 = TimeZone.getTimeZone("GMT"); [EOL] TimeZone tz2 = TimeZone.getTimeZone("UTC"); [EOL] TimeZone tz3 = TimeZone.getTimeZone("PST"); [EOL] DateFormat df1 = FastDateFormat.getTimeInstance(DateFormat.DEFAULT, tz1, Locale.getDefault()); [EOL] DateFormat df2 = FastDateFormat.getTimeInstance(DateFormat.DEFAULT, tz2, Locale.getDefault()); [EOL] DateFormat df3 = FastDateFormat.getTimeInstance(DateFormat.DEFAULT, tz3, Locale.getDefault()); [EOL] assertNotNull(df1); [EOL] assertNotNull(df2); [EOL] assertNotNull(df3); [EOL] }
public void testGetTimeInstanceWithDifferentLocales() { [EOL] Locale locale1 = Locale.ENGLISH; [EOL] Locale locale2 = Locale.FRENCH; [EOL] Locale locale3 = Locale.GERMAN; [EOL] DateFormat df1 = FastDateFormat.getTimeInstance(DateFormat.DEFAULT, TimeZone.getDefault(), locale1); [EOL] DateFormat df2 = FastDateFormat.getTimeInstance(DateFormat.DEFAULT, TimeZone.getDefault(), locale2); [EOL] DateFormat df3 = FastDateFormat.getTimeInstance(DateFormat.DEFAULT, TimeZone.getDefault(), locale3); [EOL] assertNotNull(df1); [EOL] assertNotNull(df2); [EOL] assertNotNull(df3); [EOL] }
public void testGetTimeInstanceWithNullLocale() { [EOL] try { [EOL] FastDateFormat.getTimeInstance(DateFormat.DEFAULT, TimeZone.getDefault(), null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetPatternForStyleWithDateStyleOnly() { [EOL] Locale locale = Locale.US; [EOL] Integer dateStyle = DateFormat.MEDIUM; [EOL] String pattern = getPatternForStyle(dateStyle, null, locale); [EOL] assertNotNull(pattern); [EOL] DateFormat formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL] String expectedPattern = ((SimpleDateFormat) formatter).toPattern(); [EOL] assertEquals(expectedPattern, pattern); [EOL] }
public void testGetPatternForStyleWithTimeStyleOnly() { [EOL] Locale locale = Locale.US; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] String pattern = getPatternForStyle(null, timeStyle, locale); [EOL] assertNotNull(pattern); [EOL] DateFormat formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL] String expectedPattern = ((SimpleDateFormat) formatter).toPattern(); [EOL] assertEquals(expectedPattern, pattern); [EOL] }
public void testGetPatternForStyleWithBothStyles() { [EOL] Locale locale = Locale.US; [EOL] Integer dateStyle = DateFormat.MEDIUM; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL] assertNotNull(pattern); [EOL] DateFormat formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL] String expectedPattern = ((SimpleDateFormat) formatter).toPattern(); [EOL] assertEquals(expectedPattern, pattern); [EOL] }
public void testGetPatternForStyleWithInvalidLocale() { [EOL] Locale locale = new Locale("invalid"); [EOL] Integer dateStyle = DateFormat.MEDIUM; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] try { [EOL] getPatternForStyle(dateStyle, timeStyle, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetPatternForStyleWithCachedPattern() { [EOL] Locale locale = Locale.US; [EOL] Integer dateStyle = DateFormat.MEDIUM; [EOL] Integer timeStyle = DateFormat.MEDIUM; [EOL] String pattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL] assertNotNull(pattern); [EOL] String cachedPattern = getPatternForStyle(dateStyle, timeStyle, locale); [EOL] assertSame(pattern, cachedPattern); [EOL] }
public void testMultipartKeyWithNull() { [EOL] MultipartKey multipartKey = new MultipartKey((Object[]) null); [EOL] assertNull(multipartKey.keys); [EOL] }
public void testMultipartKeyWithEmptyArray() { [EOL] MultipartKey multipartKey = new MultipartKey(new Object[]{}); [EOL] assertNotNull(multipartKey.keys); [EOL] assertEquals(0, multipartKey.keys.length); [EOL] }
public void testMultipartKeyWithNonEmptyArray() { [EOL] Object[] inputKeys = new Object[]{"key1", "key2", "key3"}; [EOL] MultipartKey multipartKey = new MultipartKey(inputKeys); [EOL] assertNotNull(multipartKey.keys); [EOL] assertEquals(inputKeys.length, multipartKey.keys.length); [EOL] assertArrayEquals(inputKeys, multipartKey.keys); [EOL] }
public void testEquals_withEqualMultipartKeys() { [EOL] Object[] keys1 = new Object[] {"key1", "key2", "key3"}; [EOL] Object[] keys2 = new Object[] {"key1", "key2", "key3"}; [EOL] MultipartKey multipartKey1 = new MultipartKey(keys1); [EOL] MultipartKey multipartKey2 = new MultipartKey(keys2); [EOL] boolean result = multipartKey1.equals(multipartKey2); [EOL] assertTrue(result); [EOL] }
public void testEquals_withNonEqualMultipartKeys() { [EOL] Object[] keys1 = new Object[] {"key1", "key2", "key3"}; [EOL] Object[] keys2 = new Object[] {"key1", "differentKey", "key3"}; [EOL] MultipartKey multipartKey1 = new MultipartKey(keys1); [EOL] MultipartKey multipartKey2 = new MultipartKey(keys2); [EOL] boolean result = multipartKey1.equals(multipartKey2); [EOL] assertFalse(result); [EOL] }
public void testEquals_withItself() { [EOL] Object[] keys = new Object[] {"key1", "key2", "key3"}; [EOL] MultipartKey multipartKey = new MultipartKey(keys); [EOL] boolean result = multipartKey.equals(multipartKey); [EOL] assertTrue(result); [EOL] }
public void testEquals_withNull() { [EOL] Object[] keys = new Object[] {"key1", "key2", "key3"}; [EOL] MultipartKey multipartKey = new MultipartKey(keys); [EOL] boolean result = multipartKey.equals(null); [EOL] assertFalse(result); [EOL] }
public void testEquals_withDifferentClass() { [EOL] Object[] keys = new Object[] {"key1", "key2", "key3"}; [EOL] MultipartKey multipartKey = new MultipartKey(keys); [EOL] Object differentClassObj = new Object(); [EOL] boolean result = multipartKey.equals(differentClassObj); [EOL] assertFalse(result); [EOL] }
public void testHashCodeWhenHashCodeIsZeroAndKeysNotNull() { [EOL] keys.add("key1"); [EOL] keys.add("key2"); [EOL] keys.add("key3"); [EOL] hashCode = 0; // Ensure hashCode starts at 0 [EOL] int expectedHashCode = ("key1".hashCode() * 7 + "key2".hashCode()) * 7 + "key3".hashCode(); [EOL] int actualHashCode = hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWhenHashCodeIsZeroAndKeysContainNull() { [EOL] keys.add("key1"); [EOL] keys.add(null); // Include a null key to test the null condition [EOL] keys.add("key3"); [EOL] hashCode = 0; // Ensure hashCode starts at 0 [EOL] int expectedHashCode = ("key1".hashCode() * 7) * 7 + "key3".hashCode(); [EOL] int actualHashCode = hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWhenHashCodeIsNotZero() { [EOL] keys.add("key1"); [EOL] hashCode = 123; // Set a non-zero hashCode [EOL] int actualHashCode = hashCode(); [EOL] assertEquals(123, actualHashCode); // Expect the pre-set non-zero hashCode [EOL] }
public void testToString() { [EOL] Triple<String, String, String> triple = new ImmutableTriple<>("left", "middle", "right"); [EOL] String result = triple.toString(); [EOL] assertEquals("(left,middle,right)", result); [EOL] }
public void testSetDefaultStyleWithNonNull() { [EOL] ToStringStyle style = ToStringStyle.DEFAULT_STYLE; [EOL] ToStringBuilder.setDefaultStyle(style); [EOL] assertEquals(style, ToStringBuilder.getDefaultStyle()); [EOL] } [EOL] public void testSetDefaultStyleWithNull() { [EOL] try { [EOL] ToStringBuilder.setDefaultStyle(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The style must not be null", e.getMessage()); [EOL] } [EOL] }
public void testAppendBooleanArray_Null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] boolean[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{}"); [EOL] }
public void testAppendBooleanArray_Empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] boolean[] array = new boolean[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{}"); [EOL] }
public void testAppendBooleanArray_NonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] boolean[] array = new boolean[] {true, false, true}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), this.toString() + "{true,false,true}"); [EOL] }
public void testAppendShortArray_Null() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] short[] array = null; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "ToStringBuilder@1[]"); [EOL] }
public void testAppendShortArray_Empty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] short[] array = new short[0]; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "ToStringBuilder@1[]"); [EOL] }
public void testAppendShortArray_NonEmpty() { [EOL] ToStringBuilder tsb = new ToStringBuilder(this); [EOL] short[] array = new short[] {1, 2, 3}; [EOL] tsb.append(array); [EOL] assertEquals(tsb.toString(), "ToStringBuilder@1[1,2,3]"); [EOL] }
public void testToStringWhenValueIsNull() { [EOL] MyClass instance = new MyClass(null); [EOL] String result = instance.toString(); [EOL] assertEquals("null", result); [EOL] }
public void testToStringWhenValueIsNotNull() { [EOL] MyClass instance = new MyClass("test"); [EOL] String result = instance.toString(); [EOL] assertEquals("test", result); [EOL] }
public DateUtils() { [EOL] super(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public static Date addWeeks(final Date date, final int amount) { [EOL] return add(date, Calendar.WEEK_OF_YEAR, amount); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public static Date addHours(final Date date, final int amount) { [EOL] return add(date, Calendar.HOUR_OF_DAY, amount); [EOL] } [EOL] public DateUtils() { } [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal) { } [EOL] public static boolean isSameDay(final Date date1, final Date date2) { } [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameInstant(final Date date1, final Date date2) { } [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { } [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { } [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException { } [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException { } [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException { } [EOL] public static Date addYears(final Date date, final int amount) { } [EOL] public static Date addMonths(final Date date, final int amount) { } [EOL] public static Date addWeeks(final Date date, final int amount) { } [EOL] public static Date addDays(final Date date, final int amount) { } [EOL] public static Date addHours(final Date date, final int amount) { } [EOL] public static Date addMinutes(final Date date, final int amount) { } [EOL] public static Date addSeconds(final Date date, final int amount) { } [EOL] public static Date addMilliseconds(final Date date, final int amount) { } [EOL] private static Date add(final Date date, final int calendarField, final int amount) { } [EOL] public static Date setYears(final Date date, final int amount) { } [EOL] public static Date setMonths(final Date date, final int amount) { } [EOL] public static Date setDays(final Date date, final int amount) { } [EOL] public static Date setHours(final Date date, final int amount) { } [EOL] public static Date setMinutes(final Date date, final int amount) { } [EOL] public static Date setSeconds(final Date date, final int amount) { } [EOL] public static Date setMilliseconds(final Date date, final int amount) { } [EOL] private static Date set(final Date date, final int calendarField, final int amount) { } [EOL] public static Calendar toCalendar(final Date date) { } [EOL] public static Date round(final Date date, final int field) { } [EOL] public static Calendar round(final Calendar date, final int field) { } [EOL] public static Date round(final Object date, final int field) { } [EOL] public static Date truncate(final Date date, final int field) { } [EOL] public static Calendar truncate(final Calendar date, final int field) { } [EOL] public static Date truncate(final Object date, final int field) { } [EOL] public static Date ceiling(final Date date, final int field) { } [EOL] public static Calendar ceiling(final Calendar date, final int field) { } [EOL] public static Date ceiling(final Object date, final int field) { } [EOL] private static void modify(final Calendar val, final int field, final int modType) { } [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) { } [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { } [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle) { } [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Date date, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Date date, final int fragment) { } [EOL] public static long getFragmentInHours(final Date date, final int fragment) { } [EOL] public static long getFragmentInDays(final Date date, final int fragment) { } [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment) { } [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment) { } [EOL] private static long getFragment(final Date date, final int fragment, final int unit) { } [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit) { } [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { } [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) { } [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { } [EOL] private static long getMillisPerUnit(final int unit) { } [EOL] public boolean hasNext() { } [EOL] public Calendar next() { } [EOL] public void remove() { } [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };
public static Date addMilliseconds(final Date date, final int amount) { [EOL] return add(date, Calendar.MILLISECOND, amount); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={{ [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }};
private static Date add(final Date date, final int calendarField, final int amount) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar c = Calendar.getInstance(); [EOL] c.setTime(date); [EOL] c.add(calendarField, amount); [EOL] return c.getTime(); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }};
public void testRoundWithNullDate() { [EOL] try { [EOL] DateUtils.round(null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRoundWithValidDateAndField() { [EOL] Date date = new Date(); [EOL] Date roundedDate = DateUtils.round(date, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Rounded date should not be null", roundedDate); [EOL] }
public void testRoundWithInvalidField() { [EOL] try { [EOL] Date date = new Date(); [EOL] DateUtils.round(date, Calendar.FIELD_COUNT); [EOL] fail("Should have thrown IllegalArgumentException or ArrayIndexOutOfBoundsException"); [EOL] } catch (IllegalArgumentException | ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRoundCalendarWithNullDate() { [EOL] try { [EOL] DateUtils.round((Calendar) null, Calendar.MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRoundCalendarWithValidDateAndField() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.JANUARY, 25, 1, 29, 59); [EOL] cal.set(Calendar.MILLISECOND, 123); [EOL] Calendar rounded = DateUtils.round(cal, Calendar.HOUR); [EOL] assertEquals(2023, rounded.get(Calendar.YEAR)); [EOL] assertEquals(Calendar.JANUARY, rounded.get(Calendar.MONTH)); [EOL] assertEquals(25, rounded.get(Calendar.DATE)); [EOL] assertEquals(2, rounded.get(Calendar.HOUR_OF_DAY)); [EOL] assertEquals(0, rounded.get(Calendar.MINUTE)); [EOL] assertEquals(0, rounded.get(Calendar.SECOND)); [EOL] assertEquals(0, rounded.get(Calendar.MILLISECOND)); [EOL] } [EOL] public void testRoundCalendarWithDifferentFields() { [EOL] Calendar cal = Calendar.getInstance(); [EOL] cal.set(2023, Calendar.JANUARY, 25, 1, 29, 59); [EOL] cal.set(Calendar.MILLISECOND, 123); [EOL] Calendar roundedMonth = DateUtils.round(cal, Calendar.MONTH); [EOL] assertEquals(2023, roundedMonth.get(Calendar.YEAR)); [EOL] assertEquals(Calendar.FEBRUARY, roundedMonth.get(Calendar.MONTH)); [EOL] assertEquals(1, roundedMonth.get(Calendar.DATE)); [EOL] Calendar roundedMinute = DateUtils.round(cal, Calendar.MINUTE); [EOL] assertEquals(30, roundedMinute.get(Calendar.MINUTE)); [EOL] Calendar roundedYear = DateUtils.round(cal, Calendar.YEAR); [EOL] assertEquals(2024, roundedYear.get(Calendar.YEAR)); [EOL] }
public void testRoundWithNullDate() { [EOL] try { [EOL] DateUtils.round(null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRoundWithDate() { [EOL] Date date = new Date(); [EOL] Date roundedDate = DateUtils.round(date, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Rounded date should not be null", roundedDate); [EOL] } [EOL] public void testRoundWithCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] Date roundedDate = DateUtils.round(calendar, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Rounded date should not be null", roundedDate); [EOL] } [EOL] public void testRoundWithInvalidObjectType() { [EOL] try { [EOL] Object invalidObject = new Object(); [EOL] DateUtils.round(invalidObject, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException cce) { [EOL] } [EOL] }
public static Date truncate(final Date date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar gval = Calendar.getInstance(); [EOL] gval.setTime(date); [EOL] modify(gval, field, MODIFY_TRUNCATE); [EOL] return gval.getTime(); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=1000; long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; int SEMI_MONTH=1001; int[][] fields={{ Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA }}
public static Calendar truncate(final Calendar date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar truncated = (Calendar) date.clone(); [EOL] modify(truncated, field, MODIFY_TRUNCATE); [EOL] return truncated; [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public static Date truncate(final Object date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] if (date instanceof Date) { [EOL] return truncate((Date) date, field); [EOL] } else if (date instanceof Calendar) { [EOL] return truncate((Calendar) date, field).getTime(); [EOL] } else { [EOL] throw new ClassCastException("Could not truncate " + date); [EOL] } [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public void testCeilingWithNullDate() { [EOL] try { [EOL] DateUtils.ceiling(null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testCeilingWithValidDate() { [EOL] Date date = new Date(); [EOL] Date ceilingDate = DateUtils.ceiling(date, Calendar.DAY_OF_MONTH); [EOL] assertNotNull("Ceiling date should not be null", ceilingDate); [EOL] } [EOL] public void testCeilingWithDifferentFields() { [EOL] Date date = new Date(); [EOL] Date ceilingDateDay = DateUtils.ceiling(date, Calendar.DAY_OF_MONTH); [EOL] Date ceilingDateMonth = DateUtils.ceiling(date, Calendar.MONTH); [EOL] Date ceilingDateYear = DateUtils.ceiling(date, Calendar.YEAR); [EOL] }
public void testCeilingWithInvalidField() { [EOL] Date date = new Date(); [EOL] try { [EOL] DateUtils.ceiling(date, Calendar.FIELD_COUNT); [EOL] fail("Should have thrown IllegalArgumentException or ArrayIndexOutOfBoundsException"); [EOL] } catch (IllegalArgumentException | ArrayIndexOutOfBoundsException expected) { [EOL] } [EOL] }
public static Calendar ceiling(final Calendar date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar ceiled = (Calendar) date.clone(); [EOL] modify(ceiled, field, MODIFY_CEILING); [EOL] return ceiled; [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={{ [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }}
public static Date ceiling(final Object date, final int field) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] if (date instanceof Date) { [EOL] return ceiling((Date) date, field); [EOL] } else if (date instanceof Calendar) { [EOL] return ceiling((Calendar) date, field).getTime(); [EOL] } else { [EOL] throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL] } [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
private static void modify(final Calendar val, final int field, final int modType) { [EOL] if (val.get(Calendar.YEAR) > 280000000) { [EOL] throw new ArithmeticException("Calendar value too large for accurate calculations"); [EOL] } [EOL] if (field == Calendar.MILLISECOND) { [EOL] return; [EOL] } [EOL] final Date date = val.getTime(); [EOL] long time = date.getTime(); [EOL] boolean done = false; [EOL] final int millisecs = val.get(Calendar.MILLISECOND); [EOL] if (MODIFY_TRUNCATE == modType || millisecs < 500) { [EOL] time = time - millisecs; [EOL] } [EOL] if (field == Calendar.SECOND) { [EOL] done = true; [EOL] } [EOL] final int seconds = val.get(Calendar.SECOND); [EOL] if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) { [EOL] time = time - (seconds * 1000L); [EOL] } [EOL] if (field == Calendar.MINUTE) { [EOL] done = true; [EOL] } [EOL] final int minutes = val.get(Calendar.MINUTE); [EOL] if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) { [EOL] time = time - (minutes * 60000L); [EOL] } [EOL] if (date.getTime() != time) { [EOL] date.setTime(time); [EOL] val.setTime(date); [EOL] } [EOL] boolean roundUp = false; [EOL] for (final int[] aField : fields) { [EOL] for (final int element : aField) { [EOL] if (element == field) { [EOL] if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) { [EOL] if (field == DateUtils.SEMI_MONTH) { [EOL] if (val.get(Calendar.DATE) == 1) { [EOL] val.add(Calendar.DATE, 15); [EOL] } else { [EOL] val.add(Calendar.DATE, -15); [EOL] val.add(Calendar.MONTH, 1); [EOL] } [EOL] } else if (field == Calendar.AM_PM) { [EOL] if (val.get(Calendar.HOUR_OF_DAY) == 0) { [EOL] val.add(Calendar.HOUR_OF_DAY, 12); [EOL] } else { [EOL] val.add(Calendar.HOUR_OF_DAY, -12); [EOL] val.add(Calendar.DATE, 1); [EOL] } [EOL] } else { [EOL] val.add(aField[0], 1); [EOL] } [EOL] } [EOL] return; [EOL] } [EOL] } [EOL] int offset = 0; [EOL] boolean offsetSet = false; [EOL] switch(field) { [EOL] case DateUtils.SEMI_MONTH: [EOL] if (aField[0] == Calendar.DATE) { [EOL] offset = val.get(Calendar.DATE) - 1; [EOL] if (offset >= 15) { [EOL] offset -= 15; [EOL] } [EOL] roundUp = offset > 7; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] case Calendar.AM_PM: [EOL] if (aField[0] == Calendar.HOUR_OF_DAY) { [EOL] offset = val.get(Calendar.HOUR_OF_DAY); [EOL] if (offset >= 12) { [EOL] offset -= 12; [EOL] } [EOL] roundUp = offset >= 6; [EOL] offsetSet = true; [EOL] } [EOL] break; [EOL] } [EOL] if (!offsetSet) { [EOL] final int min = val.getActualMinimum(aField[0]); [EOL] final int max = val.getActualMaximum(aField[0]); [EOL] offset = val.get(aField[0]) - min; [EOL] roundUp = offset > ((max - min) / 2); [EOL] } [EOL] if (offset != 0) { [EOL] val.set(aField[0], val.get(aField[0]) - offset); [EOL] } [EOL] } [EOL] throw new IllegalArgumentException("The field " + field + " is not supported"); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=Optional[1000]; [EOL] long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; [EOL] long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; [EOL] long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; [EOL] int SEMI_MONTH=Optional[1001]; [EOL] int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }];
public void testIteratorWithNullDate() { [EOL] try { [EOL] DateUtils.iterator((Date) null, Calendar.DAY_OF_MONTH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIteratorWithValidDate() { [EOL] Date focus = new Date(); [EOL] int rangeStyle = Calendar.DAY_OF_MONTH; [EOL] Iterator<Calendar> it = DateUtils.iterator(focus, rangeStyle); [EOL] assertNotNull("Iterator should not be null", it); [EOL] }
public void testIteratorWithDifferentRangeStyles() { [EOL] Date focus = new Date(); [EOL] int[] rangeStyles = new int[] { [EOL] Calendar.DAY_OF_MONTH, [EOL] Calendar.DAY_OF_WEEK, [EOL] Calendar.DAY_OF_YEAR [EOL] }; [EOL] for (int rangeStyle : rangeStyles) { [EOL] Iterator<Calendar> it = DateUtils.iterator(focus, rangeStyle); [EOL] assertNotNull("Iterator should not be null for range style: " + rangeStyle, it); [EOL] } [EOL] }
public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) { [EOL] if (focus == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] Calendar start = null; [EOL] Calendar end = null; [EOL] int startCutoff = Calendar.SUNDAY; [EOL] int endCutoff = Calendar.SATURDAY; [EOL] switch(rangeStyle) { [EOL] case RANGE_MONTH_SUNDAY: [EOL] case RANGE_MONTH_MONDAY: [EOL] start = truncate(focus, Calendar.MONTH); [EOL] end = (Calendar) start.clone(); [EOL] end.add(Calendar.MONTH, 1); [EOL] end.add(Calendar.DATE, -1); [EOL] if (rangeStyle == RANGE_MONTH_MONDAY) { [EOL] startCutoff = Calendar.MONDAY; [EOL] endCutoff = Calendar.SUNDAY; [EOL] } [EOL] break; [EOL] case RANGE_WEEK_SUNDAY: [EOL] case RANGE_WEEK_MONDAY: [EOL] case RANGE_WEEK_RELATIVE: [EOL] case RANGE_WEEK_CENTER: [EOL] start = truncate(focus, Calendar.DATE); [EOL] end = truncate(focus, Calendar.DATE); [EOL] switch(rangeStyle) { [EOL] case RANGE_WEEK_SUNDAY: [EOL] break; [EOL] case RANGE_WEEK_MONDAY: [EOL] startCutoff = Calendar.MONDAY; [EOL] endCutoff = Calendar.SUNDAY; [EOL] break; [EOL] case RANGE_WEEK_RELATIVE: [EOL] startCutoff = focus.get(Calendar.DAY_OF_WEEK); [EOL] endCutoff = startCutoff - 1; [EOL] break; [EOL] case RANGE_WEEK_CENTER: [EOL] startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3; [EOL] endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3; [EOL] break; [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The range style " + rangeStyle + " is not valid."); [EOL] } [EOL] if (startCutoff < Calendar.SUNDAY) { [EOL] startCutoff += 7; [EOL] } [EOL] if (startCutoff > Calendar.SATURDAY) { [EOL] startCutoff -= 7; [EOL] } [EOL] if (endCutoff < Calendar.SUNDAY) { [EOL] endCutoff += 7; [EOL] } [EOL] if (endCutoff > Calendar.SATURDAY) { [EOL] endCutoff -= 7; [EOL] } [EOL] while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) { [EOL] start.add(Calendar.DATE, -1); [EOL] } [EOL] while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) { [EOL] end.add(Calendar.DATE, 1); [EOL] } [EOL] return new DateIterator(start, end); [EOL] } public DateUtils();  DateIterator(final Calendar startFinal, final Calendar endFinal); public static boolean isSameDay(final Date date1, final Date date2); public static boolean isSameDay(final Calendar cal1, final Calendar cal2); public static boolean isSameInstant(final Date date1, final Date date2); public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; public static Date addYears(final Date date, final int amount); public static Date addMonths(final Date date, final int amount); public static Date addWeeks(final Date date, final int amount); public static Date addDays(final Date date, final int amount); public static Date addHours(final Date date, final int amount); public static Date addMinutes(final Date date, final int amount); public static Date addSeconds(final Date date, final int amount); public static Date addMilliseconds(final Date date, final int amount); private static Date add(final Date date, final int calendarField, final int amount); public static Date setYears(final Date date, final int amount); public static Date setMonths(final Date date, final int amount); public static Date setDays(final Date date, final int amount); public static Date setHours(final Date date, final int amount); public static Date setMinutes(final Date date, final int amount); public static Date setSeconds(final Date date, final int amount); public static Date setMilliseconds(final Date date, final int amount); private static Date set(final Date date, final int calendarField, final int amount); public static Calendar toCalendar(final Date date); public static Date round(final Date date, final int field); public static Calendar round(final Calendar date, final int field); public static Date round(final Object date, final int field); public static Date truncate(final Date date, final int field); public static Calendar truncate(final Calendar date, final int field); public static Date truncate(final Object date, final int field); public static Date ceiling(final Date date, final int field); public static Calendar ceiling(final Calendar date, final int field); public static Date ceiling(final Object date, final int field); private static void modify(final Calendar val, final int field, final int modType); public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); public static Iterator<?> iterator(final Object focus, final int rangeStyle); public static long getFragmentInMilliseconds(final Date date, final int fragment); public static long getFragmentInSeconds(final Date date, final int fragment); public static long getFragmentInMinutes(final Date date, final int fragment); public static long getFragmentInHours(final Date date, final int fragment); public static long getFragmentInDays(final Date date, final int fragment); public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); public static long getFragmentInSeconds(final Calendar calendar, final int fragment); public static long getFragmentInMinutes(final Calendar calendar, final int fragment); public static long getFragmentInHours(final Calendar calendar, final int fragment); public static long getFragmentInDays(final Calendar calendar, final int fragment); private static long getFragment(final Date date, final int fragment, final int unit); private static long getFragment(final Calendar calendar, final int fragment, final int unit); public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); public static boolean truncatedEquals(final Date date1, final Date date2, final int field); public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); public static int truncatedCompareTo(final Date date1, final Date date2, final int field); private static long getMillisPerUnit(final int unit); public boolean hasNext(); public Calendar next(); public void remove(); long MILLIS_PER_SECOND=Optional[1000]; long MILLIS_PER_MINUTE=Optional[60 * MILLIS_PER_SECOND]; long MILLIS_PER_HOUR=Optional[60 * MILLIS_PER_MINUTE]; long MILLIS_PER_DAY=Optional[24 * MILLIS_PER_HOUR]; int SEMI_MONTH=Optional[1001]; int[][] fields=Optional[{ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }]
public void testIteratorWithNullFocus() { [EOL] try { [EOL] DateUtils.iterator(null, DateUtils.RANGE_MONTH_SUNDAY); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testIteratorWithDateFocus() { [EOL] Date focus = new Date(); [EOL] Iterator<?> it = DateUtils.iterator(focus, DateUtils.RANGE_MONTH_SUNDAY); [EOL] assertNotNull("Iterator should not be null", it); [EOL] } [EOL] public void testIteratorWithCalendarFocus() { [EOL] Calendar focus = Calendar.getInstance(); [EOL] Iterator<?> it = DateUtils.iterator(focus, DateUtils.RANGE_MONTH_SUNDAY); [EOL] assertNotNull("Iterator should not be null", it); [EOL] } [EOL] public void testIteratorWithUnsupportedFocusType() { [EOL] try { [EOL] Object focus = new Object(); [EOL] DateUtils.iterator(focus, DateUtils.RANGE_MONTH_SUNDAY); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException cce) { [EOL] } [EOL] }
public void testGetFragmentInSecondsWithDate() { [EOL] final Date date = new Date(); [EOL] final int fragment = Calendar.HOUR_OF_DAY; [EOL] long result = DateUtils.getFragmentInSeconds(date, fragment); [EOL] }
public void testGetFragmentInSecondsWithInvalidFragment() { [EOL] final Date date = new Date(); [EOL] final int fragment = -1; // assuming -1 is an invalid fragment [EOL] try { [EOL] DateUtils.getFragmentInSeconds(date, fragment); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testGetFragmentInSecondsWithCalendarAndFragment() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] int fragment = Calendar.HOUR_OF_DAY; [EOL] long expected = calendar.get(Calendar.HOUR_OF_DAY) * 3600 [EOL] + calendar.get(Calendar.MINUTE) * 60 [EOL] + calendar.get(Calendar.SECOND); [EOL] long actual = DateUtils.getFragmentInSeconds(calendar, fragment); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetFragmentInSecondsWithCalendarAndInvalidFragment() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] int fragment = Calendar.YEAR; // Assuming YEAR is not a valid fragment for this method [EOL] try { [EOL] DateUtils.getFragmentInSeconds(calendar, fragment); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
private static long getFragment(final Date date, final int fragment, final int unit) { [EOL] if (date == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] return getFragment(calendar, fragment, unit); [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={{ [EOL] { Calendar.MILLISECOND }, [EOL] { Calendar.SECOND }, [EOL] { Calendar.MINUTE }, [EOL] { Calendar.HOUR_OF_DAY, Calendar.HOUR }, [EOL] { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, [EOL] { Calendar.MONTH, DateUtils.SEMI_MONTH }, [EOL] { Calendar.YEAR }, [EOL] { Calendar.ERA } [EOL] }}
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL] if (calendar == null) { [EOL] throw new IllegalArgumentException("The date must not be null"); [EOL] } [EOL] final long millisPerUnit = getMillisPerUnit(unit); [EOL] long result = 0; [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] case Calendar.MONTH: [EOL] result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL] break; [EOL] } [EOL] switch(fragment) { [EOL] case Calendar.YEAR: [EOL] case Calendar.MONTH: [EOL] case Calendar.DAY_OF_YEAR: [EOL] case Calendar.DATE: [EOL] result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL] case Calendar.HOUR_OF_DAY: [EOL] result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL] case Calendar.MINUTE: [EOL] result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL] case Calendar.SECOND: [EOL] result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL] break; [EOL] case Calendar.MILLISECOND: [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL] } [EOL] return result; [EOL] } [EOL] public DateUtils(); [EOL] DateIterator(final Calendar startFinal, final Calendar endFinal); [EOL] public static boolean isSameDay(final Date date1, final Date date2); [EOL] public static boolean isSameDay(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameInstant(final Date date1, final Date date2); [EOL] public static boolean isSameInstant(final Calendar cal1, final Calendar cal2); [EOL] public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2); [EOL] public static Date parseDate(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException; [EOL] public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException; [EOL] private static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException; [EOL] public static Date addYears(final Date date, final int amount); [EOL] public static Date addMonths(final Date date, final int amount); [EOL] public static Date addWeeks(final Date date, final int amount); [EOL] public static Date addDays(final Date date, final int amount); [EOL] public static Date addHours(final Date date, final int amount); [EOL] public static Date addMinutes(final Date date, final int amount); [EOL] public static Date addSeconds(final Date date, final int amount); [EOL] public static Date addMilliseconds(final Date date, final int amount); [EOL] private static Date add(final Date date, final int calendarField, final int amount); [EOL] public static Date setYears(final Date date, final int amount); [EOL] public static Date setMonths(final Date date, final int amount); [EOL] public static Date setDays(final Date date, final int amount); [EOL] public static Date setHours(final Date date, final int amount); [EOL] public static Date setMinutes(final Date date, final int amount); [EOL] public static Date setSeconds(final Date date, final int amount); [EOL] public static Date setMilliseconds(final Date date, final int amount); [EOL] private static Date set(final Date date, final int calendarField, final int amount); [EOL] public static Calendar toCalendar(final Date date); [EOL] public static Date round(final Date date, final int field); [EOL] public static Calendar round(final Calendar date, final int field); [EOL] public static Date round(final Object date, final int field); [EOL] public static Date truncate(final Date date, final int field); [EOL] public static Calendar truncate(final Calendar date, final int field); [EOL] public static Date truncate(final Object date, final int field); [EOL] public static Date ceiling(final Date date, final int field); [EOL] public static Calendar ceiling(final Calendar date, final int field); [EOL] public static Date ceiling(final Object date, final int field); [EOL] private static void modify(final Calendar val, final int field, final int modType); [EOL] public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle); [EOL] public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle); [EOL] public static Iterator<?> iterator(final Object focus, final int rangeStyle); [EOL] public static long getFragmentInMilliseconds(final Date date, final int fragment); [EOL] public static long getFragmentInSeconds(final Date date, final int fragment); [EOL] public static long getFragmentInMinutes(final Date date, final int fragment); [EOL] public static long getFragmentInHours(final Date date, final int fragment); [EOL] public static long getFragmentInDays(final Date date, final int fragment); [EOL] public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInSeconds(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInMinutes(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInHours(final Calendar calendar, final int fragment); [EOL] public static long getFragmentInDays(final Calendar calendar, final int fragment); [EOL] private static long getFragment(final Date date, final int fragment, final int unit); [EOL] private static long getFragment(final Calendar calendar, final int fragment, final int unit); [EOL] public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static boolean truncatedEquals(final Date date1, final Date date2, final int field); [EOL] public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field); [EOL] public static int truncatedCompareTo(final Date date1, final Date date2, final int field); [EOL] private static long getMillisPerUnit(final int unit); [EOL] public boolean hasNext(); [EOL] public Calendar next(); [EOL] public void remove(); [EOL] long MILLIS_PER_SECOND=1000; [EOL] long MILLIS_PER_MINUTE=60 * MILLIS_PER_SECOND; [EOL] long MILLIS_PER_HOUR=60 * MILLIS_PER_MINUTE; [EOL] long MILLIS_PER_DAY=24 * MILLIS_PER_HOUR; [EOL] int SEMI_MONTH=1001; [EOL] int[][] fields={ { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM }, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } }
public void testGetMillisPerUnitWithDayOfYear() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.DAY_OF_YEAR); [EOL] assertEquals(DateUtils.MILLIS_PER_DAY, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithDate() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.DATE); [EOL] assertEquals(DateUtils.MILLIS_PER_DAY, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithHourOfDay() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.HOUR_OF_DAY); [EOL] assertEquals(DateUtils.MILLIS_PER_HOUR, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithMinute() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.MINUTE); [EOL] assertEquals(DateUtils.MILLIS_PER_MINUTE, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithSecond() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.SECOND); [EOL] assertEquals(DateUtils.MILLIS_PER_SECOND, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithMillisecond() { [EOL] long millis = DateUtils.getMillisPerUnit(Calendar.MILLISECOND); [EOL] assertEquals(1, millis); [EOL] } [EOL] public void testGetMillisPerUnitWithInvalidUnit() { [EOL] try { [EOL] DateUtils.getMillisPerUnit(Calendar.YEAR); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testCapitalize_NullInput() { [EOL] String result = StringUtils.capitalize(null); [EOL] assertNull(result); [EOL] }
public void testCapitalize_EmptyString() { [EOL] String result = StringUtils.capitalize(""); [EOL] assertEquals("", result); [EOL] }
public void testCapitalize_SingleCharString() { [EOL] String result = StringUtils.capitalize("a"); [EOL] assertEquals("A", result); [EOL] }
public void testCapitalize_MultiCharString() { [EOL] String result = StringUtils.capitalize("test"); [EOL] assertEquals("Test", result); [EOL] }
public void testCapitalize_NullString() { [EOL] String capitalized = StringUtils.capitalize(null); [EOL] assertNull("capitalize(null) should return null", capitalized); [EOL] } [EOL] public void testCapitalize_EmptyString() { [EOL] String capitalized = StringUtils.capitalize(""); [EOL] assertEquals("capitalize(\"\") should return \"\"", "", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithNoDelimiters() { [EOL] String capitalized = StringUtils.capitalize("cat"); [EOL] assertEquals("capitalize(\"cat\") should return \"Cat\"", "Cat", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimiters() { [EOL] String capitalized = StringUtils.capitalize("cat and dog", ' ', 'a'); [EOL] assertEquals("capitalize(\"cat and dog\", ' ', 'a') should return \"Cat And Dog\"", "Cat And Dog", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimitersAtStart() { [EOL] String capitalized = StringUtils.capitalize(" cat", ' '); [EOL] assertEquals("capitalize(\" cat\", ' ') should return \" Cat\"", " Cat", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithNoNeedToCapitalize() { [EOL] String capitalized = StringUtils.capitalize("Cat"); [EOL] assertEquals("capitalize(\"Cat\") should return \"Cat\"", "Cat", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimitersOnly() { [EOL] String capitalized = StringUtils.capitalize(" ", ' '); [EOL] assertEquals("capitalize(\" \", ' ') should return \" \"", " ", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDifferentCaseDelimiters() { [EOL] String capitalized = StringUtils.capitalize("cat-and-dog", '-', 'A'); [EOL] assertEquals("capitalize(\"cat-and-dog\", '-', 'A') should return \"Cat-And-Dog\"", "Cat-And-Dog", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithDelimitersArray() { [EOL] char[] delimiters = new char[]{' ', '-'}; [EOL] String capitalized = StringUtils.capitalize("cat and-dog", delimiters); [EOL] assertEquals("capitalize(\"cat and-dog\", delimiters) should return \"Cat And-Dog\"", "Cat And-Dog", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithNullDelimiters() { [EOL] String capitalized = StringUtils.capitalize("cat", (char[]) null); [EOL] assertEquals("capitalize(\"cat\", (char[]) null) should return \"Cat\"", "Cat", capitalized); [EOL] } [EOL] public void testCapitalize_StringWithEmptyDelimiters() { [EOL] String capitalized = StringUtils.capitalize("cat", new char[]{}); [EOL] assertEquals("capitalize(\"cat\", new char[]{}) should return \"Cat\"", "Cat", capitalized); [EOL] }
public void testInitialsWithNull() { [EOL] String result = StringUtils.initials(null); [EOL] assertNull(result); [EOL] }
public void testInitialsWithEmptyString() { [EOL] String result = StringUtils.initials(""); [EOL] assertEquals("", result); [EOL] }
public void testInitialsWithNonEmptyString() { [EOL] String result = StringUtils.initials("John Doe"); [EOL] assertEquals("JD", result); [EOL] }
public void testInitials_emptyString() { [EOL] String result = StringUtils.initials(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testInitials_nullString() { [EOL] String result = StringUtils.initials(null); [EOL] assertNull(result); [EOL] } [EOL] public void testInitials_noDelimiters() { [EOL] String result = StringUtils.initials("John Doe"); [EOL] assertEquals("JD", result); [EOL] } [EOL] public void testInitials_emptyDelimiters() { [EOL] String result = StringUtils.initials("John Doe", new char[]{}); [EOL] assertEquals("", result); [EOL] } [EOL] public void testInitials_withDelimiters() { [EOL] String result = StringUtils.initials("John Doe", new char[]{' '}); [EOL] assertEquals("JD", result); [EOL] } [EOL] public void testInitials_withMultipleDelimiters() { [EOL] String result = StringUtils.initials("John Doe-Foe", new char[]{' ', '-'}); [EOL] assertEquals("JDF", result); [EOL] } [EOL] public void testInitials_withNoDelimiterMatch() { [EOL] String result = StringUtils.initials("JohnDoe", new char[]{' ', '-'}); [EOL] assertEquals("J", result); [EOL] } [EOL] public void testInitials_withDelimiterAtEnd() { [EOL] String result = StringUtils.initials("John Doe ", new char[]{' '}); [EOL] assertEquals("JD", result); [EOL] }
public void testAddInitializerWithNullName() { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<?> initializer = new BackgroundInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() throws Exception { [EOL] return null; [EOL] } [EOL] }; [EOL] try { [EOL] multiBackgroundInitializer.addInitializer(null, initializer); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testAddInitializerWithNullInitializer() { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] try { [EOL] multiBackgroundInitializer.addInitializer("test", null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testAddInitializerAfterStart() { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<?> initializer = new BackgroundInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() throws Exception { [EOL] return null; [EOL] } [EOL] }; [EOL] multiBackgroundInitializer.start(); [EOL] try { [EOL] multiBackgroundInitializer.addInitializer("test", initializer); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException ex) { [EOL] } [EOL] }
public void testAddInitializerSuccess() { [EOL] MultiBackgroundInitializer multiBackgroundInitializer = new MultiBackgroundInitializer(); [EOL] BackgroundInitializer<?> initializer = new BackgroundInitializer<Object>() { [EOL] @Override [EOL] protected Object initialize() throws Exception { [EOL] return null; [EOL] } [EOL] }; [EOL] multiBackgroundInitializer.addInitializer("test", initializer); [EOL] assertTrue(multiBackgroundInitializer.getTaskCount() > 0); [EOL] }
public void testToLocaleWithNullInput() { [EOL] Locale result = toLocale(null); [EOL] assertNull(result); [EOL] }
public void testToLocaleWithInvalidFormatContainingHash() { [EOL] try { [EOL] toLocale("en#US"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en#US", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithInvalidFormatShortLength() { [EOL] try { [EOL] toLocale("e"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: e", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreAndInvalidCountry() { [EOL] try { [EOL] toLocale("_E"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: _E", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreAndValidCountry() { [EOL] Locale result = toLocale("_US"); [EOL] assertEquals(new Locale("", "US"), result); [EOL] }
public void testToLocaleWithUnderscoreCountryAndInvalidVariant() { [EOL] try { [EOL] toLocale("_US_"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: _US_", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithUnderscoreCountryAndValidVariant() { [EOL] Locale result = toLocale("_US_variant"); [EOL] assertEquals(new Locale("", "US", "variant"), result); [EOL] }
public void testToLocaleWithInvalidLanguage() { [EOL] try { [EOL] toLocale("E_"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: E_", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithValidLanguage() { [EOL] Locale result = toLocale("en"); [EOL] assertEquals(new Locale("en"), result); [EOL] }
public void testToLocaleWithLanguageAndInvalidCountry() { [EOL] try { [EOL] toLocale("en_U"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en_U", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithLanguageCountryAndInvalidVariant() { [EOL] try { [EOL] toLocale("en_US_"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid locale format: en_US_", e.getMessage()); [EOL] } [EOL] }
public void testToLocaleWithValidLanguageCountryAndVariant() { [EOL] Locale result = toLocale("en_US_variant"); [EOL] assertEquals(new Locale("en", "US", "variant"), result); [EOL] }
public void testLocaleLookupListWithNullLocale() { [EOL] List<Locale> result = LocaleUtils.localeLookupList(null); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testLocaleLookupListWithNonNullLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(locale); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(locale, result.get(0)); [EOL] }
public void testLocaleLookupListWithNonNullLocaleAndDefaultLocale() { [EOL] Locale locale = new Locale("en", "US", "WIN"); [EOL] Locale defaultLocale = new Locale("en", "GB"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(locale, defaultLocale); [EOL] assertEquals(4, result.size()); [EOL] assertTrue(result.contains(new Locale("en", "US", "WIN"))); [EOL] assertTrue(result.contains(new Locale("en", "US"))); [EOL] assertTrue(result.contains(new Locale("en", ""))); [EOL] assertTrue(result.contains(defaultLocale)); [EOL] }
public void testLocaleLookupListWithNonNullLocaleAndNullDefaultLocale() { [EOL] Locale locale = new Locale("en", "US", "WIN"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(locale, null); [EOL] assertEquals(3, result.size()); [EOL] assertTrue(result.contains(new Locale("en", "US", "WIN"))); [EOL] assertTrue(result.contains(new Locale("en", "US"))); [EOL] assertTrue(result.contains(new Locale("en", ""))); [EOL] }
public void testLocaleLookupListWithNullLocale() { [EOL] Locale defaultLocale = new Locale("en", "GB"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(null, defaultLocale); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains(defaultLocale)); [EOL] }
public void testLocaleLookupListWithLocaleHavingNoCountryAndVariant() { [EOL] Locale locale = new Locale("en"); [EOL] Locale defaultLocale = new Locale("fr"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(locale, defaultLocale); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains(locale)); [EOL] assertTrue(result.contains(defaultLocale)); [EOL] }
public void testLocaleLookupListWithLocaleHavingNoVariant() { [EOL] Locale locale = new Locale("en", "US"); [EOL] Locale defaultLocale = new Locale("en", "GB"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(locale, defaultLocale); [EOL] assertEquals(3, result.size()); [EOL] assertTrue(result.contains(new Locale("en", "US"))); [EOL] assertTrue(result.contains(new Locale("en", ""))); [EOL] assertTrue(result.contains(defaultLocale)); [EOL] }
public void testLocaleLookupListWithLocaleEqualsDefaultLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] List<Locale> result = LocaleUtils.localeLookupList(locale, locale); [EOL] assertEquals(2, result.size()); [EOL] assertTrue(result.contains(new Locale("en", "US"))); [EOL] assertTrue(result.contains(new Locale("en", ""))); [EOL] }
It appears that the provided input text is the constructor for a utility class, likely meant to be used statically and not instantiated. Since constructors for utility classes are often made private to prevent instantiation, and the body of the constructor only calls `super()`, which is a default behavior for any constructor that doesn't explicitly call a superclass constructor, there is no meaningful behavior to test here. [EOL] In Java, constructors for utility classes are typically private and include a comment or throw an exception to prevent instantiation. However, if this constructor is indeed meant to be public and testable, there would be no meaningful assertions to make for a constructor that only calls `super()`, as it does not change any state or have any side effects. [EOL] If the goal is to ensure that the constructor cannot be called (as is common with utility classes), you would write a test to assert that the constructor is private. However, since the constructor in the provided input is public, there is no need for such a test. [EOL] Therefore, no test cases are generated for this input. If the constructor were private and you wanted to enforce that it cannot be instantiated, you would use reflection to access the constructor and assert that an `IllegalAccessException` is thrown. But again, this does not apply to the provided public constructor.
public void testToString_NullArray() { [EOL] String result = StringUtils.toString(null); [EOL] assertEquals("{}", result); [EOL] }
public void testToString_EmptyArray() { [EOL] String[] emptyArray = new String[0]; [EOL] String result = StringUtils.toString(emptyArray); [EOL] assertEquals("{}", result); [EOL] }
public void testToString_NonEmptyArray() { [EOL] String[] array = new String[]{"element1", "element2"}; [EOL] String result = StringUtils.toString(array); [EOL] assertEquals("{element1, element2}", result); [EOL] }
public void testToString_NullArray() { [EOL] String result = StringUtils.toString(null, "NULL"); [EOL] assertEquals("NULL", result); [EOL] }
public void testToString_NonNullArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] String result = StringUtils.toString(array, "NULL"); [EOL] assertTrue(result.startsWith("[1,2,3]")); [EOL] }
public void testClone_NullArray() { [EOL] int[] array = null; [EOL] int[] clonedArray = clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] int[] array = {}; [EOL] int[] clonedArray = clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] int[] array = {1, 2, 3}; [EOL] int[] clonedArray = clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testClone_NullArray() { [EOL] short[] array = null; [EOL] short[] clonedArray = ArrayUtils.clone(array); [EOL] assertNull(clonedArray); [EOL] }
public void testClone_EmptyArray() { [EOL] short[] array = new short[0]; [EOL] short[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertEquals(0, clonedArray.length); [EOL] }
public void testClone_NonEmptyArray() { [EOL] short[] array = {1, 2, 3}; [EOL] short[] clonedArray = ArrayUtils.clone(array); [EOL] assertNotNull(clonedArray); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] long[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] long[] emptyArray = new long[0]; [EOL] long[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] long[] nonEmptyArray = new long[] {1, 2, 3}; [EOL] long[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] char[] result = nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] char[] emptyArray = new char[0]; [EOL] char[] result = nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] char[] nonEmptyArray = new char[]{'a', 'b', 'c'}; [EOL] char[] result = nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] boolean[] result = nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] boolean[] emptyArray = new boolean[0]; [EOL] boolean[] result = nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] boolean[] nonEmptyArray = new boolean[] {true, false, true}; [EOL] boolean[] result = nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] Long[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Long[] emptyArray = new Long[0]; [EOL] Long[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Long[] nonEmptyArray = new Long[] {1L, 2L, 3L}; [EOL] Long[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] Short[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] } [EOL] public void testNullToEmptyWithEmptyInput() { [EOL] Short[] emptyArray = new Short[0]; [EOL] Short[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] } [EOL] public void testNullToEmptyWithNonEmptyInput() { [EOL] Short[] nonEmptyArray = new Short[] {1, 2, 3}; [EOL] Short[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullInput() { [EOL] Byte[] result = nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Byte[] emptyArray = new Byte[0]; [EOL] Byte[] result = nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Byte[] nonEmptyArray = new Byte[] {1, 2, 3}; [EOL] Byte[] result = nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testNullToEmptyWithNullArray() { [EOL] Float[] result = ArrayUtils.nullToEmpty(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testNullToEmptyWithEmptyArray() { [EOL] Float[] emptyArray = new Float[0]; [EOL] Float[] result = ArrayUtils.nullToEmpty(emptyArray); [EOL] assertSame(emptyArray, result); [EOL] }
public void testNullToEmptyWithNonEmptyArray() { [EOL] Float[] nonEmptyArray = new Float[] {1.0f, 2.0f, 3.0f}; [EOL] Float[] result = ArrayUtils.nullToEmpty(nonEmptyArray); [EOL] assertSame(nonEmptyArray, result); [EOL] }
public void testSubarray_NullArray() { [EOL] short[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_NegativeStartIndex() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, -1, 3); [EOL] assertArrayEquals(new short[]{1, 2, 3}, result); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, 1, 10); [EOL] assertArrayEquals(new short[]{2, 3, 4, 5}, result); [EOL] } [EOL] public void testSubarray_ZeroLengthResult() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, 3, 3); [EOL] assertArrayEquals(new short[]{}, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new short[]{2, 3, 4}, result); [EOL] }
public void testSubarray_StartIndexGreaterThanEndIndex() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, 4, 2); [EOL] assertArrayEquals(new short[]{}, result); [EOL] } [EOL] public void testSubarray_StartIndexEqualToArrayLength() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, 5, 6); [EOL] assertArrayEquals(new short[]{}, result); [EOL] } [EOL] public void testSubarray_EndIndexEqualToArrayLength() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] short[] result = ArrayUtils.subarray(array, 2, 5); [EOL] assertArrayEquals(new short[]{3, 4, 5}, result); [EOL] }
public void testSubarray_NullArray() { [EOL] float[] result = ArrayUtils.subarray(null, 0, 1); [EOL] assertNull(result); [EOL] } [EOL] public void testSubarray_NegativeStartIndex() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.subarray(array, -1, 2); [EOL] assertArrayEquals(new float[]{1.0f, 2.0f}, result); [EOL] } [EOL] public void testSubarray_EndIndexGreaterThanLength() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.subarray(array, 1, 5); [EOL] assertArrayEquals(new float[]{2.0f, 3.0f}, result); [EOL] } [EOL] public void testSubarray_ZeroNewSize() { [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.subarray(array, 2, 2); [EOL] assertArrayEquals(new float[]{}, result); [EOL] } [EOL] public void testSubarray_ValidSubarray() { [EOL] float[] array = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] float[] result = ArrayUtils.subarray(array, 1, 4); [EOL] assertArrayEquals(new float[]{2.0f, 3.0f, 4.0f}, result); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] Object[] array1 = null; [EOL] Object[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] Object[] array1 = null; [EOL] Object[] array2 = new Object[1]; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_SecondArrayNullFirstArrayNotEmpty() { [EOL] Object[] array1 = new Object[1]; [EOL] Object[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_ArraysDifferentLength() { [EOL] Object[] array1 = new Object[1]; [EOL] Object[] array2 = new Object[2]; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_ArraysSameLength() { [EOL] Object[] array1 = new Object[1]; [EOL] Object[] array2 = new Object[1]; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testIsSameLength_BothArraysNull() { [EOL] short[] array1 = null; [EOL] short[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testIsSameLength_FirstArrayNullSecondArrayNotEmpty() { [EOL] short[] array1 = null; [EOL] short[] array2 = new short[]{1, 2, 3}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_SecondArrayNullFirstArrayNotEmpty() { [EOL] short[] array1 = new short[]{1, 2, 3}; [EOL] short[] array2 = null; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_ArraysDifferentLengths() { [EOL] short[] array1 = new short[]{1, 2, 3}; [EOL] short[] array2 = new short[]{1, 2}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertFalse(result); [EOL] }
public void testIsSameLength_ArraysSameLength() { [EOL] short[] array1 = new short[]{1, 2, 3}; [EOL] short[] array2 = new short[]{4, 5, 6}; [EOL] boolean result = ArrayUtils.isSameLength(array1, array2); [EOL] assertTrue(result); [EOL] }
public void testReverse_NullArray() { [EOL] long[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "The array should remain null after reverse operation"); [EOL] }
public void testReverse_EmptyArray() { [EOL] long[] array = {}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new long[]{}, array, "Empty array should not change after reverse operation"); [EOL] }
public void testReverse_SingleElementArray() { [EOL] long[] array = {1L}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new long[]{1L}, array, "Single element array should not change after reverse operation"); [EOL] }
public void testReverse_MultipleElementsArray() { [EOL] long[] array = {1L, 2L, 3L}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(new long[]{3L, 2L, 1L}, array, "Array should be reversed"); [EOL] }
public void testReverse_NullArray() { [EOL] boolean[] array = null; [EOL] ArrayUtils.reverse(array); [EOL] assertNull(array, "Array should remain null after reverse operation"); [EOL] }
public void testReverse_EmptyArray() { [EOL] boolean[] array = new boolean[0]; [EOL] ArrayUtils.reverse(array); [EOL] assertEquals(0, array.length, "Empty array should remain unchanged after reverse operation"); [EOL] }
public void testReverse_NonEmptyArray() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean[] expectedArray = {true, false, true}; [EOL] ArrayUtils.reverse(array); [EOL] assertArrayEquals(expectedArray, array, "Array should be reversed correctly"); [EOL] }
public void testIndexOf_NullArray() { [EOL] final int[] array = null; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_StartIndexNegative() { [EOL] final int[] array = {1, 2, 3, 4, 5}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = -1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] final int[] array = {1, 2, 3, 4, 5}; [EOL] final int valueToFind = 6; [EOL] final int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueFound() { [EOL] final int[] array = {1, 2, 3, 4, 5}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ValueFoundAfterStartIndex() { [EOL] final int[] array = {1, 2, 3, 4, 5}; [EOL] final int valueToFind = 3; [EOL] final int startIndex = 1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ShouldReturnNegativeOne_WhenArrayIsNull() { [EOL] int result = ArrayUtils.indexOf(null, (short) 1); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ShouldReturnNegativeOne_WhenArrayIsEmpty() { [EOL] int result = ArrayUtils.indexOf(new short[0], (short) 1); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_ShouldReturnIndex_WhenValueToFindExists() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] int result = ArrayUtils.indexOf(array, (short) 3); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ShouldReturnNegativeOne_WhenValueToFindDoesNotExist() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] int result = ArrayUtils.indexOf(array, (short) 6); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NullArray() { [EOL] final short[] array = null; [EOL] final short valueToFind = 0; [EOL] final int startIndex = 0; [EOL] final int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_StartIndexNegative() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 1; [EOL] final int startIndex = -1; [EOL] final int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 6; [EOL] final int startIndex = 0; [EOL] final int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueFound() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 3; [EOL] final int startIndex = 0; [EOL] final int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ValueFoundAfterStartIndex() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 3; [EOL] final int startIndex = 2; [EOL] final int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_StartIndexEqualsArrayLength() { [EOL] final short[] array = new short[] {1, 2, 3, 4, 5}; [EOL] final short valueToFind = 1; [EOL] final int startIndex = array.length; [EOL] final int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ArrayWithElement() { [EOL] final char[] array = {'a', 'b', 'c', 'd'}; [EOL] final char valueToFind = 'b'; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_ArrayWithoutElement() { [EOL] final char[] array = {'a', 'b', 'c', 'd'}; [EOL] final char valueToFind = 'e'; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NullArray() { [EOL] final char[] array = null; [EOL] final char valueToFind = 'a'; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final char[] array = {'a', 'b', 'c', 'd'}; [EOL] final char valueToFind = 'a'; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanArrayLength() { [EOL] final char[] array = {'a', 'b', 'c', 'd'}; [EOL] final char valueToFind = 'a'; [EOL] int startIndex = 5; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(-1, result); [EOL] }
public void testLastIndexOf_CharArrayChar() { [EOL] final char[] array = {'a', 'b', 'c', 'd', 'a', 'b'}; [EOL] int index = ArrayUtils.lastIndexOf(array, 'a'); [EOL] assertEquals(4, index); [EOL] }
public void testLastIndexOf_CharArrayCharNotFound() { [EOL] final char[] array = {'a', 'b', 'c', 'd', 'e', 'f'}; [EOL] int index = ArrayUtils.lastIndexOf(array, 'g'); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_CharArrayCharEmpty() { [EOL] final char[] array = new char[0]; [EOL] int index = ArrayUtils.lastIndexOf(array, 'a'); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_CharArrayCharNull() { [EOL] final char[] array = null; [EOL] int index = ArrayUtils.lastIndexOf(array, 'a'); [EOL] assertEquals(-1, index); [EOL] }
public void testLastIndexOf_nullArray() { [EOL] final int result = ArrayUtils.lastIndexOf(null, 'a', 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_negativeStartIndex() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ArrayUtils.lastIndexOf(array, 'a', -1); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_startIndexGreaterThanLength() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ArrayUtils.lastIndexOf(array, 'a', 4); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testLastIndexOf_charNotFound() { [EOL] final char[] array = {'a', 'b', 'c'}; [EOL] final int result = ArrayUtils.lastIndexOf(array, 'd', 2); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_charFound() { [EOL] final char[] array = {'a', 'b', 'a', 'c'}; [EOL] final int result = ArrayUtils.lastIndexOf(array, 'a', 3); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOf_ByteArray() { [EOL] byte[] array = {1, 2, 3, 4, 5}; [EOL] int index = ArrayUtils.indexOf(array, (byte) 3); [EOL] assertEquals(2, index); [EOL] }
public void testIndexOf_ByteArrayNotFound() { [EOL] byte[] array = {1, 2, 3, 4, 5}; [EOL] int index = ArrayUtils.indexOf(array, (byte) 6); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_ByteArrayWithNull() { [EOL] byte[] array = null; [EOL] int index = ArrayUtils.indexOf(array, (byte) 1); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_NullArray() { [EOL] final byte[] array = null; [EOL] final byte valueToFind = 0x00; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_NegativeStartIndex() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x02; [EOL] int startIndex = -1; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_StartIndexGreaterThanLength() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x02; [EOL] int startIndex = 4; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueNotFound() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x04; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOf_ValueFound() { [EOL] final byte[] array = new byte[] {0x01, 0x02, 0x03}; [EOL] final byte valueToFind = 0x02; [EOL] int startIndex = 0; [EOL] int result = ArrayUtils.indexOf(array, valueToFind, startIndex); [EOL] assertEquals(1, result); [EOL] }
public void testIndexOf_booleanArray_booleanValue() { [EOL] final boolean[] array = {true, false, true, false, true}; [EOL] int index = ArrayUtils.indexOf(array, true); [EOL] assertEquals(0, index); [EOL] index = ArrayUtils.indexOf(array, false); [EOL] assertEquals(1, index); [EOL] }
public void testIndexOf_booleanArray_booleanValueNotFound() { [EOL] final boolean[] array = {true, true, true}; [EOL] int index = ArrayUtils.indexOf(array, false); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_booleanArray_booleanValueWithEmptyArray() { [EOL] final boolean[] array = {}; [EOL] int index = ArrayUtils.indexOf(array, true); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_booleanArray_booleanValueWithNullArray() { [EOL] int index = ArrayUtils.indexOf(null, true); [EOL] assertEquals(-1, index); [EOL] }
public void testIndexOf_ArrayIsEmpty() { [EOL] boolean[] array = {}; [EOL] int index = ArrayUtils.indexOf(array, true, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_StartIndexIsNegative() { [EOL] boolean[] array = {false, false, true, false, true}; [EOL] int index = ArrayUtils.indexOf(array, true, -1); [EOL] assertEquals(2, index); [EOL] }
public void testIndexOf_ValueToFindIsPresent() { [EOL] boolean[] array = {false, false, true, false, true}; [EOL] int index = ArrayUtils.indexOf(array, true, 0); [EOL] assertEquals(2, index); [EOL] }
public void testIndexOf_ValueToFindIsNotPresent() { [EOL] boolean[] array = {false, false, false, false}; [EOL] int index = ArrayUtils.indexOf(array, true, 0); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testIndexOf_ValueToFindIsPresentButAfterStartIndex() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.indexOf(array, true, 3); [EOL] assertEquals(3, index); [EOL] }
public void testIndexOf_StartIndexEqualsArrayLength() { [EOL] boolean[] array = {false, true, false, true, false}; [EOL] int index = ArrayUtils.indexOf(array, true, array.length); [EOL] assertEquals(ArrayUtils.INDEX_NOT_FOUND, index); [EOL] }
public void testContains_WithEmptyArray() { [EOL] boolean[] array = {}; [EOL] boolean valueToFind = true; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testContains_WithNonEmptyArray_ValuePresent() { [EOL] boolean[] array = {false, true, false}; [EOL] boolean valueToFind = true; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertTrue(result); [EOL] }
public void testContains_WithNonEmptyArray_ValueNotPresent() { [EOL] boolean[] array = {false, false, false}; [EOL] boolean valueToFind = true; [EOL] boolean result = ArrayUtils.contains(array, valueToFind); [EOL] assertFalse(result); [EOL] }
public void testToObjectWithNullArray() { [EOL] Long[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObjectWithEmptyArray() { [EOL] long[] array = {}; [EOL] Long[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObjectWithNonEmptyArray() { [EOL] long[] array = {1, 2, 3}; [EOL] Long[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(Long.valueOf(array[i]), result[i]); [EOL] } [EOL] }
public void testToObjectWithNullArray() { [EOL] Integer[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObjectWithEmptyArray() { [EOL] int[] array = {}; [EOL] Integer[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObjectWithNonEmptyArray() { [EOL] int[] array = {1, 2, 3}; [EOL] Integer[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(Integer.valueOf(array[i]), result[i]); [EOL] } [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] short[] result = ArrayUtils.toPrimitive(null, (short) 0); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Short[] emptyArray = new Short[0]; [EOL] short[] result = ArrayUtils.toPrimitive(emptyArray, (short) 0); [EOL] assertArrayEquals(ArrayUtils.EMPTY_SHORT_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullElements() { [EOL] Short[] arrayWithElements = new Short[]{1, 2, 3}; [EOL] short valueForNull = (short) 0; [EOL] short[] result = ArrayUtils.toPrimitive(arrayWithElements, valueForNull); [EOL] short[] expected = new short[]{1, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullElements() { [EOL] Short[] arrayWithNulls = new Short[]{null, null, null}; [EOL] short valueForNull = (short) 1; [EOL] short[] result = ArrayUtils.toPrimitive(arrayWithNulls, valueForNull); [EOL] short[] expected = new short[]{1, 1, 1}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedElements() { [EOL] Short[] mixedArray = new Short[]{1, null, 3}; [EOL] short valueForNull = (short) 2; [EOL] short[] result = ArrayUtils.toPrimitive(mixedArray, valueForNull); [EOL] short[] expected = new short[]{1, 2, 3}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToObject_NullArray() { [EOL] Short[] result = ArrayUtils.toObject(null); [EOL] assertNull(result); [EOL] }
public void testToObject_EmptyArray() { [EOL] short[] array = {}; [EOL] Short[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testToObject_NonEmptyArray() { [EOL] short[] array = {1, 2, 3}; [EOL] Short[] result = ArrayUtils.toObject(array); [EOL] assertNotNull(result); [EOL] assertEquals(array.length, result.length); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(Short.valueOf(array[i]), result[i]); [EOL] } [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Double[] array = null; [EOL] double[] result = ArrayUtils.toPrimitive(array); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyInput() { [EOL] Double[] array = new Double[0]; [EOL] double[] result = ArrayUtils.toPrimitive(array); [EOL] assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, result); [EOL] }
public void testToPrimitiveWithValidInput() { [EOL] Double[] array = new Double[] {1.0, 2.0, 3.0}; [EOL] double[] result = ArrayUtils.toPrimitive(array); [EOL] double[] expected = new double[] {1.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullInput() { [EOL] Float[] array = null; [EOL] float[] result = ArrayUtils.toPrimitive(array); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyInput() { [EOL] Float[] array = new Float[0]; [EOL] float[] result = ArrayUtils.toPrimitive(array); [EOL] assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, result); [EOL] }
public void testToPrimitiveWithValidInput() { [EOL] Float[] array = new Float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.toPrimitive(array); [EOL] float[] expected = new float[] {1.0f, 2.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullArray() { [EOL] float[] result = ArrayUtils.toPrimitive(null, 0.0f); [EOL] assertNull(result); [EOL] }
public void testToPrimitiveWithEmptyArray() { [EOL] Float[] emptyArray = new Float[0]; [EOL] float[] result = ArrayUtils.toPrimitive(emptyArray, 0.0f); [EOL] assertArrayEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, result); [EOL] }
public void testToPrimitiveWithNonNullElements() { [EOL] Float[] arrayWithElements = new Float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.toPrimitive(arrayWithElements, 0.0f); [EOL] float[] expected = new float[] {1.0f, 2.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithNullElements() { [EOL] Float[] arrayWithNulls = new Float[] {null, null, null}; [EOL] float valueForNull = 0.0f; [EOL] float[] result = ArrayUtils.toPrimitive(arrayWithNulls, valueForNull); [EOL] float[] expected = new float[] {valueForNull, valueForNull, valueForNull}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testToPrimitiveWithMixedElements() { [EOL] Float[] mixedArray = new Float[] {1.0f, null, 3.0f}; [EOL] float valueForNull = 2.0f; [EOL] float[] result = ArrayUtils.toPrimitive(mixedArray, valueForNull); [EOL] float[] expected = new float[] {1.0f, valueForNull, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testIsEmpty_NullArray() { [EOL] assertTrue(ArrayUtils.isEmpty(null)); [EOL] }
public void testIsEmpty_EmptyArray() { [EOL] assertTrue(ArrayUtils.isEmpty(new long[] {})); [EOL] }
public void testIsEmpty_NonEmptyArray() { [EOL] assertFalse(ArrayUtils.isEmpty(new long[] {1, 2, 3})); [EOL] }
public void testIsEmpty_NullArray() { [EOL] int[] array = null; [EOL] boolean result = ArrayUtils.isEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsEmpty_EmptyArray() { [EOL] int[] array = new int[0]; [EOL] boolean result = ArrayUtils.isEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testIsEmpty_NonEmptyArray() { [EOL] int[] array = new int[]{1, 2, 3}; [EOL] boolean result = ArrayUtils.isEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsEmpty_NullArray() { [EOL] assertTrue(ArrayUtils.isEmpty(null)); [EOL] }
public void testIsEmpty_EmptyArray() { [EOL] assertTrue(ArrayUtils.isEmpty(new short[0])); [EOL] }
public void testIsEmpty_NonEmptyArray() { [EOL] assertFalse(ArrayUtils.isEmpty(new short[]{1, 2, 3})); [EOL] }
public void testIsEmptyWithNullArray() { [EOL] assertTrue(StringUtils.isEmpty(null)); [EOL] }
public void testIsEmptyWithEmptyArray() { [EOL] assertTrue(StringUtils.isEmpty(new char[] {})); [EOL] }
public void testIsEmptyWithNonEmptyArray() { [EOL] assertFalse(StringUtils.isEmpty(new char[] {'a', 'b', 'c'})); [EOL] }
public void testIsEmpty_WithNullArray() { [EOL] byte[] array = null; [EOL] boolean result = ArrayUtils.isEmpty(array); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsEmpty_WithEmptyArray() { [EOL] byte[] array = new byte[0]; [EOL] boolean result = ArrayUtils.isEmpty(array); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsEmpty_WithNonEmptyArray() { [EOL] byte[] array = new byte[1]; [EOL] boolean result = ArrayUtils.isEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsEmpty_NullArray() { [EOL] assertTrue(ArrayUtils.isEmpty(null)); [EOL] }
public void testIsEmpty_EmptyArray() { [EOL] assertTrue(ArrayUtils.isEmpty(new float[] {})); [EOL] }
public void testIsEmpty_NonEmptyArray() { [EOL] assertFalse(ArrayUtils.isEmpty(new float[] {1.0f, 2.0f})); [EOL] }
public void testIsEmpty_WithNullArray() { [EOL] boolean[] array = null; [EOL] assertTrue(ArrayUtils.isEmpty(array)); [EOL] }
public void testIsEmpty_WithEmptyArray() { [EOL] boolean[] array = new boolean[0]; [EOL] assertTrue(ArrayUtils.isEmpty(array)); [EOL] }
public void testIsEmpty_WithNonEmptyArray() { [EOL] boolean[] array = new boolean[1]; [EOL] assertFalse(ArrayUtils.isEmpty(array)); [EOL] }
public void testIsNotEmpty_NullArray() { [EOL] boolean result = ArrayUtils.isNotEmpty(null); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_EmptyArray() { [EOL] int[] array = new int[0]; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertFalse(result); [EOL] }
public void testIsNotEmpty_NonEmptyArray() { [EOL] int[] array = new int[]{1, 2, 3}; [EOL] boolean result = ArrayUtils.isNotEmpty(array); [EOL] assertTrue(result); [EOL] }
public void testAddArrayAndElementBothNotNull() { [EOL] Integer[] originalArray = new Integer[]{1, 2, 3}; [EOL] Integer elementToAdd = 4; [EOL] Integer[] newArray = ArrayUtils.add(originalArray, elementToAdd); [EOL] assertNotNull(newArray); [EOL] assertEquals(4, newArray.length); [EOL] assertEquals(Integer.valueOf(4), newArray[3]); [EOL] } [EOL] public void testAddArrayNotNullElementNull() { [EOL] Integer[] originalArray = new Integer[]{1, 2, 3}; [EOL] Integer[] newArray = ArrayUtils.add(originalArray, null); [EOL] assertNotNull(newArray); [EOL] assertEquals(4, newArray.length); [EOL] assertNull(newArray[3]); [EOL] } [EOL] public void testAddArrayNullElementNotNull() { [EOL] Integer elementToAdd = 4; [EOL] Integer[] newArray = ArrayUtils.add(null, elementToAdd); [EOL] assertNotNull(newArray); [EOL] assertEquals(1, newArray.length); [EOL] assertEquals(Integer.valueOf(4), newArray[0]); [EOL] } [EOL] public void testAddArrayAndElementBothNull() { [EOL] try { [EOL] ArrayUtils.add(null, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testAddNullArray() { [EOL] final int elementToAdd = 5; [EOL] final int[] result = ArrayUtils.add(null, elementToAdd); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(elementToAdd, result[0]); [EOL] }
public void testAddNonNullArray() { [EOL] final int[] array = {1, 2, 3}; [EOL] final int elementToAdd = 4; [EOL] final int[] result = ArrayUtils.add(array, elementToAdd); [EOL] assertNotNull(result); [EOL] assertEquals(array.length + 1, result.length); [EOL] assertEquals(elementToAdd, result[result.length - 1]); [EOL] for (int i = 0; i < array.length; i++) { [EOL] assertEquals(array[i], result[i]); [EOL] } [EOL] }
public void testAdd_BothArrayAndElementNull_ThrowsException() { [EOL] try { [EOL] Object[] result = ArrayUtils.add(null, 0, null); [EOL] fail("Expected IllegalArgumentException was not thrown."); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Array and element cannot both be null", e.getMessage()); [EOL] } [EOL] }
public void testAdd_ArrayNotNull_AddElement() { [EOL] String[] array = {"a", "b", "c"}; [EOL] String element = "d"; [EOL] String[] result = ArrayUtils.add(array, 2, element); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("d", result[2]); [EOL] assertEquals("c", result[3]); [EOL] }
public void testAdd_ArrayNull_AddElement() { [EOL] String[] array = null; [EOL] String element = "a"; [EOL] String[] result = ArrayUtils.add(array, 0, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a", result[0]); [EOL] }
public void testAddBooleanArrayAtIndex() { [EOL] boolean[] array = {true, false, true}; [EOL] boolean elementToAdd = false; [EOL] int index = 1; [EOL] boolean[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] assertNotNull(newArray); [EOL] assertEquals(4, newArray.length); [EOL] assertTrue(newArray[0]); [EOL] assertFalse(newArray[1]); [EOL] assertFalse(newArray[2]); [EOL] assertTrue(newArray[3]); [EOL] }
public void testAddBooleanArrayAtStart() { [EOL] boolean[] array = {false, true}; [EOL] boolean elementToAdd = true; [EOL] int index = 0; [EOL] boolean[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] assertNotNull(newArray); [EOL] assertEquals(3, newArray.length); [EOL] assertTrue(newArray[0]); [EOL] assertFalse(newArray[1]); [EOL] assertTrue(newArray[2]); [EOL] }
public void testAddBooleanArrayAtEnd() { [EOL] boolean[] array = {true, false}; [EOL] boolean elementToAdd = true; [EOL] int index = array.length; [EOL] boolean[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] assertNotNull(newArray); [EOL] assertEquals(3, newArray.length); [EOL] assertTrue(newArray[0]); [EOL] assertFalse(newArray[1]); [EOL] assertTrue(newArray[2]); [EOL] }
public void testAddBooleanArrayWithInvalidIndex() { [EOL] boolean[] array = {true, false}; [EOL] boolean elementToAdd = true; [EOL] int index = -1; [EOL] try { [EOL] ArrayUtils.add(array, index, elementToAdd); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddBooleanArrayWithNullArray() { [EOL] boolean[] array = null; [EOL] boolean elementToAdd = true; [EOL] int index = 0; [EOL] boolean[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] assertNotNull(newArray); [EOL] assertEquals(1, newArray.length); [EOL] assertTrue(newArray[0]); [EOL] }
public void testAddCharAtIndex() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'z'; [EOL] int index = 1; [EOL] char[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new char[]{'a', 'z', 'b', 'c'}, result); [EOL] }
public void testAddCharAtStart() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'z'; [EOL] int index = 0; [EOL] char[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new char[]{'z', 'a', 'b', 'c'}, result); [EOL] }
public void testAddCharAtEnd() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'z'; [EOL] int index = array.length; [EOL] char[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c', 'z'}, result); [EOL] }
public void testAddCharToEmptyArray() { [EOL] char[] array = {}; [EOL] char element = 'z'; [EOL] int index = 0; [EOL] char[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new char[]{'z'}, result); [EOL] }
public void testAddCharWithNegativeIndex() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'z'; [EOL] int index = -1; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddCharWithIndexGreaterThanLength() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'z'; [EOL] int index = array.length + 1; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddByteToArrayAtIndex_NullArray() { [EOL] final byte element = 1; [EOL] final int index = 0; [EOL] byte[] result = ArrayUtils.add(null, index, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[index]); [EOL] }
public void testAddByteToArrayAtIndex_EmptyArray() { [EOL] final byte[] array = new byte[0]; [EOL] final byte element = 1; [EOL] final int index = 0; [EOL] byte[] result = ArrayUtils.add(array, index, element); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals(element, result[index]); [EOL] }
public void testAddByteToArrayAtIndex_MiddleOfArray() { [EOL] final byte[] array = {2, 4, 6}; [EOL] final byte element = 3; [EOL] final int index = 1; [EOL] byte[] result = ArrayUtils.add(array, index, element); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals(element, result[index]); [EOL] }
public void testAddByteToArrayAtIndex_EndOfArray() { [EOL] final byte[] array = {2, 4, 6}; [EOL] final byte element = 7; [EOL] final int index = array.length; [EOL] byte[] result = ArrayUtils.add(array, index, element); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals(element, result[index]); [EOL] }
public void testAddByteToArrayAtIndex_OutOfBounds() { [EOL] final byte[] array = {2, 4, 6}; [EOL] final byte element = 7; [EOL] final int index = 4; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddShortArrayAtIndex() { [EOL] short[] array = {1, 2, 3}; [EOL] short elementToAdd = 4; [EOL] int indexToAddAt = 1; [EOL] short[] newArray = ArrayUtils.add(array, indexToAddAt, elementToAdd); [EOL] assertArrayEquals(new short[]{1, 4, 2, 3}, newArray); [EOL] }
public void testAddShortArrayAtStart() { [EOL] short[] array = {1, 2, 3}; [EOL] short elementToAdd = 0; [EOL] int indexToAddAt = 0; [EOL] short[] newArray = ArrayUtils.add(array, indexToAddAt, elementToAdd); [EOL] assertArrayEquals(new short[]{0, 1, 2, 3}, newArray); [EOL] }
public void testAddShortArrayAtEnd() { [EOL] short[] array = {1, 2, 3}; [EOL] short elementToAdd = 4; [EOL] int indexToAddAt = array.length; [EOL] short[] newArray = ArrayUtils.add(array, indexToAddAt, elementToAdd); [EOL] assertArrayEquals(new short[]{1, 2, 3, 4}, newArray); [EOL] }
public void testAddShortArrayWithNull() { [EOL] short elementToAdd = 1; [EOL] int indexToAddAt = 0; [EOL] short[] newArray = ArrayUtils.add(null, indexToAddAt, elementToAdd); [EOL] assertArrayEquals(new short[]{1}, newArray); [EOL] }
public void testAddShortArrayWithNegativeIndex() { [EOL] short[] array = {1, 2, 3}; [EOL] short elementToAdd = 4; [EOL] int indexToAddAt = -1; [EOL] try { [EOL] ArrayUtils.add(array, indexToAddAt, elementToAdd); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddShortArrayWithIndexOutOfBounds() { [EOL] short[] array = {1, 2, 3}; [EOL] short elementToAdd = 4; [EOL] int indexToAddAt = 4; [EOL] try { [EOL] ArrayUtils.add(array, indexToAddAt, elementToAdd); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddWithValidIndex() { [EOL] int[] array = {1, 2, 3}; [EOL] int index = 1; [EOL] int elementToAdd = 4; [EOL] int[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] int[] expectedArray = {1, 4, 2, 3}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAddWithIndexZero() { [EOL] int[] array = {1, 2, 3}; [EOL] int index = 0; [EOL] int elementToAdd = 4; [EOL] int[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] int[] expectedArray = {4, 1, 2, 3}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAddWithIndexEqualToArrayLength() { [EOL] int[] array = {1, 2, 3}; [EOL] int index = array.length; [EOL] int elementToAdd = 4; [EOL] int[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] int[] expectedArray = {1, 2, 3, 4}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAddWithEmptyArray() { [EOL] int[] array = {}; [EOL] int index = 0; [EOL] int elementToAdd = 4; [EOL] int[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] int[] expectedArray = {4}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAdd_LongArrayAtIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] int index = 1; [EOL] long elementToAdd = 4; [EOL] long[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] long[] expectedArray = {1, 4, 2, 3}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAdd_LongArrayAtStart() { [EOL] long[] array = {1, 2, 3}; [EOL] int index = 0; [EOL] long elementToAdd = 4; [EOL] long[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] long[] expectedArray = {4, 1, 2, 3}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAdd_LongArrayAtEnd() { [EOL] long[] array = {1, 2, 3}; [EOL] int index = 3; [EOL] long elementToAdd = 4; [EOL] long[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] long[] expectedArray = {1, 2, 3, 4}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAdd_LongArrayWithEmpty() { [EOL] long[] array = {}; [EOL] int index = 0; [EOL] long elementToAdd = 4; [EOL] long[] newArray = ArrayUtils.add(array, index, elementToAdd); [EOL] long[] expectedArray = {4}; [EOL] assertArrayEquals(expectedArray, newArray); [EOL] }
public void testAdd_LongArrayWithNull() { [EOL] long[] array = null; [EOL] int index = 0; [EOL] long elementToAdd = 4; [EOL] try { [EOL] ArrayUtils.add(array, index, elementToAdd); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAdd_LongArrayWithInvalidIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] int index = 4; [EOL] long elementToAdd = 4; [EOL] try { [EOL] ArrayUtils.add(array, index, elementToAdd); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddFloatArrayAtIndex() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] int index = 1; [EOL] float element = 4.0f; [EOL] float[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new float[] {1.0f, 4.0f, 2.0f, 3.0f}, result, 0.0f); [EOL] }
public void testAddFloatArrayAtStart() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] int index = 0; [EOL] float element = 4.0f; [EOL] float[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new float[] {4.0f, 1.0f, 2.0f, 3.0f}, result, 0.0f); [EOL] }
public void testAddFloatArrayAtEnd() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] int index = array.length; [EOL] float element = 4.0f; [EOL] float[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new float[] {1.0f, 2.0f, 3.0f, 4.0f}, result, 0.0f); [EOL] }
public void testAddFloatArrayWithNull() { [EOL] float[] array = null; [EOL] int index = 0; [EOL] float element = 4.0f; [EOL] float[] result = ArrayUtils.add(array, index, element); [EOL] assertArrayEquals(new float[] {4.0f}, result, 0.0f); [EOL] }
public void testAddFloatArrayWithNegativeIndex() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] int index = -1; [EOL] float element = 4.0f; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddFloatArrayWithIndexGreaterThanLength() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] int index = 4; [EOL] float element = 4.0f; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAdd_DoubleArrayAtIndex() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] int index = 1; [EOL] double element = 4.0; [EOL] double[] result = ArrayUtils.add(array, index, element); [EOL] double[] expected = {1.0, 4.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result, 0.0); [EOL] }
public void testAdd_DoubleArrayAtStart() { [EOL] double[] array = {2.0, 3.0}; [EOL] int index = 0; [EOL] double element = 1.0; [EOL] double[] result = ArrayUtils.add(array, index, element); [EOL] double[] expected = {1.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result, 0.0); [EOL] }
public void testAdd_DoubleArrayAtEnd() { [EOL] double[] array = {1.0, 2.0}; [EOL] int index = 2; [EOL] double element = 3.0; [EOL] double[] result = ArrayUtils.add(array, index, element); [EOL] double[] expected = {1.0, 2.0, 3.0}; [EOL] assertArrayEquals(expected, result, 0.0); [EOL] }
public void testAdd_DoubleArrayWithNull() { [EOL] double[] array = null; [EOL] int index = 0; [EOL] double element = 1.0; [EOL] double[] result = ArrayUtils.add(array, index, element); [EOL] double[] expected = {1.0}; [EOL] assertArrayEquals(expected, result, 0.0); [EOL] }
public void testAdd_DoubleArrayWithNegativeIndex() { [EOL] double[] array = {1.0, 2.0}; [EOL] int index = -1; [EOL] double element = 3.0; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAdd_DoubleArrayWithOutOfBoundsIndex() { [EOL] double[] array = {1.0, 2.0}; [EOL] int index = 3; [EOL] double element = 3.0; [EOL] try { [EOL] ArrayUtils.add(array, index, element); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAddWithNullArrayAndNonZeroIndex() { [EOL] try { [EOL] Object result = add(null, 1, "element", String.class); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] assertEquals("Index: 1, Length: 0", ex.getMessage()); [EOL] } [EOL] }
public void testAddWithNullArrayAndZeroIndex() { [EOL] Object result = add(null, 0, "element", String.class); [EOL] assertNotNull(result); [EOL] assertEquals(1, Array.getLength(result)); [EOL] assertEquals("element", Array.get(result, 0)); [EOL] }
public void testAddWithValidArrayAndIndex() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] Object result = add(array, 1, "element", String.class); [EOL] assertNotNull(result); [EOL] assertEquals(4, Array.getLength(result)); [EOL] assertEquals("element", Array.get(result, 1)); [EOL] }
public void testAddWithValidArrayAndEndIndex() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] Object result = add(array, 3, "element", String.class); [EOL] assertNotNull(result); [EOL] assertEquals(4, Array.getLength(result)); [EOL] assertEquals("element", Array.get(result, 3)); [EOL] }
public void testAddWithValidArrayAndNegativeIndex() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] try { [EOL] Object result = add(array, -1, "element", String.class); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] assertEquals("Index: -1, Length: 3", ex.getMessage()); [EOL] } [EOL] }
public void testAddWithValidArrayAndOutOfBoundsIndex() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] try { [EOL] Object result = add(array, 4, "element", String.class); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] assertEquals("Index: 4, Length: 3", ex.getMessage()); [EOL] } [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'd'; [EOL] char[] result = removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElement_ArrayContainsElement() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char element = 'b'; [EOL] char[] expected = {'a', 'c'}; [EOL] char[] result = removeElement(array, element); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_ArrayIsNull() { [EOL] char[] array = null; [EOL] char element = 'b'; [EOL] char[] result = removeElement(array, element); [EOL] assertNull(result); [EOL] }
public void testRemoveElement_ArrayIsEmpty() { [EOL] char[] array = {}; [EOL] char element = 'b'; [EOL] char[] result = removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveFloatArrayAtIndex() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.remove(array, 1); [EOL] float[] expected = new float[] {1.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveFloatArrayAtStart() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.remove(array, 0); [EOL] float[] expected = new float[] {2.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveFloatArrayAtEnd() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float[] result = ArrayUtils.remove(array, 2); [EOL] float[] expected = new float[] {1.0f, 2.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveFloatArrayOutOfBounds() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] try { [EOL] ArrayUtils.remove(array, 3); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveFloatArrayFromEmpty() { [EOL] float[] array = new float[] {}; [EOL] try { [EOL] ArrayUtils.remove(array, 0); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveFloatArrayWithNull() { [EOL] try { [EOL] ArrayUtils.remove((float[]) null, 0); [EOL] fail("Should throw a NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float element = 4.0f; [EOL] float[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElement_ArrayContainsElement() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f}; [EOL] float element = 2.0f; [EOL] float[] result = ArrayUtils.removeElement(array, element); [EOL] float[] expected = new float[] {1.0f, 3.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveElement_ArrayIsEmpty() { [EOL] float[] array = new float[] {}; [EOL] float element = 1.0f; [EOL] float[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveElement_ArrayIsNull() { [EOL] float[] array = null; [EOL] float element = 1.0f; [EOL] float[] result = ArrayUtils.removeElement(array, element); [EOL] assertNull(result); [EOL] }
public void testRemoveElement_ArrayDoesNotContainElement() { [EOL] int[] array = new int[] {1, 2, 3}; [EOL] int element = 4; [EOL] int[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals("Array should not be changed", new int[] {1, 2, 3}, result); [EOL] }
public void testRemoveElement_ArrayContainsElement() { [EOL] int[] array = new int[] {1, 2, 3}; [EOL] int element = 2; [EOL] int[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals("Element should be removed", new int[] {1, 3}, result); [EOL] }
public void testRemoveElement_ArrayIsEmpty() { [EOL] int[] array = new int[] {}; [EOL] int element = 1; [EOL] int[] result = ArrayUtils.removeElement(array, element); [EOL] assertArrayEquals("Empty array should return empty", new int[] {}, result); [EOL] }
public void testRemoveElement_ArrayIsNull() { [EOL] int[] result = ArrayUtils.removeElement(null, 1); [EOL] assertNull("Null array should return null", result); [EOL] }
public void testRemoveAll_NullArray() { [EOL] char[] result = ArrayUtils.removeAll((char[]) null, 1, 2); [EOL] assertNull(result); [EOL] }
public void testRemoveAll_EmptyArray() { [EOL] char[] emptyArray = new char[0]; [EOL] char[] result = ArrayUtils.removeAll(emptyArray, 1, 2); [EOL] assertArrayEquals(emptyArray, result); [EOL] }
public void testRemoveAll_NoIndices() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char[] result = ArrayUtils.removeAll(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testRemoveAll_ValidIndices() { [EOL] char[] array = {'a', 'b', 'c', 'd'}; [EOL] char[] result = ArrayUtils.removeAll(array, 1, 3); [EOL] char[] expected = {'a', 'c'}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_OutOfBoundsIndices() { [EOL] char[] array = {'a', 'b', 'c', 'd'}; [EOL] try { [EOL] ArrayUtils.removeAll(array, 4); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NegativeIndices() { [EOL] char[] array = {'a', 'b', 'c', 'd'}; [EOL] try { [EOL] ArrayUtils.removeAll(array, -1); [EOL] fail("Should throw an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveElements_NullArray() { [EOL] char[] result = ArrayUtils.removeElements(null, 'a', 'b'); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveElements_EmptyArray() { [EOL] char[] array = new char[0]; [EOL] char[] result = ArrayUtils.removeElements(array, 'a', 'b'); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesToRemove() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char[] result = ArrayUtils.removeElements(array); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_NoValuesFound() { [EOL] char[] array = {'a', 'b', 'c'}; [EOL] char[] result = ArrayUtils.removeElements(array, 'x', 'y'); [EOL] assertArrayEquals(array, result); [EOL] } [EOL] public void testRemoveElements_ValuesToRemove() { [EOL] char[] array = {'a', 'b', 'c', 'b', 'b'}; [EOL] char[] result = ArrayUtils.removeElements(array, 'b'); [EOL] char[] expected = {'a', 'c'}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_MultipleValuesToRemove() { [EOL] char[] array = {'a', 'b', 'c', 'b', 'b'}; [EOL] char[] result = ArrayUtils.removeElements(array, 'b', 'c'); [EOL] char[] expected = {'a'}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_AllValuesToRemove() { [EOL] char[] array = {'a', 'a', 'a'}; [EOL] char[] result = ArrayUtils.removeElements(array, 'a'); [EOL] char[] expected = {}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveDuplicates() { [EOL] char[] array = {'a', 'b', 'c', 'b', 'b'}; [EOL] char[] result = ArrayUtils.removeElements(array, 'b', 'b'); [EOL] char[] expected = {'a', 'c'}; [EOL] assertArrayEquals(expected, result); [EOL] } [EOL] public void testRemoveElements_RemoveNonExistingAndExisting() { [EOL] char[] array = {'a', 'b', 'c', 'd', 'e'}; [EOL] char[] result = ArrayUtils.removeElements(array, 'x', 'b'); [EOL] char[] expected = {'a', 'c', 'd', 'e'}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_FloatArrayWithIndices() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] int[] indices = new int[] {1, 3}; [EOL] float[] result = ArrayUtils.removeAll(array, indices); [EOL] float[] expected = new float[] {1.0f, 3.0f, 5.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_FloatArrayWithNoIndices() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] int[] indices = new int[] {}; [EOL] float[] result = ArrayUtils.removeAll(array, indices); [EOL] float[] expected = new float[] {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_FloatArrayWithAllIndices() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] int[] indices = new int[] {0, 1, 2, 3, 4}; [EOL] float[] result = ArrayUtils.removeAll(array, indices); [EOL] float[] expected = new float[] {}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testRemoveAll_FloatArrayWithInvalidIndices() { [EOL] float[] array = new float[] {1.0f, 2.0f, 3.0f, 4.0f, 5.0f}; [EOL] int[] indices = new int[] {5, 6}; // Assuming the method should handle out-of-bounds gracefully [EOL] try { [EOL] ArrayUtils.removeAll(array, indices); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testRemoveAll_NullFloatArray() { [EOL] float[] result = ArrayUtils.removeAll(null, 1, 2); [EOL] assertNull(result); [EOL] }
public void testRemoveAllWithEmptyIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array); [EOL] assertEquals("Result should have the same length as input array", array.length, result.length); [EOL] assertArrayEquals("Result should be equal to the original array", array, result); [EOL] } [EOL] public void testRemoveAllWithValidIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {1, 3}; [EOL] Integer[] expected = new Integer[] {1, 3, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, indices); [EOL] assertEquals("Result should have a length of array minus indices length", array.length - indices.length, result.length); [EOL] assertArrayEquals("Result should have specific elements removed", expected, result); [EOL] } [EOL] public void testRemoveAllWithDuplicateIndices() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {2, 2}; [EOL] Integer[] expected = new Integer[] {1, 2, 4, 5}; [EOL] Integer[] result = (Integer[]) removeAll(array, indices); [EOL] assertEquals("Result should have a length of array minus unique indices length", array.length - 1, result.length); [EOL] assertArrayEquals("Result should have specific elements removed considering unique indices", expected, result); [EOL] } [EOL] public void testRemoveAllWithOutOfBoundsIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {0, 5}; // 5 is out of bounds [EOL] try { [EOL] removeAll(array, indices); [EOL] fail("Should throw IndexOutOfBoundsException for out of bounds index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithNegativeIndex() { [EOL] Integer[] array = new Integer[] {1, 2, 3, 4, 5}; [EOL] int[] indices = {-1, 2}; // -1 is a negative index [EOL] try { [EOL] removeAll(array, indices); [EOL] fail("Should throw IndexOutOfBoundsException for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithNullArray() { [EOL] try { [EOL] removeAll(null, 1, 2); [EOL] fail("Should throw NullPointerException for null array"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testRemoveAllWithEmptyArray() { [EOL] Integer[] array = new Integer[0]; [EOL] int[] indices = {0}; [EOL] Integer[] result = (Integer[]) removeAll(array, indices); [EOL] assertEquals("Result should be an empty array", 0, result.length); [EOL] }

public void testSetAccessibleWorkaround_NullInput() { [EOL] setAccessibleWorkaround(null); [EOL] } [EOL] public void testSetAccessibleWorkaround_AlreadyAccessible() { [EOL] AccessibleObject accessibleObject = mock(AccessibleObject.class); [EOL] when(accessibleObject.isAccessible()).thenReturn(true); [EOL] setAccessibleWorkaround(accessibleObject); [EOL] } [EOL] public void testSetAccessibleWorkaround_PublicMember() { [EOL] AccessibleObject accessibleObject = mock(AccessibleObject.class); [EOL] Member member = mock(Member.class); [EOL] when(accessibleObject.isAccessible()).thenReturn(false); [EOL] when((Member) accessibleObject).thenReturn(member); [EOL] when(member.getModifiers()).thenReturn(Modifier.PUBLIC); [EOL] when(isPackageAccess(member.getDeclaringClass().getModifiers())).thenReturn(true); [EOL] setAccessibleWorkaround(accessibleObject); [EOL] } [EOL] public void testSetAccessibleWorkaround_SecurityException() { [EOL] AccessibleObject accessibleObject = mock(AccessibleObject.class); [EOL] Member member = mock(Member.class); [EOL] when(accessibleObject.isAccessible()).thenReturn(false); [EOL] when((Member) accessibleObject).thenReturn(member); [EOL] when(member.getModifiers()).thenReturn(Modifier.PUBLIC); [EOL] when(isPackageAccess(member.getDeclaringClass().getModifiers())).thenReturn(true); [EOL] doThrow(new SecurityException()).when(accessibleObject).setAccessible(true); [EOL] setAccessibleWorkaround(accessibleObject); [EOL] } [EOL] public void testSetAccessibleWorkaround_NonPublicMember() { [EOL] AccessibleObject accessibleObject = mock(AccessibleObject.class); [EOL] Member member = mock(Member.class); [EOL] when(accessibleObject.isAccessible()).thenReturn(false); [EOL] when((Member) accessibleObject).thenReturn(member); [EOL] when(member.getModifiers()).thenReturn(0); // Non-public [EOL] when(isPackageAccess(member.getDeclaringClass().getModifiers())).thenReturn(false); [EOL] setAccessibleWorkaround(accessibleObject); [EOL] }
static boolean isPackageAccess(final int modifiers) { [EOL] return (modifiers & ACCESS_TEST) == 0; [EOL] }
public void testDetermineTypeArgumentsWithNonAssignableClass() { [EOL] Class<?> cls = String.class; [EOL] ParameterizedType superType = (ParameterizedType) ArrayList.class.getGenericSuperclass(); [EOL] Map<TypeVariable<?>, Type> result = TypeUtils.determineTypeArguments(cls, superType); [EOL] assertNull(result); [EOL] } [EOL] public void testDetermineTypeArgumentsWithSameClass() { [EOL] Class<?> cls = ArrayList.class; [EOL] ParameterizedType superType = (ParameterizedType) ArrayList.class.getGenericSuperclass(); [EOL] Map<TypeVariable<?>, Type> result = TypeUtils.determineTypeArguments(cls, superType); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDetermineTypeArgumentsWithMidTypeAsClass() { [EOL] Class<?> cls = ArrayList.class; [EOL] ParameterizedType superType = (ParameterizedType) AbstractList.class.getGenericSuperclass(); [EOL] Map<TypeVariable<?>, Type> result = TypeUtils.determineTypeArguments(cls, superType); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
public void testDetermineTypeArgumentsWithMidTypeAsParameterizedType() { [EOL] Class<?> cls = ArrayList.class; [EOL] ParameterizedType superType = (ParameterizedType) List.class.getGenericSuperclass(); [EOL] Map<TypeVariable<?>, Type> result = TypeUtils.determineTypeArguments(cls, superType); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] }
private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL] final Type ownerType = parameterizedType.getOwnerType(); [EOL] if (ownerType instanceof ParameterizedType) { [EOL] mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL] } [EOL] final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL] final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL] final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL] for (int i = 0; i < typeArgs.length; i++) { [EOL] final TypeVariable<?> typeVar = typeVars[i]; [EOL] final Type typeArg = typeArgs[i]; [EOL] if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL] typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL] } [EOL] } [EOL] }
public void testGetClosestParentTypeWithSuperClassInterface() { [EOL] Class<?> cls = ArrayList.class; [EOL] Class<?> superClass = List.class; [EOL] Type result = getClosestParentType(cls, superClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ParameterizedType); [EOL] ParameterizedType parameterizedType = (ParameterizedType) result; [EOL] assertEquals(superClass, parameterizedType.getRawType()); [EOL] }
public void testGetClosestParentTypeWithSuperClassNonInterface() { [EOL] Class<?> cls = Integer.class; [EOL] Class<?> superClass = Number.class; [EOL] Type result = getClosestParentType(cls, superClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Class<?>); [EOL] assertEquals(superClass, result); [EOL] }
public void testGetClosestParentTypeWithUnrelatedSuperClass() { [EOL] Class<?> cls = Integer.class; [EOL] Class<?> superClass = List.class; [EOL] try { [EOL] getClosestParentType(cls, superClass); [EOL] fail("Should throw IllegalStateException for unrelated interface"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testGetClosestParentTypeWithSuperClassBeingClass() { [EOL] Class<?> cls = LinkedHashMap.class; [EOL] Class<?> superClass = AbstractMap.class; [EOL] Type result = getClosestParentType(cls, superClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Class<?>); [EOL] assertEquals(superClass, result); [EOL] }
public void testNormalizeUpperBounds_SingleElement() { [EOL] Type[] singleBound = new Type[] { String.class }; [EOL] Type[] result = YourClass.normalizeUpperBounds(singleBound); [EOL] assertEquals("Array should be the same as the input array when there is only one element.", singleBound, result); [EOL] }
public void testNormalizeUpperBounds_MultipleElementsNoSubtypes() { [EOL] Type[] multipleBounds = new Type[] { String.class, Integer.class }; [EOL] Type[] result = YourClass.normalizeUpperBounds(multipleBounds); [EOL] assertEquals("Array should contain all elements when there are no subtypes.", multipleBounds.length, result.length); [EOL] assertTrue("Array should contain String class.", Arrays.asList(result).contains(String.class)); [EOL] assertTrue("Array should contain Integer class.", Arrays.asList(result).contains(Integer.class)); [EOL] }
public void testNormalizeUpperBounds_MultipleElementsWithSubtypes() { [EOL] Type[] multipleBounds = new Type[] { Number.class, Integer.class }; [EOL] Type[] result = YourClass.normalizeUpperBounds(multipleBounds); [EOL] assertEquals("Array should contain fewer elements when subtypes are present.", 1, result.length); [EOL] assertTrue("Array should only contain Number class after normalization.", Arrays.asList(result).contains(Number.class)); [EOL] }
public void testGetFormattedExceptionMessageWithBaseMessageAndContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] exceptionContext.addContextValue("key2", "value2"); [EOL] String baseMessage = "Base message"; [EOL] String result = exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] assertTrue(result.startsWith(baseMessage)); [EOL] assertTrue(result.contains("Exception Context:")); [EOL] assertTrue(result.contains("[1:key1=value1]")); [EOL] assertTrue(result.contains("[2:key2=value2]")); [EOL] assertTrue(result.contains("---------------------------------")); [EOL] }
public void testGetFormattedExceptionMessageWithBaseMessageNoContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] String baseMessage = "Base message"; [EOL] String result = exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] assertEquals(baseMessage, result); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessageAndContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] String result = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertFalse(result.startsWith("\n")); [EOL] assertTrue(result.contains("Exception Context:")); [EOL] assertTrue(result.contains("[1:key1=value1]")); [EOL] assertTrue(result.contains("---------------------------------")); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessageNoContext() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] String result = exceptionContext.getFormattedExceptionMessage(null); [EOL] assertEquals("", result); [EOL] }
public void testGetFormattedExceptionMessageWithExceptionInToString() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Object problematicObject = new Object() { [EOL] @Override [EOL] public String toString() { [EOL] throw new RuntimeException("toString failure"); [EOL] } [EOL] }; [EOL] exceptionContext.addContextValue("problematicKey", problematicObject); [EOL] String result = exceptionContext.getFormattedExceptionMessage("Error occurred"); [EOL] assertTrue(result.contains("Error occurred")); [EOL] assertTrue(result.contains("Exception thrown on toString()")); [EOL] }
public void testSetNullTextWithNonNullEmptyString() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText(""); [EOL] assertNull(builder.getNullText()); [EOL] }
public void testSetNullTextWithNonNullNonEmptyString() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText("text"); [EOL] assertEquals("text", builder.getNullText()); [EOL] }
public void testSetNullTextWithNull() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText(null); [EOL] assertNull(builder.getNullText()); [EOL] }
public void testCharAt_ValidIndex() { [EOL] CharSequence cs = new CustomCharSequence("abc"); // CustomCharSequence is a hypothetical class [EOL] char result = cs.charAt(1); [EOL] assert result == 'b'; [EOL] } [EOL] public void testCharAt_IndexOutOfBounds_Negative() { [EOL] CharSequence cs = new CustomCharSequence("abc"); [EOL] try { [EOL] cs.charAt(-1); [EOL] assert false : "Expected StringIndexOutOfBoundsException for negative index"; [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assert true; [EOL] } [EOL] } [EOL] public void testCharAt_IndexOutOfBounds_TooLarge() { [EOL] CharSequence cs = new CustomCharSequence("abc"); [EOL] try { [EOL] cs.charAt(3); [EOL] assert false : "Expected StringIndexOutOfBoundsException for index equal to length"; [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] assert true; [EOL] } [EOL] }
public void testGetCharsWithNullDestination() { [EOL] TextBuffer tb = new TextBuffer("example"); [EOL] char[] destination = null; [EOL] char[] result = tb.getChars(destination); [EOL] assertArrayEquals(new char[]{'e', 'x', 'a', 'm', 'p', 'l', 'e'}, result); [EOL] }
public void testGetCharsWithSmallerDestination() { [EOL] TextBuffer tb = new TextBuffer("example"); [EOL] char[] destination = new char[3]; [EOL] char[] result = tb.getChars(destination); [EOL] assertArrayEquals(new char[]{'e', 'x', 'a', 'm', 'p', 'l', 'e'}, result); [EOL] }
public void testGetCharsWithExactSizeDestination() { [EOL] TextBuffer tb = new TextBuffer("example"); [EOL] char[] destination = new char[7]; [EOL] char[] result = tb.getChars(destination); [EOL] assertArrayEquals(new char[]{'e', 'x', 'a', 'm', 'p', 'l', 'e'}, result); [EOL] }
public void testGetCharsWithLargerDestination() { [EOL] TextBuffer tb = new TextBuffer("example"); [EOL] char[] destination = new char[10]; [EOL] char[] result = tb.getChars(destination); [EOL] assertArrayEquals(new char[]{'e', 'x', 'a', 'm', 'p', 'l', 'e', '\0', '\0', '\0'}, result); [EOL] }
public void testAppendNullWithNullText() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText(null); [EOL] assertSame(builder, builder.appendNull()); [EOL] }
public void testAppendNullWithNonNullText() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText("null"); [EOL] assertSame(builder, builder.appendNull()); [EOL] assertEquals("null", builder.toString()); [EOL] }
public void testAppend_CharSequenceStartIndexLength_NullSeq() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.append((CharSequence) null, 0, 0); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppend_CharSequenceStartIndexLength_ValidSeq() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] CharSequence seq = "abcdef"; [EOL] builder.append(seq, 2, 3); [EOL] assertEquals("cde", builder.toString()); [EOL] }
public void testAppend_CharSequenceStartIndexLength_EmptySeq() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] CharSequence seq = ""; [EOL] builder.append(seq, 0, 0); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppend_CharSequenceStartIndexLength_NegativeStart() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] CharSequence seq = "abcdef"; [EOL] try { [EOL] builder.append(seq, -1, 3); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppend_CharSequenceStartIndexLength_ExcessiveLength() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] CharSequence seq = "abcdef"; [EOL] try { [EOL] builder.append(seq, 2, 10); [EOL] fail("Should throw StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testAppendWithNullString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((String) null); [EOL] assertEquals("appendNull method should be called", sb.toString(), "null"); [EOL] }
public void testAppendWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(""); [EOL] assertEquals("Buffer should remain unchanged", sb.toString(), ""); [EOL] }
public void testAppendWithNonEmptyString() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append("abc"); [EOL] assertEquals("Buffer should contain 'abc'", sb.toString(), "abc"); [EOL] }
public void testAppendStringValid() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] sb.append(str, 1, 3); [EOL] assertEquals("bcd", sb.toString()); [EOL] } [EOL] public void testAppendStringNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(null, 0, 0); [EOL] assertEquals("null", sb.toString()); [EOL] } [EOL] public void testAppendStringInvalidStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, -1, 3); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringInvalidLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, 1, -1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringExceedingLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, 1, 6); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringStartIndexGreaterThanStringLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] try { [EOL] sb.append(str, 7, 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testAppendStringZeroLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] String str = "abcdef"; [EOL] sb.append(str, 2, 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendWithNullStringBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.append((StringBuffer) null); [EOL] assertEquals("appendNull was not called", builder.toString(), "null"); [EOL] }
public void testAppendWithEmptyStringBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer emptyBuffer = new StringBuffer(); [EOL] builder.append(emptyBuffer); [EOL] assertEquals("Buffer should be empty", builder.length(), 0); [EOL] }
public void testAppendWithStringBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer stringBuffer = new StringBuffer("abc"); [EOL] builder.append(stringBuffer); [EOL] assertEquals("Buffer should contain 'abc'", builder.toString(), "abc"); [EOL] }
public void testAppendCharArray_Null() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append((char[]) null); [EOL] assertEquals("appendNull method should be called", "null", sb.toString()); [EOL] }
public void testAppendCharArray_Empty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(new char[0]); [EOL] assertEquals("Buffer should remain unchanged", "", sb.toString()); [EOL] }
public void testAppendCharArray_NonEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[] {'a', 'b', 'c'}; [EOL] sb.append(chars); [EOL] assertEquals("Characters should be appended", "abc", sb.toString()); [EOL] }
public void testAppendInt() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(0); [EOL] assertEquals("0", sb.toString()); [EOL] }
public void testAppendIntNegative() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(-1); [EOL] assertEquals("-1", sb.toString()); [EOL] }
public void testAppendIntPositive() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append(1); [EOL] assertEquals("1", sb.toString()); [EOL] }
public void testAppendLong() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] long value = 1234567890L; [EOL] builder.append(value); [EOL] assertEquals("1234567890", builder.toString()); [EOL] }
public void testAppendLongNegative() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] long value = -9876543210L; [EOL] builder.append(value); [EOL] assertEquals("-9876543210", builder.toString()); [EOL] }
public void testAppendFloat() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] float value = 10.5f; [EOL] builder.append(value); [EOL] assertEquals("10.5", builder.toString()); [EOL] }
public void testAppendFloatNegative() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] float value = -10.5f; [EOL] builder.append(value); [EOL] assertEquals("-10.5", builder.toString()); [EOL] }
public void testAppendFloatZero() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] float value = 0.0f; [EOL] builder.append(value); [EOL] assertEquals("0.0", builder.toString()); [EOL] }
public void testAppendDouble() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] double value = 123.456d; [EOL] builder.append(value); [EOL] assertEquals("123.456", builder.toString()); [EOL] }
public void testAppendDoubleNegative() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] double value = -123.456d; [EOL] builder.append(value); [EOL] assertEquals("-123.456", builder.toString()); [EOL] }
public void testAppendDoubleZero() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] double value = 0.0d; [EOL] builder.append(value); [EOL] assertEquals("0.0", builder.toString()); [EOL] }
public void testAppendlnWithNullStringBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendln((StringBuffer) null); [EOL] assertEquals(System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnWithEmptyStringBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendln(new StringBuffer("")); [EOL] assertEquals(System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnWithStringBuffer() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] StringBuffer stringBuffer = new StringBuffer("test"); [EOL] builder.appendln(stringBuffer); [EOL] assertEquals("test" + System.lineSeparator(), builder.toString()); [EOL] }
public void testAppendlnStrBuilderWithValidRange() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abcdef"); [EOL] sb.appendln(toAppend, 2, 3); [EOL] assertEquals("cde" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnStrBuilderWithNegativeStartIndex() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abcdef"); [EOL] sb.appendln(toAppend, -1, 3); [EOL] assertEquals("abc" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnStrBuilderWithLengthExceeding() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abcdef"); [EOL] sb.appendln(toAppend, 2, 10); [EOL] assertEquals("cdef" + System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnStrBuilderWithNullStrBuilder() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendln((StrBuilder) null, 0, 10); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnStrBuilderWithStartIndexExceeding() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abcdef"); [EOL] sb.appendln(toAppend, 10, 3); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendlnStrBuilderWithZeroLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] StrBuilder toAppend = new StrBuilder("abcdef"); [EOL] sb.appendln(toAppend, 2, 0); [EOL] assertEquals(System.lineSeparator(), sb.toString()); [EOL] }
public void testAppendAllWithNonNullArray() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] String[] array = {"a", "b", "c"}; [EOL] builder.appendAll(array); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testAppendAllWithEmptyArray() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] String[] array = {}; [EOL] builder.appendAll(array); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendAllWithNullArray() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.appendAll((Object[]) null); [EOL] assertEquals("", builder.toString()); [EOL] }
public void testAppendSeparator_String() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append("a"); [EOL] sb.appendSeparator(","); [EOL] assertEquals("a,", sb.toString()); [EOL] }
public void testAppendSeparator_StringNull() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.append("a"); [EOL] sb.appendSeparator(null); [EOL] assertEquals("a", sb.toString()); [EOL] }
public void testAppendSeparator_CharNotEmpty() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.appendSeparator('x'); [EOL] assertEquals("abcx", sb.toString()); [EOL] }
public void testAppendSeparator_CharEmpty() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendSeparator('x'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testAppendFixedWidthPadRight_PositiveWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 5, 'X'); [EOL] assertEquals("abcXX", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_WidthEqualToLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 3, 'X'); [EOL] assertEquals("abc", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_WidthLessThanLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 2, 'X'); [EOL] assertEquals("ab", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_NullObject() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.setNullText("null"); [EOL] sb.appendFixedWidthPadRight(null, 5, 'X'); [EOL] assertEquals("nullX", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_NullObjectNoNullText() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight(null, 5, 'X'); [EOL] assertEquals("XXXXX", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_NegativeWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", -1, 'X'); [EOL] assertEquals("", sb.toString()); [EOL] } [EOL] public void testAppendFixedWidthPadRight_ZeroWidth() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.appendFixedWidthPadRight("abc", 0, 'X'); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testInsert_NullObject() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] builder.setNullText("null"); [EOL] int index = 0; [EOL] builder.insert(index, (Object) null); [EOL] assertEquals("null", builder.toString()); [EOL] } [EOL] public void testInsert_NonNullObject() { [EOL] StrBuilder builder = new StrBuilder(); [EOL] int index = 0; [EOL] Object obj = new Integer(123); [EOL] builder.insert(index, obj); [EOL] assertEquals("123", builder.toString()); [EOL] }
public void testInsertWithNullString() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.setNullText("null"); [EOL] sb.insert(1, null); [EOL] assertEquals("anullbc", sb.toString()); [EOL] }
public void testInsertWithEmptyString() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, ""); [EOL] assertEquals("abc", sb.toString()); [EOL] }
public void testInsertWithValidString() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(1, "xyz"); [EOL] assertEquals("axyzbc", sb.toString()); [EOL] }
public void testInsertAtStart() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(0, "xyz"); [EOL] assertEquals("xyzabc", sb.toString()); [EOL] }
public void testInsertAtEnd() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] sb.insert(3, "xyz"); [EOL] assertEquals("abcxyz", sb.toString()); [EOL] }
public void testInsertOutOfBounds() { [EOL] StrBuilder sb = new StrBuilder("abc"); [EOL] try { [EOL] sb.insert(4, "xyz"); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsert_CharArrayAtIndex_NullArray() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.insert(1, (char[]) null); [EOL] assertEquals("anullbc", builder.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_EmptyArray() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] char[] chars = new char[0]; [EOL] builder.insert(1, chars); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_ValidArray() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] builder.insert(1, chars); [EOL] assertEquals("axyzbc", builder.toString()); [EOL] }
public void testInsert_CharArrayAtIndex_InvalidIndex() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] char[] chars = new char[]{'x', 'y', 'z'}; [EOL] try { [EOL] builder.insert(4, chars); [EOL] fail("Should throw IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithNullChars() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] sb.insert(0, (char[]) null, 0, 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testInsertWithValidOffsetAndLength() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 1, 2); [EOL] assertEquals("bc", sb.toString()); [EOL] }
public void testInsertWithInvalidOffset() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, -1, 2); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithInvalidLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 1, 4); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithOffsetGreaterThanCharsLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 4, 0); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertWithLengthZero() { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 0, 0); [EOL] assertEquals("", sb.toString()); [EOL] }
public void testInsertWithOffsetPlusLengthGreaterThanCharsLength() { [EOL] try { [EOL] StrBuilder sb = new StrBuilder(); [EOL] char[] chars = new char[]{'a', 'b', 'c'}; [EOL] sb.insert(0, chars, 2, 2); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDeleteFirst_NullMatcher() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.deleteFirst((StrMatcher) null); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testDeleteFirst_NoMatch() { [EOL] StrBuilder builder = new StrBuilder("abc"); [EOL] builder.deleteFirst(StrMatcher.noneMatcher()); [EOL] assertEquals("abc", builder.toString()); [EOL] }
public void testDeleteFirst_Match() { [EOL] StrBuilder builder = new StrBuilder("aabbcc"); [EOL] builder.deleteFirst(StrMatcher.charMatcher('a')); [EOL] assertEquals("abbcc", builder.toString()); [EOL] }
public void testDeleteFirst_MatchAtEnd() { [EOL] StrBuilder builder = new StrBuilder("abccba"); [EOL] builder.deleteFirst(StrMatcher.charMatcher('a')); [EOL] assertEquals("bccba", builder.toString()); [EOL] }
public void testSubstring_ValidRange() { [EOL] TextStringBuilder builder = new TextStringBuilder("Hello World"); [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] String result = builder.substring(startIndex, endIndex); [EOL] assertEquals("Hello", result); [EOL] }
public void testSubstring_EndIndexGreaterThanLength() { [EOL] TextStringBuilder builder = new TextStringBuilder("Hello World"); [EOL] int startIndex = 0; [EOL] int endIndex = builder.length() + 1; [EOL] try { [EOL] builder.substring(startIndex, endIndex); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubstring_StartIndexNegative() { [EOL] TextStringBuilder builder = new TextStringBuilder("Hello World"); [EOL] int startIndex = -1; [EOL] int endIndex = 5; [EOL] try { [EOL] builder.substring(startIndex, endIndex); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubstring_EndIndexNegative() { [EOL] TextStringBuilder builder = new TextStringBuilder("Hello World"); [EOL] int startIndex = 0; [EOL] int endIndex = -1; [EOL] try { [EOL] builder.substring(startIndex, endIndex); [EOL] fail("Should have thrown an IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testSubstring_StartIndexGreaterThanEndIndex() { [EOL] TextStringBuilder builder = new TextStringBuilder("Hello World"); [EOL] int startIndex = 5; [EOL] int endIndex = 3; [EOL] try { [EOL] builder.substring(startIndex, endIndex); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSubstring_StartIndexEqualsEndIndex() { [EOL] TextStringBuilder builder = new TextStringBuilder("Hello World"); [EOL] int startIndex = 5; [EOL] int endIndex = 5; [EOL] String result = builder.substring(startIndex, endIndex); [EOL] assertEquals("", result); [EOL] }
public void testAsReader() { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] Reader reader = strBuilder.asReader(); [EOL] assertNotNull(reader); [EOL] assertTrue(reader instanceof StrBuilder.StrBuilderReader); [EOL] }
public String build() { [EOL] return toString(); [EOL] }
public void testValidateIndex_ValidIndex() { [EOL] int size = 5; [EOL] validateIndex(0); [EOL] validateIndex(size); [EOL] } [EOL] public void testValidateIndex_InvalidIndexNegative() { [EOL] int size = 5; [EOL] try { [EOL] validateIndex(-1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testValidateIndex_InvalidIndexTooLarge() { [EOL] int size = 5; [EOL] try { [EOL] validateIndex(size + 1); [EOL] fail("Should have thrown StringIndexOutOfBoundsException"); [EOL] } catch (StringIndexOutOfBoundsException e) { [EOL] } [EOL] }

public void testStrBuilderReaderConstructor() { [EOL] StrBuilderReader strBuilderReader = new StrBuilderReader(); [EOL] assertNotNull(strBuilderReader); [EOL] }
public void testReadWhenNotReady() throws IOException { [EOL] StrBuilder strBuilder = new StrBuilder(); [EOL] int result = strBuilder.read(); [EOL] assertEquals("Expected result is -1 when not ready", -1, result); [EOL] }
public void testReadWhenReady() throws IOException { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] int result = strBuilder.read(); [EOL] assertEquals("Expected result is the char value at the current position", 'a', result); [EOL] result = strBuilder.read(); [EOL] assertEquals("Expected result is the char value at the next position", 'b', result); [EOL] }
public void testReadWithNegativeOffset() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] try { [EOL] strBuilder.read(buffer, -1, 1); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testReadWithNegativeLength() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] try { [EOL] strBuilder.read(buffer, 0, -1); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testReadWithOffsetOutOfBounds() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] try { [EOL] strBuilder.read(buffer, 11, 1); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testReadWithLengthOutOfBounds() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] try { [EOL] strBuilder.read(buffer, 1, 10); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] } [EOL] public void testReadWithZeroLength() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] int result = strBuilder.read(buffer, 0, 0); [EOL] assertEquals("Reading 0 characters should return 0", 0, result); [EOL] } [EOL] public void testReadAtEndOfString() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] int result = strBuilder.read(buffer, 0, 1); [EOL] assertEquals("Reading at the end of the string should return -1", -1, result); [EOL] } [EOL] public void testReadWithLengthExceedingStrBuilderSize() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] int result = strBuilder.read(buffer, 0, 5); [EOL] assertEquals("Reading should adjust length to StrBuilder size", 4, result); [EOL] } [EOL] public void testReadWithValidParameters() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] char[] buffer = new char[10]; [EOL] int result = strBuilder.read(buffer, 0, 2); [EOL] assertEquals("Reading with valid parameters should return the correct length", 2, result); [EOL] assertEquals("Buffer should contain the read characters", 't', buffer[0]); [EOL] assertEquals("Buffer should contain the read characters", 'e', buffer[1]); [EOL] }
public void testSkipBeyondStrBuilderSize() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] long skipped = strBuilder.skip(10); [EOL] assertEquals(3, skipped); [EOL] assertEquals(3, strBuilder.length()); [EOL] } [EOL] public void testSkipNegative() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] long skipped = strBuilder.skip(-1); [EOL] assertEquals(0, skipped); [EOL] assertEquals(3, strBuilder.length()); [EOL] } [EOL] public void testSkipWithinStrBuilderSize() { [EOL] StrBuilder strBuilder = new StrBuilder("abc"); [EOL] long skipped = strBuilder.skip(2); [EOL] assertEquals(2, skipped); [EOL] assertEquals(3, strBuilder.length()); [EOL] }
public void testReadyWhenPositionLessThanSize() { [EOL] StrBuilder strBuilder = new StrBuilder("test"); [EOL] StrBuilder.StrBuilderReader reader = strBuilder.new StrBuilderReader(); [EOL] assertTrue(reader.ready()); [EOL] }
public void testReadyWhenPositionEqualToSize() { [EOL] StrBuilder strBuilder = new StrBuilder(""); [EOL] StrBuilder.StrBuilderReader reader = strBuilder.new StrBuilderReader(); [EOL] assertFalse(reader.ready()); [EOL] }
public void testReadyWhenPositionGreaterThanSize() { [EOL] StrBuilder strBuilder = new StrBuilder(""); [EOL] StrBuilder.StrBuilderReader reader = strBuilder.new StrBuilderReader(); [EOL] reader.pos = 1; [EOL] assertFalse(reader.ready()); [EOL] }
public void testMarkSupported() { [EOL] YourInputStreamClass inputStream = new YourInputStreamClass(); [EOL] assertTrue(inputStream.markSupported()); [EOL] }
public void testMarkAtStart() { [EOL] CharArrayReader charArrayReader = new CharArrayReader(new char[] {'a', 'b', 'c'}); [EOL] charArrayReader.mark(0); [EOL] assertEquals(0, charArrayReader.getPos()); [EOL] assertEquals(0, charArrayReader.getMark()); [EOL] }
public void testMarkAfterReading() { [EOL] CharArrayReader charArrayReader = new CharArrayReader(new char[] {'a', 'b', 'c'}); [EOL] charArrayReader.read(); [EOL] charArrayReader.mark(0); [EOL] assertEquals(1, charArrayReader.getPos()); [EOL] assertEquals(1, charArrayReader.getMark()); [EOL] }
public void testReset_PosAndMarkAtDifferentValues() { [EOL] CharArrayWriter charArrayWriter = new CharArrayWriter(); [EOL] charArrayWriter.append('a'); [EOL] charArrayWriter.append('b'); [EOL] charArrayWriter.append('c'); [EOL] charArrayWriter.mark = 1; [EOL] charArrayWriter.pos = 2; [EOL] charArrayWriter.reset(); [EOL] assertEquals("Reset should set pos to mark", 1, charArrayWriter.pos); [EOL] }
public void testReset_PosAndMarkAtSameValue() { [EOL] CharArrayWriter charArrayWriter = new CharArrayWriter(); [EOL] charArrayWriter.append('a'); [EOL] charArrayWriter.mark = 0; [EOL] charArrayWriter.pos = 0; [EOL] charArrayWriter.reset(); [EOL] assertEquals("Reset should not change pos when pos and mark are the same", 0, charArrayWriter.pos); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return cache.getInstance(pattern, timeZone, locale); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
public void testGetTimeInstanceWithDifferentStyles() { [EOL] FastDateFormat fdfFull = FastDateFormat.getTimeInstance(FastDateFormat.FULL); [EOL] assertNotNull(fdfFull); [EOL] FastDateFormat fdfLong = FastDateFormat.getTimeInstance(FastDateFormat.LONG); [EOL] assertNotNull(fdfLong); [EOL] FastDateFormat fdfMedium = FastDateFormat.getTimeInstance(FastDateFormat.MEDIUM); [EOL] assertNotNull(fdfMedium); [EOL] FastDateFormat fdfShort = FastDateFormat.getTimeInstance(FastDateFormat.SHORT); [EOL] assertNotNull(fdfShort); [EOL] assertNotEquals(fdfFull, fdfLong); [EOL] assertNotEquals(fdfFull, fdfMedium); [EOL] assertNotEquals(fdfFull, fdfShort); [EOL] assertNotEquals(fdfLong, fdfMedium); [EOL] assertNotEquals(fdfLong, fdfShort); [EOL] assertNotEquals(fdfMedium, fdfShort); [EOL] }
public void testGetTimeInstanceWithInvalidStyle() { [EOL] try { [EOL] FastDateFormat.getTimeInstance(Integer.MAX_VALUE); [EOL] fail("Should have thrown IllegalArgumentException for invalid style"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public static FastDateFormat getTimeInstance(final int style, final Locale locale) { [EOL] return cache.getTimeInstance(style, null, locale); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
public void testGetTimeInstanceWithStyleAndTimeZone() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(FastDateFormat.LONG, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] } [EOL] public void testGetTimeInstanceWithInvalidStyle() { [EOL] try { [EOL] FastDateFormat.getTimeInstance(Integer.MAX_VALUE, TimeZone.getDefault()); [EOL] fail("Should have thrown IllegalArgumentException for invalid style"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetTimeInstanceWithNullTimeZone() { [EOL] FastDateFormat fdf = FastDateFormat.getTimeInstance(FastDateFormat.SHORT, null); [EOL] assertNotNull(fdf); [EOL] assertEquals(TimeZone.getDefault(), fdf.getTimeZone()); [EOL] }
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL] return cache.getTimeInstance(style, timeZone, locale); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle) { [EOL] return cache.getDateTimeInstance(dateStyle, timeStyle, null, null); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
public void testGetDateTimeInstanceWithLocale() { [EOL] Locale locale = Locale.CANADA_FRENCH; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateTimeInstanceWithDefaults() { [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT); [EOL] assertNotNull(fdf); [EOL] assertEquals(FastDateFormat.SHORT, fdf.getDateStyle()); [EOL] assertEquals(FastDateFormat.SHORT, fdf.getTimeStyle()); [EOL] }
public void testGetDateTimeInstanceWithTimeZone() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.MEDIUM, FastDateFormat.LONG, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetDateTimeInstanceWithTimeZoneAndLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.JAPAN; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyleTimeZone() { [EOL] TimeZone timeZone = TimeZone.getDefault(); [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, timeZone); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyle() { [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT); [EOL] assertNotNull(fdf); [EOL] assertEquals(Locale.getDefault(), fdf.getLocale()); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyleLocale() { [EOL] Locale locale = Locale.CANADA_FRENCH; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.MEDIUM, FastDateFormat.LONG, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public void testGetDateTimeInstanceWithDateStyleTimeStyleTimeZoneLocale() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] Locale locale = Locale.JAPAN; [EOL] FastDateFormat fdf = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, timeZone, locale); [EOL] assertNotNull(fdf); [EOL] assertEquals(timeZone, fdf.getTimeZone()); [EOL] assertEquals(locale, fdf.getLocale()); [EOL] }
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) { [EOL] return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
public String format(final long millis) { [EOL] return printer.format(millis); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] }; [EOL] }
@Override [EOL] public String format(final Date date) { [EOL] return printer.format(date); [EOL] } [EOL] protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getInstance(); [EOL] public static FastDateFormat getInstance(final String pattern); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); [EOL] public static FastDateFormat getInstance(final String pattern, final Locale locale); [EOL] public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style); [EOL] public static FastDateFormat getDateInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style); [EOL] public static FastDateFormat getTimeInstance(final int style, final Locale locale); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); [EOL] public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); [EOL] public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); [EOL] public String format(final long millis); [EOL] public String format(final Date date); [EOL] public String format(final Calendar calendar); [EOL] public StringBuffer format(final long millis, final StringBuffer buf); [EOL] public StringBuffer format(final Date date, final StringBuffer buf); [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf); [EOL] public Date parse(final String source) throws ParseException; [EOL] public Date parse(final String source, final ParsePosition pos); [EOL] public Object parseObject(final String source, final ParsePosition pos); [EOL] public String getPattern(); [EOL] public TimeZone getTimeZone(); [EOL] public Locale getLocale(); [EOL] public int getMaxLengthEstimate(); [EOL] public boolean equals(final Object obj); [EOL] public int hashCode(); [EOL] public String toString(); [EOL] protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); [EOL] long serialVersionUID=2L; [EOL] int FULL=DateFormat.FULL; [EOL] int LONG=DateFormat.LONG; [EOL] int MEDIUM=DateFormat.MEDIUM; [EOL] int SHORT=DateFormat.SHORT; [EOL] FormatCache<FastDateFormat> cache=new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] } [EOL] };
@Override [EOL] public String format(final Calendar calendar) { [EOL] return printer.format(calendar); [EOL] } protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale); protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getInstance(); public static FastDateFormat getInstance(final String pattern); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone); public static FastDateFormat getInstance(final String pattern, final Locale locale); public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateInstance(final int style); public static FastDateFormat getDateInstance(final int style, final Locale locale); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone); public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getTimeInstance(final int style); public static FastDateFormat getTimeInstance(final int style, final Locale locale); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone); public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone); public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale); public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos); public String format(final long millis); public String format(final Date date); public String format(final Calendar calendar); public StringBuffer format(final long millis, final StringBuffer buf); public StringBuffer format(final Date date, final StringBuffer buf); public StringBuffer format(final Calendar calendar, final StringBuffer buf); public Date parse(final String source) throws ParseException; public Date parse(final String source, final ParsePosition pos); public Object parseObject(final String source, final ParsePosition pos); public String getPattern(); public TimeZone getTimeZone(); public Locale getLocale(); public int getMaxLengthEstimate(); public boolean equals(final Object obj); public int hashCode(); public String toString(); protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf); long serialVersionUID=Optional[2L]; int FULL=Optional[DateFormat.FULL]; int LONG=Optional[DateFormat.LONG]; int MEDIUM=Optional[DateFormat.MEDIUM]; int SHORT=Optional[DateFormat.SHORT]; FormatCache<FastDateFormat> cache=Optional[new FormatCache<FastDateFormat>() { [EOL] @Override [EOL] protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL] return new FastDateFormat(pattern, timeZone, locale); [EOL] } [EOL] }];
private static boolean getJavaVersionMatches(final String versionPrefix) { [EOL] return isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix); [EOL] }
public void testGetOSMatches_NullPrefixes() { [EOL] boolean result = getOSMatches(null, null); [EOL] assertFalse(result); [EOL] }
public void testGetOSMatches_EmptyPrefixes() { [EOL] boolean result = getOSMatches("", ""); [EOL] assertFalse(result); [EOL] }
public void testGetOSMatches_ValidPrefixes() { [EOL] String osNamePrefix = System.getProperty("os.name").substring(0, 3); [EOL] String osVersionPrefix = System.getProperty("os.version").substring(0, 3); [EOL] boolean result = getOSMatches(osNamePrefix, osVersionPrefix); [EOL] assertTrue(result); [EOL] }
private static boolean getOSMatchesName(final String osNamePrefix) { [EOL] return isOSNameMatch(OS_NAME, osNamePrefix); [EOL] }
public void testGetSystemPropertyWithValidProperty() { [EOL] final String propertyName = "java.version"; [EOL] final String propertyValue = getSystemProperty(propertyName); [EOL] assertNotNull(propertyValue); [EOL] } [EOL] public void testGetSystemPropertyWithInvalidProperty() { [EOL] final String propertyName = "invalid.property"; [EOL] final String propertyValue = getSystemProperty(propertyName); [EOL] assertNull(propertyValue); [EOL] } [EOL] public void testGetSystemPropertyWithSecurityException() { [EOL] final String propertyName = "java.version"; [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm.getName().equals("getProperty." + propertyName)) { [EOL] throw new SecurityException("Access denied!"); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] final String propertyValue = getSystemProperty(propertyName); [EOL] assertNull(propertyValue); [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset the security manager [EOL] } [EOL] }
public void testIsJavaAwtHeadlessWhenJavaAwtHeadlessIsNull() { [EOL] System.clearProperty("java.awt.headless"); [EOL] boolean result = isJavaAwtHeadless(); [EOL] assertFalse(result); [EOL] }
public void testIsJavaAwtHeadlessWhenJavaAwtHeadlessIsTrue() { [EOL] System.setProperty("java.awt.headless", "true"); [EOL] boolean result = isJavaAwtHeadless(); [EOL] assertTrue(result); [EOL] }
public void testIsJavaAwtHeadlessWhenJavaAwtHeadlessIsFalse() { [EOL] System.setProperty("java.awt.headless", "false"); [EOL] boolean result = isJavaAwtHeadless(); [EOL] assertFalse(result); [EOL] }
public void testIsJavaVersionAtLeastWithNull() { [EOL] boolean result = StringUtils.isJavaVersionAtLeast(null); [EOL] assertFalse(result); [EOL] }
public void testIsJavaVersionAtLeastWithLowerVersion() { [EOL] boolean result = StringUtils.isJavaVersionAtLeast(JavaVersion.JAVA_0_9); [EOL] assertTrue(result); [EOL] }
public void testIsJavaVersionAtLeastWithEqualVersion() { [EOL] boolean result = StringUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8); [EOL] assertTrue(result); [EOL] }
public void testIsJavaVersionAtLeastWithHigherVersion() { [EOL] boolean result = StringUtils.isJavaVersionAtLeast(JavaVersion.JAVA_11); [EOL] assertFalse(result); [EOL] }
public void testIsJavaVersionMatch_NullVersion() { [EOL] boolean result = isJavaVersionMatch(null, "1.8"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsJavaVersionMatch_EmptyVersion() { [EOL] boolean result = isJavaVersionMatch("", "1.8"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsJavaVersionMatch_ValidVersionMatch() { [EOL] boolean result = isJavaVersionMatch("1.8.0_144", "1.8"); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsJavaVersionMatch_ValidVersionNoMatch() { [EOL] boolean result = isJavaVersionMatch("1.7.0_80", "1.8"); [EOL] assertFalse(result); [EOL] } [EOL] public void testIsJavaVersionMatch_EmptyVersionPrefix() { [EOL] boolean result = isJavaVersionMatch("1.8.0_144", ""); [EOL] assertTrue(result); [EOL] } [EOL] public void testIsJavaVersionMatch_NullVersionPrefix() { [EOL] boolean result = isJavaVersionMatch("1.8.0_144", null); [EOL] assertFalse(result); // This will throw a NullPointerException, indicating a potential bug in the method [EOL] }
It seems there is a misunderstanding. The constructor `public FieldUtils() { super(); }` is a default constructor that does not contain any logic other than calling the superclass constructor. In Java, if no other constructors are defined, this constructor is provided by the compiler by default. Since there is no conditional logic or executable lines of code that could result in different outcomes, there is no meaningful line coverage to be achieved by writing unit tests for this constructor. [EOL] Unit tests are generally written to test the behavior of methods that contain logic. Constructors that only call `super()` and do not perform any other actions typically do not need explicit unit tests. Therefore, no unit test case methods are necessary for the provided input text.
public void testGetFieldWithValidClassAndFieldName() { [EOL] Field field = FieldUtils.getField(String.class, "CASE_INSENSITIVE_ORDER"); [EOL] assertNotNull(field); [EOL] }
public void testGetFieldWithInvalidFieldName() { [EOL] Field field = FieldUtils.getField(String.class, "nonExistentField"); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.getField(null, "anyField"); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldWithEmptyFieldName() { [EOL] try { [EOL] FieldUtils.getField(String.class, ""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.getField(String.class, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.getField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The class must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.getField(String.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field name must not be null", e.getMessage()); [EOL] } [EOL] }
public void testGetFieldWithExistingPublicField() { [EOL] Field field = FieldUtils.getField(String.class, "CASE_INSENSITIVE_ORDER", false); [EOL] assertNotNull(field); [EOL] assertEquals("CASE_INSENSITIVE_ORDER", field.getName()); [EOL] }
public void testGetFieldWithExistingPrivateFieldAndForceAccess() { [EOL] Field field = FieldUtils.getField(String.class, "value", true); [EOL] assertNotNull(field); [EOL] assertEquals("value", field.getName()); [EOL] }
public void testGetFieldWithExistingPrivateFieldWithoutForceAccess() { [EOL] Field field = FieldUtils.getField(String.class, "value", false); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithNonExistingField() { [EOL] Field field = FieldUtils.getField(String.class, "nonExistingField", true); [EOL] assertNull(field); [EOL] }
public void testGetFieldWithAmbiguousFieldInInterfaces() { [EOL] try { [EOL] FieldUtils.getField(AmbiguousFieldInterface.class, "AMBIGUOUS_FIELD", false); [EOL] fail("Should have thrown IllegalArgumentException for ambiguous field"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Reference to field AMBIGUOUS_FIELD is ambiguous relative to")); [EOL] } [EOL] }
public void testGetDeclaredField_ClassIsNull() { [EOL] try { [EOL] ClassUtils.getDeclaredField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testGetDeclaredField_FieldNameIsNull() { [EOL] try { [EOL] ClassUtils.getDeclaredField(Object.class, null, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testGetDeclaredField_FieldExistsAccessible() throws Exception { [EOL] Field field = ClassUtils.getDeclaredField(TestClass.class, "publicField", false); [EOL] assertNotNull(field); [EOL] assertEquals("publicField", field.getName()); [EOL] } [EOL] public void testGetDeclaredField_FieldExistsForceAccess() throws Exception { [EOL] Field field = ClassUtils.getDeclaredField(TestClass.class, "privateField", true); [EOL] assertNotNull(field); [EOL] assertEquals("privateField", field.getName()); [EOL] } [EOL] public void testGetDeclaredField_FieldDoesNotExist() { [EOL] Field field = ClassUtils.getDeclaredField(TestClass.class, "nonExistentField", true); [EOL] assertNull(field); [EOL] }
class TestClass { [EOL] public String publicField; [EOL] private String privateField; [EOL] }
public void testReadStaticFieldWithAccessibleField() throws Exception { [EOL] Field field = SomeClass.class.getField("staticField"); [EOL] Object result = FieldUtils.readStaticField(field); [EOL] assertEquals("Expected value from staticField", SomeClass.staticField, result); [EOL] }
public void testReadStaticFieldWithInaccessibleField() throws Exception { [EOL] Field field = SomeClass.class.getDeclaredField("privateStaticField"); [EOL] try { [EOL] FieldUtils.readStaticField(field); [EOL] fail("Should throw IllegalAccessException for private field"); [EOL] } catch (IllegalAccessException expected) { [EOL] } [EOL] }
public void testReadStaticField_NullField_ThrowsIllegalArgumentException() { [EOL] try { [EOL] ReflectionUtils.readStaticField(null, true); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testReadStaticField_NonStaticField_ThrowsIllegalArgumentException() throws NoSuchFieldException { [EOL] class TestClass { [EOL] @SuppressWarnings("unused") [EOL] private int nonStaticField = 0; [EOL] } [EOL] Field nonStaticField = TestClass.class.getDeclaredField("nonStaticField"); [EOL] try { [EOL] ReflectionUtils.readStaticField(nonStaticField, true); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("is not static")); [EOL] } [EOL] }
public void testReadStaticField_StaticField_ReturnsValue() throws NoSuchFieldException, IllegalAccessException { [EOL] class TestClass { [EOL] @SuppressWarnings("unused") [EOL] private static int staticField = 123; [EOL] } [EOL] Field staticField = TestClass.class.getDeclaredField("staticField"); [EOL] Object result = ReflectionUtils.readStaticField(staticField, true); [EOL] assertEquals(123, result); [EOL] }
public void testReadStaticFieldWithValidClassAndFieldName() throws IllegalAccessException { [EOL] final String fieldName = "CASE_INSENSITIVE_ORDER"; [EOL] Object result = ClassUtils.readStaticField(String.class, fieldName); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Comparator); [EOL] }
public void testReadStaticFieldWithInvalidFieldName() { [EOL] final String fieldName = "nonExistingField"; [EOL] try { [EOL] ClassUtils.readStaticField(String.class, fieldName); [EOL] fail("Should have thrown NoSuchFieldException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testReadStaticFieldWithNullClass() { [EOL] final String fieldName = "CASE_INSENSITIVE_ORDER"; [EOL] try { [EOL] ClassUtils.readStaticField(null, fieldName); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReadStaticFieldWithNullFieldName() { [EOL] try { [EOL] ClassUtils.readStaticField(String.class, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testReadStaticFieldWithExistingFieldAndNoForceAccess() throws IllegalAccessException { [EOL] final Object expectedValue = SomeClassWithFields.STATIC_FIELD; [EOL] final Object actualValue = FieldUtils.readStaticField(SomeClassWithFields.class, "STATIC_FIELD", false); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testReadStaticFieldWithNonExistingField() { [EOL] try { [EOL] FieldUtils.readStaticField(SomeClassWithFields.class, "NON_EXISTING_FIELD", false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown"); [EOL] } [EOL] } [EOL] public void testReadStaticFieldWithExistingFieldAndForceAccess() throws IllegalAccessException { [EOL] final Object expectedValue = SomeClassWithFields.PRIVATE_STATIC_FIELD; [EOL] final Object actualValue = FieldUtils.readStaticField(SomeClassWithFields.class, "PRIVATE_STATIC_FIELD", true); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testReadStaticFieldWithNullClass() { [EOL] try { [EOL] FieldUtils.readStaticField(null, "ANY_FIELD", false); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown"); [EOL] } [EOL] }
public void testReadStaticFieldWithNullFieldName() { [EOL] try { [EOL] FieldUtils.readStaticField(SomeClassWithFields.class, null, false); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown"); [EOL] } [EOL] }
public void testReadDeclaredStaticFieldWithValidInput() throws IllegalAccessException { [EOL] final String fieldName = "CONSTANT"; // Assume CONSTANT is a valid static field in SomeClass [EOL] Object result = SomeClass.readDeclaredStaticField(SomeClass.class, fieldName); [EOL] assertNotNull(result); [EOL] assertEquals(SomeClass.CONSTANT, result); [EOL] }
public void testReadDeclaredStaticFieldWithInvalidFieldName() { [EOL] final String fieldName = "nonExistentField"; [EOL] try { [EOL] SomeClass.readDeclaredStaticField(SomeClass.class, fieldName); [EOL] fail("Should have thrown NoSuchFieldException"); [EOL] } catch (NoSuchFieldException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException was not expected"); [EOL] } [EOL] }
public void testReadDeclaredStaticFieldWithNullClass() { [EOL] final String fieldName = "CONSTANT"; [EOL] try { [EOL] SomeClass.readDeclaredStaticField(null, fieldName); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException was not expected"); [EOL] } [EOL] }
public void testReadDeclaredStaticFieldWithNullFieldName() { [EOL] try { [EOL] SomeClass.readDeclaredStaticField(SomeClass.class, null); [EOL] fail("Should have thrown NoSuchFieldException"); [EOL] } catch (NoSuchFieldException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException was not expected"); [EOL] } [EOL] }
public void testReadFieldWithNullField() throws IllegalAccessException { [EOL] try { [EOL] Object result = FieldUtils.readField(null, new Object()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testReadFieldWithNullTarget() throws IllegalAccessException { [EOL] Field field = String.class.getField("CASE_INSENSITIVE_ORDER"); [EOL] Object result = FieldUtils.readField(field, null); [EOL] assertNotNull(result); [EOL] } [EOL] public void testReadFieldWithValidFieldAndTarget() throws IllegalAccessException { [EOL] Field field = String.class.getField("CASE_INSENSITIVE_ORDER"); [EOL] Object target = "test"; [EOL] Object result = FieldUtils.readField(field, target); [EOL] assertNotNull(result); [EOL] } [EOL] public void testReadFieldWithInaccessibleField() throws IllegalAccessException { [EOL] Field field = System.class.getDeclaredField("out"); [EOL] try { [EOL] Object result = FieldUtils.readField(field, null); [EOL] fail("Should have thrown IllegalAccessException"); [EOL] } catch (IllegalAccessException e) { [EOL] } [EOL] }
public void testReadFieldWithNullField() { [EOL] try { [EOL] FieldUtils.readField(null, new Object(), true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The field must not be null", e.getMessage()); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadFieldWithInaccessibleField() throws NoSuchFieldException { [EOL] class TestClass { [EOL] private String privateField = "private value"; [EOL] } [EOL] TestClass testInstance = new TestClass(); [EOL] Field privateField = TestClass.class.getDeclaredField("privateField"); [EOL] try { [EOL] Object fieldValue = FieldUtils.readField(privateField, testInstance, true); [EOL] assertEquals("private value", fieldValue); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadFieldWithoutForceAccess() throws NoSuchFieldException { [EOL] class TestClass { [EOL] public String publicField = "public value"; [EOL] } [EOL] TestClass testInstance = new TestClass(); [EOL] Field publicField = TestClass.class.getField("publicField"); [EOL] try { [EOL] Object fieldValue = FieldUtils.readField(publicField, testInstance, false); [EOL] assertEquals("public value", fieldValue); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Should not have thrown IllegalAccessException"); [EOL] } [EOL] }
public void testReadDeclaredFieldWithValidFieldName() throws IllegalAccessException { [EOL] final TestClass testObj = new TestClass(); [EOL] final String fieldName = "privateField"; [EOL] final Object fieldValue = FieldUtils.readDeclaredField(testObj, fieldName); [EOL] assertEquals("Value should match the actual private field value", testObj.getPrivateFieldValue(), fieldValue); [EOL] }
public void testReadDeclaredFieldWithInvalidFieldName() { [EOL] final TestClass testObj = new TestClass(); [EOL] final String fieldName = "nonExistentField"; [EOL] try { [EOL] FieldUtils.readDeclaredField(testObj, fieldName); [EOL] fail("Should have thrown NoSuchFieldException"); [EOL] } catch (NoSuchFieldException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for non-existent fields"); [EOL] } [EOL] }
public void testReadDeclaredFieldWithNullTarget() { [EOL] final String fieldName = "anyField"; [EOL] try { [EOL] FieldUtils.readDeclaredField(null, fieldName); [EOL] fail("Should have thrown IllegalArgumentException for null target"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (IllegalAccessException e) { [EOL] fail("IllegalAccessException should not be thrown for null target"); [EOL] } [EOL] }
public void testReadDeclaredFieldWithNullFieldName() throws IllegalAccessException { [EOL] final TestClass testObj = new TestClass(); [EOL] try { [EOL] FieldUtils.readDeclaredField(testObj, null); [EOL] fail("Should have thrown IllegalArgumentException for null field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadDeclaredFieldWithEmptyFieldName() throws IllegalAccessException { [EOL] final TestClass testObj = new TestClass(); [EOL] final String fieldName = ""; [EOL] try { [EOL] FieldUtils.readDeclaredField(testObj, fieldName); [EOL] fail("Should have thrown IllegalArgumentException for empty field name"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadDeclaredFieldWithNullTarget() { [EOL] try { [EOL] Object result = FieldUtils.readDeclaredField(null, "fieldName", true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("target object must not be null", e.getMessage()); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Unexpected IllegalAccessException"); [EOL] } [EOL] }
public void testReadDeclaredFieldWithValidTargetAndFieldName() throws IllegalAccessException { [EOL] class TestClass { [EOL] private String privateField = "private value"; [EOL] } [EOL] TestClass testObj = new TestClass(); [EOL] Object result = FieldUtils.readDeclaredField(testObj, "privateField", true); [EOL] assertEquals("private value", result); [EOL] }
public void testReadDeclaredFieldWithValidTargetAndNonExistingFieldName() { [EOL] class TestClass { [EOL] private String privateField = "private value"; [EOL] } [EOL] TestClass testObj = new TestClass(); [EOL] try { [EOL] Object result = FieldUtils.readDeclaredField(testObj, "nonExistingField", true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Cannot locate declared field")); [EOL] } catch (IllegalAccessException e) { [EOL] fail("Unexpected IllegalAccessException"); [EOL] } [EOL] }
public void testGetInstance_NullInput() { [EOL] CharSet result = CharSet.getInstance((String[]) null); [EOL] assertNull(result); [EOL] }
public void testGetInstance_SingleCommonSet() { [EOL] CharSet result = CharSet.getInstance("a"); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_MultipleSets() { [EOL] CharSet result = CharSet.getInstance("a", "b"); [EOL] assertNotNull(result); [EOL] }
public void testHashCode() { [EOL] Set<String> set = new HashSet<>(); [EOL] set.add("element1"); [EOL] set.add("element2"); [EOL] YourClass instance = new YourClass(set); [EOL] int expectedHashCode = 89 + set.hashCode(); [EOL] assertEquals(expectedHashCode, instance.hashCode()); [EOL] }
public void testContextedExceptionWithMessage() { [EOL] String message = "Error message"; [EOL] ContextedException exception = new ContextedException(message); [EOL] assertEquals(message, exception.getMessage()); [EOL] assertNotNull(exception.getExceptionContext()); [EOL] }
public void testContextedExceptionWithMessageAndCauseAndNullContext() { [EOL] String message = "Test message"; [EOL] Throwable cause = new Exception("Test cause"); [EOL] ContextedException exception = new ContextedException(message, cause, null); [EOL] assertEquals("Context should match the message", message, exception.getMessage()); [EOL] assertEquals("Cause should match the provided cause", cause, exception.getCause()); [EOL] assertNotNull("Context should not be null", exception.getContext()); [EOL] }
public void testContextedExceptionWithMessageAndCauseAndNonNullContext() { [EOL] String message = "Test message"; [EOL] Throwable cause = new Exception("Test cause"); [EOL] ExceptionContext context = new DefaultExceptionContext(); [EOL] ContextedException exception = new ContextedException(message, cause, context); [EOL] assertEquals("Context should match the message", message, exception.getMessage()); [EOL] assertEquals("Cause should match the provided cause", cause, exception.getCause()); [EOL] assertEquals("Context should be the one that was passed in", context, exception.getContext()); [EOL] }
public void testSetContextValueWithNullLabel() { [EOL] ContextedException exception = new ContextedException(); [EOL] exception.setContextValue(null, "value"); [EOL] assertNull(exception.getContextValue(null)); [EOL] }
public void testSetContextValueWithNonNullLabel() { [EOL] ContextedException exception = new ContextedException(); [EOL] exception.setContextValue("label", "value"); [EOL] assertEquals("value", exception.getContextValue("label")); [EOL] }
public String getFormattedExceptionMessage(String msg) { [EOL] if (msg == null) { [EOL] return "Exception without message"; [EOL] } else { [EOL] return "Formatted message: " + msg; [EOL] } [EOL] } [EOL] public void testGetMessageReturnsDefaultMessageWhenSuperMessageIsNull() { [EOL] Throwable throwable = new Throwable(null) { [EOL] @Override [EOL] public String getMessage() { [EOL] return null; [EOL] } [EOL] }; [EOL] CustomException customException = new CustomException(throwable); [EOL] String message = customException.getMessage(); [EOL] assertEquals("Exception without message", message); [EOL] }
public void testGetMessageReturnsFormattedMessageWhenSuperMessageIsNotNull() { [EOL] final String superMessage = "Super exception message"; [EOL] Throwable throwable = new Throwable(superMessage) { [EOL] @Override [EOL] public String getMessage() { [EOL] return superMessage; [EOL] } [EOL] }; [EOL] CustomException customException = new CustomException(throwable); [EOL] String message = customException.getMessage(); [EOL] assertEquals("Formatted message: " + superMessage, message); [EOL] }
public void testGetRawMessage_NullSuperMessage() { [EOL] Exception e = new Exception(null); [EOL] Throwable t = new Throwable(e); [EOL] assertNull(t.getRawMessage()); [EOL] }
public void testGetRawMessage_NonNullSuperMessage() { [EOL] String expectedMessage = "Error Message"; [EOL] Exception e = new Exception(expectedMessage); [EOL] Throwable t = new Throwable(e); [EOL] assertEquals(expectedMessage, t.getRawMessage()); [EOL] }
public void testGetFormattedExceptionMessageWithNullBaseMessage() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] Throwable testException = new ThrowableWithExceptionContext(exceptionContext); [EOL] String result = testException.getFormattedExceptionMessage(null); [EOL] assertNotNull(result); [EOL] assertTrue(result.contains("Exception Context")); [EOL] }
public void testGetFormattedExceptionMessageWithNonNullBaseMessage() { [EOL] ExceptionContext exceptionContext = new DefaultExceptionContext(); [EOL] exceptionContext.addContextValue("key1", "value1"); [EOL] Throwable testException = new ThrowableWithExceptionContext(exceptionContext); [EOL] String baseMessage = "Base Message"; [EOL] String result = testException.getFormattedExceptionMessage(baseMessage); [EOL] assertNotNull(result); [EOL] assertTrue(result.startsWith(baseMessage)); [EOL] assertTrue(result.contains("key1=value1")); [EOL] }
public void testCallableBackgroundInitializerWithValidArguments() { [EOL] Callable<Object> callable = Executors.callable(new Runnable() { [EOL] @Override [EOL] public void run() { [EOL] } [EOL] }); [EOL] ExecutorService executorService = Executors.newSingleThreadExecutor(); [EOL] CallableBackgroundInitializer<Object> initializer = new CallableBackgroundInitializer<>(callable, executorService); [EOL] assertNotNull(initializer.getCallable()); [EOL] assertNotNull(initializer.getExternalExecutor()); [EOL] }
public void testCallableBackgroundInitializerWithNullCallable() { [EOL] ExecutorService executorService = Executors.newSingleThreadExecutor(); [EOL] try { [EOL] new CallableBackgroundInitializer<>(null, executorService); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testCallableBackgroundInitializerWithNullExecutor() { [EOL] Callable<Object> callable = Executors.callable(new Runnable() { [EOL] @Override [EOL] public void run() { [EOL] } [EOL] }); [EOL] try { [EOL] new CallableBackgroundInitializer<>(callable, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testCheckCallableWithNonNull() throws Exception { [EOL] Callable<String> callable = () -> "Test"; [EOL] checkCallable(callable); [EOL] }
public void testCheckCallableWithNull() { [EOL] try { [EOL] checkCallable(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Callable must not be null!", e.getMessage()); [EOL] } [EOL] }
public void testReflectionAppendWithRegisteredObject() { [EOL] final Object object = new Object(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] HashCodeBuilder.register(object); [EOL] try { [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected hash code to remain unchanged", 17, builder.toHashCode()); [EOL] } finally { [EOL] HashCodeBuilder.unregister(object); [EOL] } [EOL] }
public void testReflectionAppendWithUnregisteredObject() { [EOL] final Object object = new Object(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertNotEquals("Expected hash code to change", 17, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithExcludedFields() { [EOL] final Object object = new Object(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = {"fieldToExclude"}; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected hash code to remain unchanged", 17, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithTransientFields() { [EOL] final ObjectWithTransientField object = new ObjectWithTransientField(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = true; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertNotEquals("Expected hash code to change", 17, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithStaticFields() { [EOL] final ObjectWithStaticField object = new ObjectWithStaticField(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] assertEquals("Expected hash code to remain unchanged", 17, builder.toHashCode()); [EOL] }
public void testReflectionAppendWithIllegalAccess() { [EOL] final ObjectWithPrivateField object = new ObjectWithPrivateField(); [EOL] final Class<?> clazz = object.getClass(); [EOL] final HashCodeBuilder builder = new HashCodeBuilder(); [EOL] final boolean useTransients = false; [EOL] final String[] excludeFields = new String[0]; [EOL] try { [EOL] reflectionAppend(object, clazz, builder, useTransients, excludeFields); [EOL] fail("Expected InternalError due to IllegalAccessException"); [EOL] } catch (InternalError e) { [EOL] assertEquals("Unexpected IllegalAccessException", e.getMessage()); [EOL] } [EOL] }
public void testReflectionHashCodeWithNullObject() { [EOL] int hashCode = reflectionHashCode(null); [EOL] assertEquals(17, hashCode); [EOL] }
public void testReflectionHashCodeWithNonNullObjectExcludeNull() { [EOL] Object object = new Object(); [EOL] int hashCode = reflectionHashCode(object, (String[]) null); [EOL] assertNotEquals(17, hashCode); [EOL] }
public void testReflectionHashCodeWithNonNullObjectExcludeFields() { [EOL] Object object = new Object(); [EOL] int hashCode1 = reflectionHashCode(object); [EOL] int hashCode2 = reflectionHashCode(object, "field1", "field2"); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testAppendChar() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] char testChar = 'a'; [EOL] int expectedValue = 17 * 37 + testChar; [EOL] builder.append(testChar); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendCharMaxValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] char testChar = Character.MAX_VALUE; [EOL] int expectedValue = 17 * 37 + testChar; [EOL] builder.append(testChar); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendCharMinValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] char testChar = Character.MIN_VALUE; [EOL] int expectedValue = 17 * 37 + testChar; [EOL] builder.append(testChar); [EOL] assertEquals(expectedValue, builder.toHashCode()); [EOL] }
public void testAppendWithNullCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = null; [EOL] HashCodeBuilder result = builder.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17 * 37, result.toHashCode()); [EOL] }
public void testAppendWithEmptyCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = new char[0]; [EOL] HashCodeBuilder result = builder.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(17, result.toHashCode()); [EOL] }
public void testAppendWithNonEmptyCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = new char[]{'a', 'b', 'c'}; [EOL] HashCodeBuilder result = builder.append(array); [EOL] assertNotNull(result); [EOL] int expectedHashCode = calculateExpectedHashCodeForCharArray(new char[]{'a', 'b', 'c'}); [EOL] assertEquals(expectedHashCode, result.toHashCode()); [EOL] } [EOL] private int calculateExpectedHashCodeForCharArray(char[] array) { [EOL] int total = 17; [EOL] int constant = 37; [EOL] for (char element : array) { [EOL] total = total * constant + (int) element; [EOL] } [EOL] return total; [EOL] }
public void testAppendInt() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] int value = 123; [EOL] HashCodeBuilder result = builder.append(value); [EOL] int expectedTotal = 17 * 37 + value; [EOL] assertEquals(expectedTotal, result.toHashCode()); [EOL] }
public void testAppendIntZero() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] int value = 0; [EOL] HashCodeBuilder result = builder.append(value); [EOL] int expectedTotal = 17 * 37 + value; [EOL] assertEquals(expectedTotal, result.toHashCode()); [EOL] }
public void testAppendIntNegative() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] int value = -1; [EOL] HashCodeBuilder result = builder.append(value); [EOL] int expectedTotal = 17 * 37 + value; [EOL] assertEquals(expectedTotal, result.toHashCode()); [EOL] }
public void testAppendWithNullArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int[] array = null; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(31, result.toHashCode()); [EOL] }
public void testAppendWithEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int[] array = new int[0]; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.toHashCode()); [EOL] }
public void testAppendWithNonEmptyArray() { [EOL] HashCodeBuilder hcb = new HashCodeBuilder(); [EOL] int[] array = {1, 2, 3}; [EOL] HashCodeBuilder result = hcb.append(array); [EOL] assertNotNull(result); [EOL] assertEquals(30856, result.toHashCode()); [EOL] }
public void testAppendWithNull() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append((Object) null); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithLongArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] long[] array = {1L, 2L, 3L}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithIntArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] int[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithCharArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] char[] array = {'a', 'b', 'c'}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithByteArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] byte[] array = {1, 2, 3}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithDoubleArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithFloatArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] float[] array = {1.0f, 2.0f, 3.0f}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithBooleanArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] boolean[] array = {true, false, true}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithObjectArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object[] array = {new Object(), new Object(), new Object()}; [EOL] builder.append(array); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(array); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendWithNonArrayObject() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] Object obj = new Object(); [EOL] builder.append(obj); [EOL] int initialTotal = builder.hashCode(); [EOL] builder.append(obj); [EOL] assertNotEquals(initialTotal, builder.hashCode()); [EOL] }
public void testAppendShortMaxValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Short.MAX_VALUE); [EOL] assertEquals(17 * 37 + Short.MAX_VALUE, builder.toHashCode()); [EOL] } [EOL] public void testAppendShortMinValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append(Short.MIN_VALUE); [EOL] assertEquals(17 * 37 + Short.MIN_VALUE, builder.toHashCode()); [EOL] } [EOL] public void testAppendShortZero() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] builder.append((short) 0); [EOL] assertEquals(17 * 37, builder.toHashCode()); [EOL] } [EOL] public void testAppendShortArbitraryValue() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(17, 37); [EOL] short arbitraryValue = 123; [EOL] builder.append(arbitraryValue); [EOL] assertEquals(17 * 37 + arbitraryValue, builder.toHashCode()); [EOL] }
public void testAppendWithNullShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = null; [EOL] HashCodeBuilder result = builder.append(array); [EOL] assertNotNull(result); [EOL] }
public void testAppendWithEmptyShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = new short[0]; [EOL] HashCodeBuilder result = builder.append(array); [EOL] assertNotNull(result); [EOL] }
public void testAppendWithNonEmptyShortArray() { [EOL] HashCodeBuilder builder = new HashCodeBuilder(); [EOL] short[] array = {1, 2, 3}; [EOL] HashCodeBuilder result = builder.append(array); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithNullInputStream() { [EOL] try { [EOL] SerializationUtils.deserialize(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The InputStream must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithValidInputStream() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] when(objectInputStream.readObject()).thenReturn("testString"); [EOL] InputStream inputStream = spy(byteArrayInputStream); [EOL] doReturn(objectInputStream).when(inputStream).read(); [EOL] String result = SerializationUtils.deserialize(inputStream); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeWithClassCastException() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] when(objectInputStream.readObject()).thenThrow(new ClassCastException("ClassCastException")); [EOL] InputStream inputStream = spy(byteArrayInputStream); [EOL] doReturn(objectInputStream).when(inputStream).read(); [EOL] try { [EOL] SerializationUtils.deserialize(inputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof ClassCastException); [EOL] } [EOL] }
public void testDeserializeWithClassNotFoundException() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] when(objectInputStream.readObject()).thenThrow(new ClassNotFoundException("ClassNotFoundException")); [EOL] InputStream inputStream = spy(byteArrayInputStream); [EOL] doReturn(objectInputStream).when(inputStream).read(); [EOL] try { [EOL] SerializationUtils.deserialize(inputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof ClassNotFoundException); [EOL] } [EOL] }
public void testDeserializeWithIOExceptionOnReadObject() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] when(objectInputStream.readObject()).thenThrow(new IOException("IOException")); [EOL] InputStream inputStream = spy(byteArrayInputStream); [EOL] doReturn(objectInputStream).when(inputStream).read(); [EOL] try { [EOL] SerializationUtils.deserialize(inputStream); [EOL] fail("Expected SerializationException"); [EOL] } catch (SerializationException ex) { [EOL] assertTrue(ex.getCause() instanceof IOException); [EOL] } [EOL] }
public void testDeserializeWithIOExceptionOnClose() throws IOException, ClassNotFoundException { [EOL] ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[0]); [EOL] ObjectInputStream objectInputStream = mock(ObjectInputStream.class); [EOL] when(objectInputStream.readObject()).thenReturn("testString"); [EOL] doThrow(new IOException("IOException")).when(objectInputStream).close(); [EOL] InputStream inputStream = spy(byteArrayInputStream); [EOL] doReturn(objectInputStream).when(inputStream).read(); [EOL] String result = SerializationUtils.deserialize(inputStream); [EOL] assertEquals("testString", result); [EOL] }
public void testToChar_EmptyString() { [EOL] char result = StringUtils.toChar("", 'a'); [EOL] assertEquals('a', result); [EOL] }
public void testToChar_NullString() { [EOL] char result = StringUtils.toChar(null, 'a'); [EOL] assertEquals('a', result); [EOL] }
public void testToChar_ValidString() { [EOL] char result = StringUtils.toChar("b", 'a'); [EOL] assertEquals('b', result); [EOL] }
public void testToString_withAsciiChar() { [EOL] char ch = 'A'; // ASCII character [EOL] String result = StringUtils.toString(ch); [EOL] assertEquals("A", result); [EOL] }
public void testToString_withNonAsciiChar() { [EOL] char ch = '\u20AC'; // Non-ASCII character (Euro sign) [EOL] String result = StringUtils.toString(ch); [EOL] assertEquals("\u20AC", result); [EOL] }
public void testToStringWithNullCharacter() { [EOL] Character ch = null; [EOL] String result = StringUtils.toString(ch); [EOL] assertNull(result); [EOL] }
public void testToStringWithNonNullCharacter() { [EOL] Character ch = 'a'; [EOL] String result = StringUtils.toString(ch); [EOL] assertEquals("a", result); [EOL] }
public void testIsAsciiControl_LessThan32() { [EOL] assertTrue(StringUtils.isAsciiControl((char) 0)); [EOL] assertTrue(StringUtils.isAsciiControl((char) 1)); [EOL] assertTrue(StringUtils.isAsciiControl((char) 31)); [EOL] }
public void testIsAsciiControl_EqualTo127() { [EOL] assertTrue(StringUtils.isAsciiControl((char) 127)); [EOL] }
public void testIsAsciiControl_NotControl() { [EOL] assertFalse(StringUtils.isAsciiControl((char) 32)); [EOL] assertFalse(StringUtils.isAsciiControl((char) 65)); [EOL] assertFalse(StringUtils.isAsciiControl((char) 126)); [EOL] }
public void testIs_withNonNullElement() { [EOL] Comparable<Object> element = 10; [EOL] Range<Comparable<Object>> result = Range.is(element); [EOL] assertNotNull(result); [EOL] assertEquals(element, result.getMinimum()); [EOL] assertEquals(element, result.getMaximum()); [EOL] }
public void testIs_withNullElement() { [EOL] Comparable<Object> element = null; [EOL] Range<Comparable<Object>> result = Range.is(element); [EOL] assertNotNull(result); [EOL] assertNull(result.getMinimum()); [EOL] assertNull(result.getMaximum()); [EOL] }
public void testIs_withComparable() { [EOL] Range<Integer> range = Range.is(5, null); [EOL] assertTrue(range.contains(5)); [EOL] assertFalse(range.contains(4)); [EOL] assertFalse(range.contains(6)); [EOL] }
public void testIs_withComparator() { [EOL] Comparator<Integer> comparator = Integer::compare; [EOL] Range<Integer> range = Range.is(5, comparator); [EOL] assertTrue(range.contains(5)); [EOL] assertFalse(range.contains(4)); [EOL] assertFalse(range.contains(6)); [EOL] }
public T getMaximum() { [EOL] return maximum; [EOL] }
public void testIsAfter_NullElement() { [EOL] Range<Integer> range = Range.between(1, 10); [EOL] boolean result = range.isAfter(null); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_ElementBeforeRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean result = range.isAfter(3); [EOL] assertTrue(result); [EOL] }
public void testIsAfter_ElementWithinRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean result = range.isAfter(6); [EOL] assertFalse(result); [EOL] }
public void testIsAfter_ElementAfterRange() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] boolean result = range.isAfter(11); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_NullRange() { [EOL] Range<Integer> range = Range.between(1, 5); [EOL] boolean result = range.isOverlappedBy(null); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_RangeBefore() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(1, 4); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_RangeAfter() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(11, 15); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertFalse(result); [EOL] }
public void testIsOverlappedBy_RangeOverlapAtStart() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(3, 6); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeOverlapAtEnd() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(9, 12); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeInside() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(6, 9); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeContains() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(4, 11); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIsOverlappedBy_RangeExact() { [EOL] Range<Integer> range = Range.between(5, 10); [EOL] Range<Integer> otherRange = Range.between(5, 10); [EOL] boolean result = range.isOverlappedBy(otherRange); [EOL] assertTrue(result); [EOL] }
public void testIntersectionWith_NonOverlappingRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(6, 10); [EOL] try { [EOL] range1.intersectionWith(range2); [EOL] fail("Expected IllegalArgumentException for non-overlapping ranges"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIntersectionWith_EqualRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(1, 5); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] assertEquals(range1, result); [EOL] } [EOL] public void testIntersectionWith_OverlappingRanges() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(3, 7); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] Range<Integer> expected = Range.between(3, 5); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testIntersectionWith_ContainedRange() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(2, 4); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] assertEquals(range2, result); [EOL] } [EOL] public void testIntersectionWith_ContainingRange() { [EOL] Range<Integer> range1 = Range.between(1, 5); [EOL] Range<Integer> range2 = Range.between(0, 6); [EOL] Range<Integer> result = range1.intersectionWith(range2); [EOL] assertEquals(range1, result); [EOL] }
public void testHashCodeWhenHashCodeIsZero() { [EOL] Range<Integer> range = new Range<>(0, 10); [EOL] int expected = 17; [EOL] expected = 37 * expected + range.getClass().hashCode(); [EOL] expected = 37 * expected + range.getMinimum().hashCode(); [EOL] expected = 37 * expected + range.getMaximum().hashCode(); [EOL] int actual = range.hashCode(); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testHashCodeWhenHashCodeIsNonZero() { [EOL] Range<Integer> range = new Range<>(0, 10); [EOL] range.hashCode(); // This call will cache the hash code [EOL] int expected = range.hashCode(); [EOL] int actual = range.hashCode(); // This call should return the cached value [EOL] assertEquals(expected, actual); [EOL] }
public void testCompareWithEqualObjects() { [EOL] Comparable<Object> obj1 = "test"; [EOL] Object obj2 = "test"; [EOL] int result = compare(obj1, obj2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareWithGreaterFirstObject() { [EOL] Comparable<Object> obj1 = "test2"; [EOL] Object obj2 = "test1"; [EOL] int result = compare(obj1, obj2); [EOL] assertTrue(result > 0); [EOL] }
public void testCompareWithLesserFirstObject() { [EOL] Comparable<Object> obj1 = "test1"; [EOL] Object obj2 = "test2"; [EOL] int result = compare(obj1, obj2); [EOL] assertTrue(result < 0); [EOL] }
public void testToNoNullStringArray_withNonNullElements() { [EOL] Object[] array = {"apple", "banana", "cherry"}; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(3, result.length); [EOL] assertEquals("apple", result[0]); [EOL] assertEquals("banana", result[1]); [EOL] assertEquals("cherry", result[2]); [EOL] }
public void testToNoNullStringArray_withNullElements() { [EOL] Object[] array = {"apple", null, "cherry"}; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(2, result.length); [EOL] assertEquals("apple", result[0]); [EOL] assertEquals("cherry", result[1]); [EOL] }
public void testToNoNullStringArray_withAllNullElements() { [EOL] Object[] array = {null, null, null}; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(0, result.length); [EOL] }
public void testToNoNullStringArray_withEmptyArray() { [EOL] Object[] array = {}; [EOL] String[] result = StringUtils.toNoNullStringArray(array); [EOL] assertEquals(0, result.length); [EOL] }
public void testAcceptWithInnerClassField() { [EOL] Field innerClassField = MyClass.InnerClass.class.getDeclaredField("someField"); [EOL] boolean result = accept(innerClassField); [EOL] assertFalse(result); [EOL] }
public void testAcceptWithTransientFieldWhenAppendTransientsIsFalse() { [EOL] Field transientField = MyClass.class.getDeclaredField("transientField"); [EOL] setAppendTransients(false); [EOL] boolean result = accept(transientField); [EOL] assertFalse(result); [EOL] }
public void testAcceptWithTransientFieldWhenAppendTransientsIsTrue() { [EOL] Field transientField = MyClass.class.getDeclaredField("transientField"); [EOL] setAppendTransients(true); [EOL] boolean result = accept(transientField); [EOL] assertTrue(result); [EOL] }
public void testAcceptWithStaticFieldWhenAppendStaticsIsFalse() { [EOL] Field staticField = MyClass.class.getDeclaredField("staticField"); [EOL] setAppendStatics(false); [EOL] boolean result = accept(staticField); [EOL] assertFalse(result); [EOL] }
public void testAcceptWithStaticFieldWhenAppendStaticsIsTrue() { [EOL] Field staticField = MyClass.class.getDeclaredField("staticField"); [EOL] setAppendStatics(true); [EOL] boolean result = accept(staticField); [EOL] assertTrue(result); [EOL] }
public void testAcceptWithExcludedFieldName() { [EOL] Field excludedField = MyClass.class.getDeclaredField("excludedField"); [EOL] setExcludeFieldNames(new String[]{"excludedField"}); [EOL] boolean result = accept(excludedField); [EOL] assertFalse(result); [EOL] }
public void testAcceptWithNonExcludedFieldName() { [EOL] Field normalField = MyClass.class.getDeclaredField("normalField"); [EOL] setExcludeFieldNames(new String[]{"excludedField"}); [EOL] boolean result = accept(normalField); [EOL] assertTrue(result); [EOL] }
public void testIsAppendTransientsTrue() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null); [EOL] builder.setAppendTransients(true); [EOL] assertTrue(builder.isAppendTransients()); [EOL] }
public void testIsAppendTransientsFalse() { [EOL] ReflectionToStringBuilder builder = new ReflectionToStringBuilder(null); [EOL] builder.setAppendTransients(false); [EOL] assertFalse(builder.isAppendTransients()); [EOL] }
public void testSetUpToClassWithNullClass() { [EOL] setUpToClass(null); [EOL] }
public void testSetUpToClassWithValidSuperclass() { [EOL] Object testObject = new TestSubClass(); [EOL] setUpToClass(testObject.getClass().getSuperclass()); [EOL] }
public void testSetUpToClassWithInvalidClass() { [EOL] try { [EOL] Object testObject = new TestSubClass(); [EOL] setUpToClass(String.class); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testJavaVersionConstructor() { [EOL] float expectedValue = 1.8f; [EOL] String expectedName = "Java 1.8"; [EOL] JavaVersion javaVersion = new JavaVersion(expectedValue, expectedName); [EOL] assertEquals(expectedValue, javaVersion.value); [EOL] assertEquals(expectedName, javaVersion.name); [EOL] }
public void testGetJavaVersionWithNull() { [EOL] assertNull(JavaVersion.getJavaVersion(null)); [EOL] }
public void testGetJavaVersionWithEmptyString() { [EOL] assertNull(JavaVersion.getJavaVersion("")); [EOL] }
public void testGetJavaVersionWithValidName() { [EOL] assertEquals(JavaVersion.JAVA_1_8, JavaVersion.getJavaVersion("1.8")); [EOL] }
public void testGetJavaVersionWithInvalidName() { [EOL] assertNull(JavaVersion.getJavaVersion("invalid")); [EOL] }
public void testGet_Java0_9() { [EOL] JavaVersion result = JavaVersion.get("0.9"); [EOL] assertEquals(JavaVersion.JAVA_0_9, result); [EOL] }
public void testGet_Java1_1() { [EOL] JavaVersion result = JavaVersion.get("1.1"); [EOL] assertEquals(JavaVersion.JAVA_1_1, result); [EOL] }
public void testGet_Java1_2() { [EOL] JavaVersion result = JavaVersion.get("1.2"); [EOL] assertEquals(JavaVersion.JAVA_1_2, result); [EOL] }
public void testGet_Java1_3() { [EOL] JavaVersion result = JavaVersion.get("1.3"); [EOL] assertEquals(JavaVersion.JAVA_1_3, result); [EOL] }
public void testGet_Java1_4() { [EOL] JavaVersion result = JavaVersion.get("1.4"); [EOL] assertEquals(JavaVersion.JAVA_1_4, result); [EOL] }
public void testGet_Java1_5() { [EOL] JavaVersion result = JavaVersion.get("1.5"); [EOL] assertEquals(JavaVersion.JAVA_1_5, result); [EOL] }
public void testGet_Java1_6() { [EOL] JavaVersion result = JavaVersion.get("1.6"); [EOL] assertEquals(JavaVersion.JAVA_1_6, result); [EOL] }
public void testGet_Java1_7() { [EOL] JavaVersion result = JavaVersion.get("1.7"); [EOL] assertEquals(JavaVersion.JAVA_1_7, result); [EOL] }
public void testGet_Java1_8() { [EOL] JavaVersion result = JavaVersion.get("1.8"); [EOL] assertEquals(JavaVersion.JAVA_1_8, result); [EOL] }
public void testGet_Unknown() { [EOL] JavaVersion result = JavaVersion.get("unknown"); [EOL] assertNull(result); [EOL] }
public void testToStringReturnsName() { [EOL] MyClass myClass = new MyClass("TestName"); [EOL] String result = myClass.toString(); [EOL] assertEquals("TestName", result); [EOL] }
public void testSubtractWithNullOperand() { [EOL] try { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] mutableLong.subtract(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException npe) { [EOL] } [EOL] }
public void testSubtractWithValidOperand() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] mutableLong.subtract(new Long(2)); [EOL] assertEquals(3, mutableLong.longValue()); [EOL] }
public void testToString_whenValueIsNotNull_returnsStringValue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = "TestValue"; [EOL] String result = instance.toString(); [EOL] assertEquals("TestValue", result); [EOL] }
public void testToString_whenValueIsNull_returnsNullString() { [EOL] YourClass instance = new YourClass(); [EOL] instance.value = null; [EOL] String result = instance.toString(); [EOL] assertEquals("null", result); [EOL] }
public void testGetValueWhenValueIsSet() { [EOL] final MyClass instance = new MyClass(5); // Assuming there's a constructor that sets the value [EOL] Integer result = instance.getValue(); [EOL] assertNotNull(result); [EOL] assertEquals(Integer.valueOf(5), result); [EOL] }
public void testSetValue() { [EOL] MyClass myClass = new MyClass(); [EOL] int expectedValue = 10; [EOL] myClass.setValue(expectedValue); [EOL] assertEquals(expectedValue, myClass.value); [EOL] }
public void testSetValueWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(null); [EOL] assertEquals(0, instance.getValue()); [EOL] }
public void testSetValueWithPositiveNumber() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(5); [EOL] assertEquals(5, instance.getValue()); [EOL] }
public void testSetValueWithNegativeNumber() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(-5); [EOL] assertEquals(-5, instance.getValue()); [EOL] }
public void testLongValue_PositiveValue() { [EOL] MutableLong mutableLong = new MutableLong(5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(5L, result); [EOL] }
public void testLongValue_NegativeValue() { [EOL] MutableLong mutableLong = new MutableLong(-5); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(-5L, result); [EOL] }
public void testLongValue_ZeroValue() { [EOL] MutableLong mutableLong = new MutableLong(0); [EOL] long result = mutableLong.longValue(); [EOL] assertEquals(0L, result); [EOL] }
public void testMinWithNullArray() { [EOL] Comparable[] nullArray = null; [EOL] Comparable result = ObjectUtils.min(nullArray); [EOL] assertNull(result); [EOL] }
public void testMinWithEmptyArray() { [EOL] Comparable[] emptyArray = new Comparable[0]; [EOL] Comparable result = ObjectUtils.min(emptyArray); [EOL] assertNull(result); [EOL] }
public void testMinWithSingleElementArray() { [EOL] Integer singleValue = 1; [EOL] Integer result = ObjectUtils.min(singleValue); [EOL] assertEquals(singleValue, result); [EOL] }
public void testMinWithMultipleElementsArray() { [EOL] Integer[] multipleValues = {2, 3, 1}; [EOL] Integer result = ObjectUtils.min(multipleValues); [EOL] assertEquals(Integer.valueOf(1), result); [EOL] }
public void testMinWithAllElementsNull() { [EOL] Integer[] allNulls = {null, null, null}; [EOL] Integer result = ObjectUtils.min(allNulls); [EOL] assertNull(result); [EOL] }
public void testMinWithSomeNullElements() { [EOL] Integer[] someNulls = {null, 1, null}; [EOL] Integer result = ObjectUtils.min(someNulls); [EOL] assertEquals(Integer.valueOf(1), result); [EOL] }
public void testCompareBothValuesNullNullGreater() { [EOL] int result = ObjectUtils.compare(null, null, true); [EOL] assertEquals(0, result); [EOL] }
public void testCompareFirstValueNullNullGreater() { [EOL] Integer first = null; [EOL] Integer second = 10; [EOL] int result = ObjectUtils.compare(first, second, true); [EOL] assertEquals(1, result); [EOL] }
public void testCompareSecondValueNullNullGreater() { [EOL] Integer first = 10; [EOL] Integer second = null; [EOL] int result = ObjectUtils.compare(first, second, true); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareBothValuesNullNullLesser() { [EOL] int result = ObjectUtils.compare(null, null, false); [EOL] assertEquals(0, result); [EOL] }
public void testCompareFirstValueNullNullLesser() { [EOL] Integer first = null; [EOL] Integer second = 10; [EOL] int result = ObjectUtils.compare(first, second, false); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareSecondValueNullNullLesser() { [EOL] Integer first = 10; [EOL] Integer second = null; [EOL] int result = ObjectUtils.compare(first, second, false); [EOL] assertEquals(1, result); [EOL] }
public void testCompareNonNullValuesEqual() { [EOL] Integer first = 20; [EOL] Integer second = 20; [EOL] int result = ObjectUtils.compare(first, second, true); [EOL] assertEquals(0, result); [EOL] }
public void testCompareNonNullValuesFirstLess() { [EOL] Integer first = 10; [EOL] Integer second = 20; [EOL] int result = ObjectUtils.compare(first, second, true); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareNonNullValuesFirstGreater() { [EOL] Integer first = 20; [EOL] Integer second = 10; [EOL] int result = ObjectUtils.compare(first, second, true); [EOL] assertEquals(1, result); [EOL] }
public void testMedianWithEmptyItems() { [EOL] try { [EOL] ArrayUtils.median(null, new Integer[]{}); [EOL] fail("Should have thrown IllegalArgumentException for empty items"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testMedianWithNullElements() { [EOL] try { [EOL] ArrayUtils.median(Integer::compare, new Integer[]{null, 1, 2}); [EOL] fail("Should have thrown IllegalArgumentException for null elements"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testMedianWithNullComparator() { [EOL] try { [EOL] ArrayUtils.median(null, new Integer[]{1, 2, 3}); [EOL] fail("Should have thrown IllegalArgumentException for null comparator"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] } [EOL] public void testMedianWithValidInputOddNumberOfElements() { [EOL] Integer[] items = {1, 3, 2}; [EOL] Integer median = ArrayUtils.median(Integer::compare, items); [EOL] assertEquals("The median should be 2", Integer.valueOf(2), median); [EOL] } [EOL] public void testMedianWithValidInputEvenNumberOfElements() { [EOL] Integer[] items = {1, 4, 2, 3}; [EOL] Integer median = ArrayUtils.median(Integer::compare, items); [EOL] assertEquals("The median should be 2 or 3", true, median.equals(2) || median.equals(3)); [EOL] }
public void testCloneWithCloneableArray() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] Integer[] clonedArray = ObjectUtils.clone(array); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] } [EOL] public void testCloneWithPrimitiveArray() { [EOL] int[] array = new int[]{1, 2, 3}; [EOL] int[] clonedArray = ObjectUtils.clone(array); [EOL] assertNotSame(array, clonedArray); [EOL] assertArrayEquals(array, clonedArray); [EOL] } [EOL] public void testCloneWithNonCloneable() { [EOL] Object obj = new Object(); [EOL] Object clonedObj = ObjectUtils.clone(obj); [EOL] assertNull(clonedObj); [EOL] } [EOL] public void testCloneWithCloneable() throws Exception { [EOL] CloneableTestClass testClass = new CloneableTestClass(); [EOL] CloneableTestClass clonedTestClass = ObjectUtils.clone(testClass); [EOL] assertNotSame(testClass, clonedTestClass); [EOL] assertEquals(testClass.value, clonedTestClass.value); [EOL] } [EOL] public void testCloneWithCloneableThrowingException() { [EOL] CloneableThrowingTestClass testClass = new CloneableThrowingTestClass(); [EOL] try { [EOL] ObjectUtils.clone(testClass); [EOL] fail("Should have thrown CloneFailedException"); [EOL] } catch (CloneFailedException e) { [EOL] } [EOL] }
public void testCloneWithCloneableHavingNoCloneMethod() { [EOL] CloneableNoCloneMethodTestClass testClass = new CloneableNoCloneMethodTestClass(); [EOL] try { [EOL] ObjectUtils.clone(testClass); [EOL] fail("Should have thrown CloneFailedException"); [EOL] } catch (CloneFailedException e) { [EOL] } [EOL] }
public void testCloneWithCloneableHavingInaccessibleCloneMethod() { [EOL] CloneablePrivateCloneMethodTestClass testClass = new CloneablePrivateCloneMethodTestClass(); [EOL] try { [EOL] ObjectUtils.clone(testClass); [EOL] fail("Should have thrown CloneFailedException"); [EOL] } catch (CloneFailedException e) { [EOL] } [EOL] }
public void testCloneIfPossible_withCloneable() { [EOL] CloneableTestClass original = new CloneableTestClass("value"); [EOL] CloneableTestClass cloned = Lang3.cloneIfPossible(original); [EOL] assertNotNull(cloned); [EOL] assertNotSame(original, cloned); [EOL] assertEquals(original.getValue(), cloned.getValue()); [EOL] }
public void testCloneIfPossible_withNull() { [EOL] Object result = Lang3.cloneIfPossible(null); [EOL] assertNull(result); [EOL] }
public void testCloneIfPossible_withNonCloneable() { [EOL] NonCloneableTestClass original = new NonCloneableTestClass("value"); [EOL] NonCloneableTestClass result = Lang3.cloneIfPossible(original); [EOL] assertSame(original, result); [EOL] }
public void testReadResolve() throws Exception { [EOL] Null nullInstance = new Null(); [EOL] Method readResolveMethod = Null.class.getDeclaredMethod("readResolve"); [EOL] readResolveMethod.setAccessible(true); [EOL] Object result = readResolveMethod.invoke(nullInstance); [EOL] assertSame(ObjectUtils.NULL, result); [EOL] }
public void testNotNullWithNonNull() { [EOL] String testString = "test"; [EOL] String result = Validate.notNull(testString); [EOL] assertEquals(testString, result); [EOL] }
public void testNotNullWithNull() { [EOL] try { [EOL] Validate.notNull(null); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(Validate.DEFAULT_IS_NULL_EX_MESSAGE, e.getMessage()); [EOL] } [EOL] }
public void testNotNull_givenNonNull_shouldReturnObject() { [EOL] String testString = "test"; [EOL] String result = notNull(testString, "The object should not be null"); [EOL] assertSame("The returned object should be the same as the input object", testString, result); [EOL] }
public void testNotNull_givenNull_shouldThrowException() { [EOL] try { [EOL] notNull(null, "The object should not be null"); [EOL] fail("NullPointerException expected for null object"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The object should not be null", e.getMessage()); [EOL] } [EOL] }
public void testNotNull_givenNullWithFormattedMessage_shouldThrowException() { [EOL] try { [EOL] notNull(null, "The %s should not be %s", "object", "null"); [EOL] fail("NullPointerException expected for null object with formatted message"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The object should not be null", e.getMessage()); [EOL] } [EOL] }
public void testNotEmptyWithNonNull() { [EOL] String nonEmptyString = "abc"; [EOL] String result = StringUtils.notEmpty(nonEmptyString); [EOL] assertNotNull(result); [EOL] assertEquals(nonEmptyString, result); [EOL] }
public void testNotEmptyWithEmptyString() { [EOL] try { [EOL] StringUtils.notEmpty(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals(StringUtils.DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE, ex.getMessage()); [EOL] } [EOL] }
public void testNotEmptyWithNull() { [EOL] try { [EOL] StringUtils.notEmpty(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals(StringUtils.DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE, ex.getMessage()); [EOL] } [EOL] }
public void testNotBlank_NullInput_ThrowsNullPointerException() { [EOL] String message = "The char sequence must not be null"; [EOL] try { [EOL] StringUtils.notBlank(null, message); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals(message, e.getMessage()); [EOL] } [EOL] }
public void testNotBlank_BlankInput_ThrowsIllegalArgumentException() { [EOL] String message = "The char sequence must not be blank"; [EOL] try { [EOL] StringUtils.notBlank(" ", message); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(message, e.getMessage()); [EOL] } [EOL] }
public void testNotBlank_NonBlankInput_ReturnsInput() { [EOL] String input = "abc"; [EOL] String result = StringUtils.notBlank(input, "The char sequence must not be blank"); [EOL] assertEquals(input, result); [EOL] }
public void testNoNullElementsWithNonNullArray() { [EOL] String[] array = {"a", "b", "c"}; [EOL] String[] result = Validate.noNullElements(array, "Array should not contain null elements at index %d", 0); [EOL] assertArrayEquals(array, result); [EOL] }
public void testNoNullElementsWithNullElement() { [EOL] String[] array = {"a", null, "c"}; [EOL] try { [EOL] Validate.noNullElements(array, "Array should not contain null elements at index %d", 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Array should not contain null elements at index 1", e.getMessage()); [EOL] } [EOL] }
public void testNoNullElementsWithEmptyArray() { [EOL] String[] array = {}; [EOL] String[] result = Validate.noNullElements(array, "Array should not contain null elements"); [EOL] assertArrayEquals(array, result); [EOL] }
public void testNoNullElementsWithAllNullArray() { [EOL] String[] array = {null, null}; [EOL] try { [EOL] Validate.noNullElements(array, "Array should not contain null elements at index %d", 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Array should not contain null elements at index 0", e.getMessage()); [EOL] } [EOL] }
public void testNoNullElementsWithNullArray() { [EOL] try { [EOL] Validate.noNullElements(null, "Array should not be null"); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Array should not be null", e.getMessage()); [EOL] } [EOL] }
public void testNoNullElementsWithNonNullArray() { [EOL] String[] array = new String[] {"a", "b", "c"}; [EOL] String[] result = ArrayUtils.noNullElements(array); [EOL] assertArrayEquals(array, result); [EOL] }
public void testNoNullElementsWithNullArray() { [EOL] String[] array = null; [EOL] try { [EOL] ArrayUtils.noNullElements(array); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testNoNullElementsWithArrayContainingNull() { [EOL] String[] array = new String[] {"a", null, "c"}; [EOL] try { [EOL] ArrayUtils.noNullElements(array); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testValidIndex_ValidIndex() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] int index = 1; [EOL] Integer[] result = ArrayUtils.validIndex(array, index, "Index is invalid: %d", index); [EOL] assertSame("The returned array should be the same as the input array", array, result); [EOL] } [EOL] public void testValidIndex_IndexOutOfBounds() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] int index = 3; [EOL] try { [EOL] ArrayUtils.validIndex(array, index, "Index is invalid: %d", index); [EOL] fail("Expected IndexOutOfBoundsException for index " + index); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index is invalid: 3", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidIndex_NegativeIndex() { [EOL] Integer[] array = new Integer[]{1, 2, 3}; [EOL] int index = -1; [EOL] try { [EOL] ArrayUtils.validIndex(array, index, "Index is invalid: %d", index); [EOL] fail("Expected IndexOutOfBoundsException for index " + index); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index is invalid: -1", e.getMessage()); [EOL] } [EOL] } [EOL] public void testValidIndex_NullArray() { [EOL] Integer[] array = null; [EOL] int index = 0; [EOL] try { [EOL] ArrayUtils.validIndex(array, index, "Array should not be null"); [EOL] fail("Expected NullPointerException for null array"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Array should not be null", e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_ValidInput() { [EOL] Integer[] array = new Integer[]{1, 2, 3, 4}; [EOL] Integer[] result = ArrayUtils.validIndex(array, 1); [EOL] assertNotNull(result); [EOL] assertSame(array, result); [EOL] }
public void testValidIndex_IndexOutOfBounds() { [EOL] Integer[] array = new Integer[]{1, 2, 3, 4}; [EOL] try { [EOL] ArrayUtils.validIndex(array, 5); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testValidIndex_NullArray() { [EOL] try { [EOL] ArrayUtils.validIndex(null, 1); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testValidIndex_NegativeIndex() { [EOL] Integer[] array = new Integer[]{1, 2, 3, 4}; [EOL] try { [EOL] ArrayUtils.validIndex(array, -1); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testValidIndex_ValidCase() { [EOL] List<String> collection = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] int index = 1; [EOL] String message = "Index is out of bounds: %d"; [EOL] List<String> result = Validate.validIndex(collection, index, message, index); [EOL] assertSame("The returned collection should be the same as the one passed in", collection, result); [EOL] }
public void testValidIndex_IndexOutOfBounds() { [EOL] List<String> collection = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] int index = 3; [EOL] String message = "Index is out of bounds: %d"; [EOL] try { [EOL] Validate.validIndex(collection, index, message, index); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index is out of bounds: 3", e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_NegativeIndex() { [EOL] List<String> collection = new ArrayList<>(Arrays.asList("a", "b", "c")); [EOL] int index = -1; [EOL] String message = "Index is out of bounds: %d"; [EOL] try { [EOL] Validate.validIndex(collection, index, message, index); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Index is out of bounds: -1", e.getMessage()); [EOL] } [EOL] }
public void testValidIndex_NullCollection() { [EOL] List<String> collection = null; [EOL] int index = 1; [EOL] String message = "The collection must not be null"; [EOL] try { [EOL] Validate.validIndex(collection, index, message); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("The collection must not be null", e.getMessage()); [EOL] } [EOL] }
public void testIsInstanceOfWithValidInstance() { [EOL] Object obj = new Integer(5); [EOL] Class<?> type = Integer.class; [EOL] isInstanceOf(type, obj, "Object is not an instance of the required type"); [EOL] } [EOL] public void testIsInstanceOfWithInvalidInstance() { [EOL] try { [EOL] Object obj = new Integer(5); [EOL] Class<?> type = String.class; [EOL] isInstanceOf(type, obj, "Object is not an instance of %s", type.getSimpleName()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Object is not an instance of String", e.getMessage()); [EOL] } [EOL] } [EOL] public void testIsInstanceOfWithNullType() { [EOL] try { [EOL] Object obj = new Integer(5); [EOL] isInstanceOf(null, obj, "Type should not be null"); [EOL] fail("Expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testIsInstanceOfWithNullObject() { [EOL] Class<?> type = Integer.class; [EOL] isInstanceOf(type, null, "Object should not be null"); [EOL] } [EOL] public void testIsInstanceOfWithNullMessage() { [EOL] try { [EOL] Object obj = new Integer(5); [EOL] Class<?> type = String.class; [EOL] isInstanceOf(type, obj, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIsInstanceOfWithMessageArguments() { [EOL] try { [EOL] Object obj = new Integer(5); [EOL] Class<?> type = String.class; [EOL] isInstanceOf(type, obj, "Expected %s, found %s", type.getSimpleName(), obj.getClass().getSimpleName()); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Expected String, found Integer", e.getMessage()); [EOL] } [EOL] }
public void testMutableBooleanConstructor() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(); [EOL] assertNotNull(mutableBoolean); [EOL] assertFalse(mutableBoolean.booleanValue()); [EOL] }
public void testMutableBooleanTrue() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(true); [EOL] assertTrue(mutableBoolean.booleanValue()); [EOL] }
public void testMutableBooleanFalse() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(false); [EOL] assertFalse(mutableBoolean.booleanValue()); [EOL] }
public void testMutableBooleanConstructorWithTrue() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(Boolean.TRUE); [EOL] assertTrue(mutableBoolean.booleanValue()); [EOL] }
public void testMutableBooleanConstructorWithFalse() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(Boolean.FALSE); [EOL] assertFalse(mutableBoolean.booleanValue()); [EOL] }
public void testGetValueWhenTrue() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(true); [EOL] assertTrue(mutableBoolean.getValue()); [EOL] }
public void testGetValueWhenFalse() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(false); [EOL] assertFalse(mutableBoolean.getValue()); [EOL] }
public void testSetValueTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(true); [EOL] assertTrue(instance.getValue()); [EOL] }
public void testSetValueFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(false); [EOL] assertFalse(instance.getValue()); [EOL] }
public void testSetValueWithTrue() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(Boolean.TRUE); [EOL] assertTrue(instance.value); [EOL] }
public void testSetValueWithFalse() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(Boolean.FALSE); [EOL] assertFalse(instance.value); [EOL] }
public void testSetValueWithNull() { [EOL] YourClass instance = new YourClass(); [EOL] instance.setValue(null); [EOL] assertFalse(instance.value); // Assuming default for null input is false [EOL] }
public void testIsTrueWhenValueIsTrue() { [EOL] SomeClass instance = new SomeClass(true); [EOL] assertTrue(instance.isTrue()); [EOL] }
public void testIsTrueWhenValueIsFalse() { [EOL] SomeClass instance = new SomeClass(false); [EOL] assertFalse(instance.isTrue()); [EOL] }
public void testIsFalseWhenValueIsTrue() { [EOL] BooleanUtils booleanUtils = new BooleanUtils(true); [EOL] assertFalse(booleanUtils.isFalse()); [EOL] }
public void testIsFalseWhenValueIsFalse() { [EOL] BooleanUtils booleanUtils = new BooleanUtils(false); [EOL] assertTrue(booleanUtils.isFalse()); [EOL] }
public void testBooleanValueTrue() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(true); [EOL] assertTrue(mutableBoolean.booleanValue()); [EOL] }
public void testBooleanValueFalse() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(false); [EOL] assertFalse(mutableBoolean.booleanValue()); [EOL] }
public void testToBooleanTrue() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(true); [EOL] Boolean result = mutableBoolean.toBoolean(); [EOL] assertTrue(result); [EOL] }
public void testToBooleanFalse() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(false); [EOL] Boolean result = mutableBoolean.toBoolean(); [EOL] assertFalse(result); [EOL] }
public void testEquals_sameMutableBooleanObject() { [EOL] MutableBoolean mutableBoolean1 = new MutableBoolean(true); [EOL] assertTrue(mutableBoolean1.equals(mutableBoolean1)); [EOL] } [EOL] public void testEquals_differentMutableBooleanObjectSameValue() { [EOL] MutableBoolean mutableBoolean1 = new MutableBoolean(true); [EOL] MutableBoolean mutableBoolean2 = new MutableBoolean(true); [EOL] assertTrue(mutableBoolean1.equals(mutableBoolean2)); [EOL] } [EOL] public void testEquals_differentMutableBooleanObjectDifferentValue() { [EOL] MutableBoolean mutableBoolean1 = new MutableBoolean(true); [EOL] MutableBoolean mutableBoolean2 = new MutableBoolean(false); [EOL] assertFalse(mutableBoolean1.equals(mutableBoolean2)); [EOL] } [EOL] public void testEquals_nonMutableBooleanObject() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(true); [EOL] Object dummyObject = new Object(); [EOL] assertFalse(mutableBoolean.equals(dummyObject)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] MutableBoolean mutableBoolean = new MutableBoolean(true); [EOL] assertFalse(mutableBoolean.equals(null)); [EOL] }
public void testFormatPeriodWithDefaultTimeZone() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 1000 * 60 * 60; // 1 hour later [EOL] String format = "yyyy-MM-dd HH:mm:ss"; [EOL] String result = StringUtils.formatPeriod(startMillis, endMillis, format); [EOL] assertNotNull(result); [EOL] String expected = DateFormatUtils.format(startMillis, format, TimeZone.getDefault()); [EOL] assertEquals(expected, result.substring(0, expected.length())); [EOL] }
public void testFormatPeriodWithDifferentStartAndEnd() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis - 1000 * 60 * 60; // 1 hour earlier [EOL] String format = "yyyy-MM-dd HH:mm:ss"; [EOL] String result = StringUtils.formatPeriod(startMillis, endMillis, format); [EOL] assertNotNull(result); [EOL] String expected = DateFormatUtils.format(endMillis, format, TimeZone.getDefault()); [EOL] assertEquals(expected, result.substring(0, expected.length())); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL] final Token[] tokens = lexx(format); [EOL] final Calendar start = Calendar.getInstance(timezone); [EOL] start.setTime(new Date(startMillis)); [EOL] final Calendar end = Calendar.getInstance(timezone); [EOL] end.setTime(new Date(endMillis)); [EOL] int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL] int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL] int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL] int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL] int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL] int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL] int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL] while (milliseconds < 0) { [EOL] milliseconds += 1000; [EOL] seconds -= 1; [EOL] } [EOL] while (seconds < 0) { [EOL] seconds += 60; [EOL] minutes -= 1; [EOL] } [EOL] while (minutes < 0) { [EOL] minutes += 60; [EOL] hours -= 1; [EOL] } [EOL] while (hours < 0) { [EOL] hours += 24; [EOL] days -= 1; [EOL] } [EOL] if (Token.containsTokenWithValue(tokens, M)) { [EOL] while (days < 0) { [EOL] days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL] months -= 1; [EOL] start.add(Calendar.MONTH, 1); [EOL] } [EOL] while (months < 0) { [EOL] months += 12; [EOL] years -= 1; [EOL] } [EOL] if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL] while (years != 0) { [EOL] months += 12 * years; [EOL] years = 0; [EOL] } [EOL] } [EOL] } else { [EOL] if (!Token.containsTokenWithValue(tokens, y)) { [EOL] int target = end.get(Calendar.YEAR); [EOL] if (months < 0) { [EOL] target -= 1; [EOL] } [EOL] while (start.get(Calendar.YEAR) != target) { [EOL] days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL] if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL] days += 1; [EOL] } [EOL] start.add(Calendar.YEAR, 1); [EOL] days += start.get(Calendar.DAY_OF_YEAR); [EOL] } [EOL] years = 0; [EOL] } [EOL] while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL] days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL] start.add(Calendar.MONTH, 1); [EOL] } [EOL] months = 0; [EOL] while (days < 0) { [EOL] days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL] months -= 1; [EOL] start.add(Calendar.MONTH, 1); [EOL] } [EOL] } [EOL] if (!Token.containsTokenWithValue(tokens, d)) { [EOL] hours += 24 * days; [EOL] days = 0; [EOL] } [EOL] if (!Token.containsTokenWithValue(tokens, H)) { [EOL] minutes += 60 * hours; [EOL] hours = 0; [EOL] } [EOL] if (!Token.containsTokenWithValue(tokens, m)) { [EOL] seconds += 60 * minutes; [EOL] minutes = 0; [EOL] } [EOL] if (!Token.containsTokenWithValue(tokens, s)) { [EOL] milliseconds += 1000 * seconds; [EOL] seconds = 0; [EOL] } [EOL] return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public void testFormatWithPaddingZerosAndLastOutputSeconds() { [EOL] Token[] tokens = new Token[] { [EOL] new Token(DurationFormatUtils.Token.y, 2), [EOL] new Token(DurationFormatUtils.Token.M, 2), [EOL] new Token(DurationFormatUtils.Token.d, 2), [EOL] new Token(DurationFormatUtils.Token.H, 2), [EOL] new Token(DurationFormatUtils.Token.m, 2), [EOL] new Token(DurationFormatUtils.Token.s, 2), [EOL] new Token(DurationFormatUtils.Token.S, 3) [EOL] }; [EOL] String formatted = DurationFormatUtils.format(tokens, 1, 1, 1, 1, 1, 1, 1, true); [EOL] assertEquals("0101010101011001", formatted); [EOL] }
public void testFormatWithoutPaddingZerosAndLastOutputSeconds() { [EOL] Token[] tokens = new Token[] { [EOL] new Token(DurationFormatUtils.Token.y, 2), [EOL] new Token(DurationFormatUtils.Token.M, 2), [EOL] new Token(DurationFormatUtils.Token.d, 2), [EOL] new Token(DurationFormatUtils.Token.H, 2), [EOL] new Token(DurationFormatUtils.Token.m, 2), [EOL] new Token(DurationFormatUtils.Token.s, 2), [EOL] new Token(DurationFormatUtils.Token.S, 3) [EOL] }; [EOL] String formatted = DurationFormatUtils.format(tokens, 1, 1, 1, 1, 1, 1, 1, false); [EOL] assertEquals("1111111001", formatted); [EOL] }
public void testFormatWithPaddingZerosWithoutLastOutputSeconds() { [EOL] Token[] tokens = new Token[] { [EOL] new Token(DurationFormatUtils.Token.y, 2), [EOL] new Token(DurationFormatUtils.Token.M, 2), [EOL] new Token(DurationFormatUtils.Token.d, 2), [EOL] new Token(DurationFormatUtils.Token.H, 2), [EOL] new Token(DurationFormatUtils.Token.m, 2), [EOL] new Token(DurationFormatUtils.Token.S, 3) [EOL] }; [EOL] String formatted = DurationFormatUtils.format(tokens, 1, 1, 1, 1, 1, 0, 1, true); [EOL] assertEquals("0101010101001", formatted); [EOL] }
public void testFormatWithoutPaddingZerosWithoutLastOutputSeconds() { [EOL] Token[] tokens = new Token[] { [EOL] new Token(DurationFormatUtils.Token.y, 2), [EOL] new Token(DurationFormatUtils.Token.M, 2), [EOL] new Token(DurationFormatUtils.Token.d, 2), [EOL] new Token(DurationFormatUtils.Token.H, 2), [EOL] new Token(DurationFormatUtils.Token.m, 2), [EOL] new Token(DurationFormatUtils.Token.S, 3) [EOL] }; [EOL] String formatted = DurationFormatUtils.format(tokens, 1, 1, 1, 1, 1, 0, 1, false); [EOL] assertEquals("111111001", formatted); [EOL] }
public void testFormatWithMixedTokens() { [EOL] Token[] tokens = new Token[] { [EOL] new Token(new StringBuilder("Year: ")), [EOL] new Token(DurationFormatUtils.Token.y, 2), [EOL] new Token(new StringBuilder(", Month: ")), [EOL] new Token(DurationFormatUtils.Token.M, 2), [EOL] new Token(new StringBuilder(", Day: ")), [EOL] new Token(DurationFormatUtils.Token.d, 2), [EOL] new Token(new StringBuilder(", Hour: ")), [EOL] new Token(DurationFormatUtils.Token.H, 2), [EOL] new Token(new StringBuilder(", Minute: ")), [EOL] new Token(DurationFormatUtils.Token.m, 2), [EOL] new Token(new StringBuilder(", Second: ")), [EOL] new Token(DurationFormatUtils.Token.s, 2), [EOL] new Token(new StringBuilder(", Millisecond: ")), [EOL] new Token(DurationFormatUtils.Token.S, 3) [EOL] }; [EOL] String formatted = DurationFormatUtils.format(tokens, 1, 1, 1, 1, 1, 1, 1, true); [EOL] assertEquals("Year: 01, Month: 01, Day: 01, Hour: 01, Minute: 01, Second: 01, Millisecond: 001", formatted); [EOL] }
public void testKeep_NullInputString() { [EOL] String result = StringUtils.keep(null, "a", "b"); [EOL] assertNull(result); [EOL] } [EOL] public void testKeep_EmptyInputString() { [EOL] String result = StringUtils.keep("", "a", "b"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testKeep_EmptySet() { [EOL] String result = StringUtils.keep("abc", new String[0]); [EOL] assertEquals("", result); [EOL] } [EOL] public void testKeep_NullSet() { [EOL] String result = StringUtils.keep("abc", (String[]) null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testKeep_ValidInput() { [EOL] String result = StringUtils.keep("abc", "a", "b"); [EOL] assertNotNull(result); [EOL] assertEquals("ab", result); [EOL] }

public ExceptionUtils() { [EOL] super(); [EOL] } [EOL] public ExceptionUtils(); [EOL] public static String[] getDefaultCauseMethodNames(); [EOL] public static Throwable getCause(final Throwable throwable); [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames); [EOL] public static Throwable getRootCause(final Throwable throwable); [EOL] private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName); [EOL] public static int getThrowableCount(final Throwable throwable); [EOL] public static Throwable[] getThrowables(final Throwable throwable); [EOL] public static List<Throwable> getThrowableList(Throwable throwable); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz); [EOL] public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type); [EOL] public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex); [EOL] private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass); [EOL] public static void printRootCauseStackTrace(final Throwable throwable); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream); [EOL] public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer); [EOL] public static String[] getRootCauseStackTrace(final Throwable throwable); [EOL] public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames); [EOL] public static String getStackTrace(final Throwable throwable); [EOL] public static String[] getStackFrames(final Throwable throwable); [EOL] static String[] getStackFrames(final String stackTrace); [EOL] static List<String> getStackFrameList(final Throwable t); [EOL] public static String getMessage(final Throwable th); [EOL] public static String getRootCauseMessage(final Throwable th); [EOL] String WRAPPED_MARKER=Optional[" [wrapped] "]; [EOL] String[] CAUSE_METHOD_NAMES=Optional[{ "getCause", "getNextException", "getTargetException", "getException", "getSourceException", "getRootCause", "getCausedByException", "getNested", "getLinkedException", "getNestedException", "getLinkedCause", "getThrowable" }];
public void testGetCause_NullThrowable() { [EOL] Throwable result = ExceptionUtils.getCause(null, null); [EOL] assertNull(result); [EOL] }
public void testGetCause_NullMethodNames() { [EOL] Throwable throwable = new RuntimeException(); [EOL] Throwable result = ExceptionUtils.getCause(throwable, null); [EOL] assertNull(result); // Assuming getCauseUsingMethodName returns null for default method names [EOL] }
public void testGetCause_ValidThrowableAndMethodNames() { [EOL] Throwable throwable = new Throwable() { [EOL] public Throwable getCause() { [EOL] return new RuntimeException(); [EOL] } [EOL] }; [EOL] String[] methodNames = {"getCause"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof RuntimeException); [EOL] }
public void testGetCause_ValidThrowableAndInvalidMethodNames() { [EOL] Throwable throwable = new Throwable() { [EOL] public Throwable getCause() { [EOL] return new RuntimeException(); [EOL] } [EOL] }; [EOL] String[] methodNames = {"getUnknownCause"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNull(result); // Assuming getCauseUsingMethodName returns null for invalid method names [EOL] }
public void testGetCause_ValidThrowableAndMixedMethodNames() { [EOL] Throwable throwable = new Throwable() { [EOL] public Throwable getCause() { [EOL] return new RuntimeException(); [EOL] } [EOL] }; [EOL] String[] methodNames = {null, "getCause", "getUnknownCause"}; [EOL] Throwable result = ExceptionUtils.getCause(throwable, methodNames); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof RuntimeException); [EOL] }
public void testPrintRootCauseStackTraceWithNullThrowable() { [EOL] ByteArrayOutputStream outContent = new ByteArrayOutputStream(); [EOL] PrintStream originalOut = System.out; [EOL] System.setOut(new PrintStream(outContent)); [EOL] ExceptionUtils.printRootCauseStackTrace(null, System.out); [EOL] System.setOut(originalOut); [EOL] assertEquals("", outContent.toString().trim()); [EOL] }
public void testPrintRootCauseStackTraceWithNullStream() { [EOL] Throwable throwable = new RuntimeException("Test"); [EOL] try { [EOL] ExceptionUtils.printRootCauseStackTrace(throwable, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] assertEquals("The PrintStream must not be null", iae.getMessage()); [EOL] } [EOL] }
public void testPrintRootCauseStackTrace() { [EOL] Throwable throwable = new RuntimeException("Root Cause"); [EOL] throwable.initCause(new IllegalStateException("Caused By")); [EOL] ByteArrayOutputStream outContent = new ByteArrayOutputStream(); [EOL] PrintStream printStream = new PrintStream(outContent); [EOL] ExceptionUtils.printRootCauseStackTrace(throwable, printStream); [EOL] String[] lines = outContent.toString().split(System.lineSeparator()); [EOL] assertTrue(lines.length > 0); [EOL] assertTrue(lines[0].contains("Root Cause")); [EOL] assertTrue(lines[lines.length - 1].contains("Caused By")); [EOL] }
public void testPrintRootCauseStackTrace_NullThrowable() { [EOL] PrintWriter writer = new PrintWriter(new StringWriter()); [EOL] ExceptionUtils.printRootCauseStackTrace(null, writer); [EOL] }
public void testPrintRootCauseStackTrace_NullWriter() { [EOL] try { [EOL] ExceptionUtils.printRootCauseStackTrace(new Throwable(), null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] }
public void testPrintRootCauseStackTrace_ValidArguments() { [EOL] Throwable throwable = new Throwable("Root Cause"); [EOL] StringWriter stringWriter = new StringWriter(); [EOL] PrintWriter writer = new PrintWriter(stringWriter); [EOL] ExceptionUtils.printRootCauseStackTrace(throwable, writer); [EOL] writer.close(); [EOL] String result = stringWriter.toString(); [EOL] assertTrue(result.contains("Root Cause")); [EOL] }
public void testRemoveCommonFrames_NullLists() { [EOL] try { [EOL] ExceptionUtils.removeCommonFrames(null, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRemoveCommonFrames_OneNullList() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("frame2"); [EOL] try { [EOL] ExceptionUtils.removeCommonFrames(causeFrames, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] try { [EOL] ExceptionUtils.removeCommonFrames(null, causeFrames); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] } [EOL] public void testRemoveCommonFrames_NoCommonFrames() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("frame2"); [EOL] List<String> wrapperFrames = new ArrayList<>(); [EOL] wrapperFrames.add("frame3"); [EOL] wrapperFrames.add("frame4"); [EOL] ExceptionUtils.removeCommonFrames(causeFrames, wrapperFrames); [EOL] assertEquals("List size should be the same", 2, causeFrames.size()); [EOL] } [EOL] public void testRemoveCommonFrames_WithCommonFrames() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("frame1"); [EOL] causeFrames.add("commonFrame"); [EOL] List<String> wrapperFrames = new ArrayList<>(); [EOL] wrapperFrames.add("commonFrame"); [EOL] wrapperFrames.add("frame2"); [EOL] ExceptionUtils.removeCommonFrames(causeFrames, wrapperFrames); [EOL] assertEquals("List size should be reduced", 1, causeFrames.size()); [EOL] assertEquals("Remaining frame should be 'frame1'", "frame1", causeFrames.get(0)); [EOL] }
public void testRemoveCommonFrames_AllCommonFrames() { [EOL] List<String> causeFrames = new ArrayList<>(); [EOL] causeFrames.add("commonFrame1"); [EOL] causeFrames.add("commonFrame2"); [EOL] List<String> wrapperFrames = new ArrayList<>(); [EOL] wrapperFrames.add("commonFrame1"); [EOL] wrapperFrames.add("commonFrame2"); [EOL] ExceptionUtils.removeCommonFrames(causeFrames, wrapperFrames); [EOL] assertTrue("List should be empty", causeFrames.isEmpty()); [EOL] }
public void testMutableShortConstructor() { [EOL] short expectedValue = 10; [EOL] MutableShort instance = new MutableShort(expectedValue); [EOL] assertEquals(expectedValue, instance.shortValue()); [EOL] }
public void testSubtract_PositiveOperand() { [EOL] MutableShort instance = new MutableShort((short)10); [EOL] instance.subtract((short)5); [EOL] assertEquals((short)5, instance.shortValue()); [EOL] }
public void testSubtract_NegativeOperand() { [EOL] MutableShort instance = new MutableShort((short)10); [EOL] instance.subtract((short)-5); [EOL] assertEquals((short)15, instance.shortValue()); [EOL] }
public void testSubtract_ZeroOperand() { [EOL] MutableShort instance = new MutableShort((short)10); [EOL] instance.subtract((short)0); [EOL] assertEquals((short)10, instance.shortValue()); [EOL] }
public void testShortValue_Positive() { [EOL] Byte byteValue = new Byte((byte) 1); [EOL] short result = byteValue.shortValue(); [EOL] assertEquals(1, result); [EOL] }
public void testShortValue_Negative() { [EOL] Byte byteValue = new Byte((byte) -1); [EOL] short result = byteValue.shortValue(); [EOL] assertEquals(-1, result); [EOL] }
public void testShortValue_Zero() { [EOL] Byte byteValue = new Byte((byte) 0); [EOL] short result = byteValue.shortValue(); [EOL] assertEquals(0, result); [EOL] }
public void testReset() { [EOL] StopWatch stopWatch = new StopWatch(); [EOL] stopWatch.start(); [EOL] stopWatch.split(); [EOL] stopWatch.reset(); [EOL] assertEquals(StopWatch.STATE_UNSTARTED, stopWatch.getRunningState()); [EOL] assertEquals(StopWatch.STATE_UNSPLIT, stopWatch.getSplitState()); [EOL] }
public void testGetStartTime_WhenUnstarted_ShouldThrowException() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] try { [EOL] stopwatch.getStartTime(); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Stopwatch has not been started", e.getMessage()); [EOL] } [EOL] }
public void testGetStartTime_WhenStarted_ShouldReturnStartTime() { [EOL] Stopwatch stopwatch = new Stopwatch(); [EOL] stopwatch.start(); [EOL] long startTime = stopwatch.getStartTime(); [EOL] assertTrue(startTime > 0); [EOL] }
public void testAppendWithNullComparator() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("a", "a"); [EOL] builder.append("a", "b"); [EOL] builder.append("b", "a"); [EOL] builder.append(null, null); [EOL] int result = builder.toComparison(); [EOL] assertTrue(result == 0); [EOL] }
public void testAppendWithNonNullComparator() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("a", "a", String.CASE_INSENSITIVE_ORDER); [EOL] builder.append("A", "b", String.CASE_INSENSITIVE_ORDER); [EOL] builder.append("B", "a", String.CASE_INSENSITIVE_ORDER); [EOL] builder.append(null, "a", String.CASE_INSENSITIVE_ORDER); [EOL] builder.append("a", null, String.CASE_INSENSITIVE_ORDER); [EOL] int result = builder.toComparison(); [EOL] assertTrue(result != 0); [EOL] }
public void testAppend_BothObjectsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, null, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_LeftObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(null, new Object(), null); [EOL] assertEquals(-1, builder.toComparison()); [EOL] }
public void testAppend_RightObjectNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(new Object(), null, null); [EOL] assertEquals(1, builder.toComparison()); [EOL] }
public void testAppend_BothObjectsSame() { [EOL] Object obj = new Object(); [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(obj, obj, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_BothObjectsAreArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] long[] lhs = new long[] {1L, 2L}; [EOL] long[] rhs = new long[] {1L, 2L}; [EOL] builder.append(lhs, rhs, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_BothObjectsAreDifferentArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] int[] lhs = new int[] {1, 2}; [EOL] int[] rhs = new int[] {3, 4}; [EOL] builder.append(lhs, rhs, null); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppend_WithComparator() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Comparator<Object> comparator = Comparator.naturalOrder(); [EOL] builder.append("a", "b", comparator); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_WithoutComparator() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append("a", "b", null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_CharEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append('a', 'a'); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_CharLessThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append('a', 'b'); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_CharGreaterThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append('b', 'a'); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppend_CharComparisonNonZero() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append('a', 'b'); [EOL] builder.append('c', 'c'); // This should not affect the comparison result [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_DoubleEqual() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(10.0, 10.0); [EOL] assertEquals(0, compareToBuilder.toComparison()); [EOL] }
public void testAppend_DoubleGreater() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(10.5, 10.0); [EOL] assertTrue(compareToBuilder.toComparison() > 0); [EOL] }
public void testAppend_DoubleLess() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(9.5, 10.0); [EOL] assertTrue(compareToBuilder.toComparison() < 0); [EOL] }
public void testAppend_DoubleComparisonNonZero() { [EOL] CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL] compareToBuilder.append(9.5, 10.0); [EOL] compareToBuilder.append(10.0, 10.0); // This should not affect the comparison result [EOL] assertTrue(compareToBuilder.toComparison() < 0); [EOL] }
public void testAppend_FloatEqual() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(10.0f, 10.0f); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppend_FloatLessThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(5.0f, 10.0f); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_FloatGreaterThan() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(10.0f, 5.0f); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppend_FloatWithComparisonSet() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(10.0f, 5.0f); [EOL] builder.append(5.0f, 10.0f); // This should not affect the comparison since it's already set [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppendSameArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = lhs; [EOL] builder.append(lhs, rhs, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendDifferentArraysSameLength() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs, null); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendDifferentLengthArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] {1, 2}; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs, null); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendNonNullLhsNullRhs() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = new Object[] {1, 2, 3}; [EOL] Object[] rhs = null; [EOL] builder.append(lhs, rhs, null); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppendNullLhsNonNullRhs() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] Object[] lhs = null; [EOL] Object[] rhs = new Object[] {1, 2, 3}; [EOL] builder.append(lhs, rhs, null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppendArraysAlreadyComparedNonZero() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); [EOL] Object[] lhs = new Object[] {3, 4}; [EOL] Object[] rhs = new Object[] {3, 4}; [EOL] builder.append(lhs, rhs, null); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppend_CharArraysWithEqualLengthAndContent() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_CharArraysWithDifferentLength() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] char[] lhs = new char[]{'a', 'b'}; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] } [EOL] public void testAppend_CharArraysWithDifferentContent() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'a', 'x', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] } [EOL] public void testAppend_LeftArrayIsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] char[] lhs = null; [EOL] char[] rhs = new char[]{'a', 'b', 'c'}; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(-1, builder.toComparison()); [EOL] } [EOL] public void testAppend_RightArrayIsNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(1, builder.toComparison()); [EOL] } [EOL] public void testAppend_BothArraysAreNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] char[] lhs = null; [EOL] char[] rhs = null; [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] } [EOL] public void testAppend_ComparisonAlreadySet() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This should set comparison to a non-zero value [EOL] char[] lhs = new char[]{'a', 'b', 'c'}; [EOL] char[] rhs = new char[]{'x', 'y', 'z'}; [EOL] builder.append(lhs, rhs); // This should not change the comparison since it's already set [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendSameDoubleArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] double[] array1 = {1.0, 2.0, 3.0}; [EOL] double[] array2 = array1; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendDifferentDoubleArraysDifferentLengths() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] double[] array1 = {1.0, 2.0, 3.0}; [EOL] double[] array2 = {1.0, 2.0}; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendDifferentDoubleArraysSameLength() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] double[] array1 = {1.0, 2.0, 3.0}; [EOL] double[] array2 = {4.0, 5.0, 6.0}; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendNonNullDoubleArrayToNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] double[] array1 = {1.0, 2.0, 3.0}; [EOL] double[] array2 = null; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendNullDoubleArrayToNonNull() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] double[] array1 = null; [EOL] double[] array2 = {1.0, 2.0, 3.0}; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendBothNullDoubleArrays() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] double[] array1 = null; [EOL] double[] array2 = null; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendDoubleArraysEarlyExit() { [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1.0, 2.0); // This will set comparison to non-zero [EOL] double[] array1 = {1.0, 2.0, 3.0}; [EOL] double[] array2 = {1.0, 2.0, 3.0}; [EOL] builder.append(array1, array2); [EOL] }
public void testAppendFloatArraysWithEqualValues() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendFloatArraysFirstShorter() { [EOL] float[] lhs = {1.0f, 2.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppendFloatArraysFirstLonger() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppendFloatArraysFirstNull() { [EOL] float[] lhs = null; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() < 0); [EOL] }
public void testAppendFloatArraysSecondNull() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = null; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() > 0); [EOL] }
public void testAppendFloatArraysBothNull() { [EOL] float[] lhs = null; [EOL] float[] rhs = null; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertEquals(0, builder.toComparison()); [EOL] }
public void testAppendFloatArraysDifferentValues() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 4.0f}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testAppendFloatArraysWhenComparisonIsNonZero() { [EOL] float[] lhs = {1.0f, 2.0f, 3.0f}; [EOL] float[] rhs = {1.0f, 2.0f, 3.0f}; [EOL] CompareToBuilder builder = new CompareToBuilder(); [EOL] builder.append(1, 2); // This will set comparison to a non-zero value [EOL] builder.append(lhs, rhs); [EOL] assertTrue(builder.toComparison() != 0); [EOL] }
public void testIndexOf_NullSeq() { [EOL] int result = StringUtils.indexOf(null, "test"); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOf_NullSearchSeq() { [EOL] int result = StringUtils.indexOf("test", null); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOf_ValidSeqSearchSeq() { [EOL] int result = StringUtils.indexOf("test", "es"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOf_EmptySeq() { [EOL] int result = StringUtils.indexOf("", "es"); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testIndexOf_EmptySearchSeq() { [EOL] int result = StringUtils.indexOf("test", ""); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOf_NotFound() { [EOL] int result = StringUtils.indexOf("test", "xyz"); [EOL] assertEquals(-1, result); [EOL] }
public void testIndexOf_NullSeq() { [EOL] int result = StringUtils.indexOf(null, "test", 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_NullSearchSeq() { [EOL] int result = StringUtils.indexOf("test", null, 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_ValidInput() { [EOL] int result = StringUtils.indexOf("test", "es", 0); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOf_ValidInputWithStartPos() { [EOL] int result = StringUtils.indexOf("test", "es", 2); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_EmptySearchSeq() { [EOL] int result = StringUtils.indexOf("test", "", 0); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOf_EmptySeq() { [EOL] int result = StringUtils.indexOf("", "es", 0); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOf_StartPosOutOfBounds() { [EOL] int result = StringUtils.indexOf("test", "es", 5); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testLastIndexOf_NullSeq() { [EOL] int result = StringUtils.lastIndexOf(null, "test"); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_NullSearchSeq() { [EOL] int result = StringUtils.lastIndexOf("test", null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_BothNull() { [EOL] int result = StringUtils.lastIndexOf(null, null); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testLastIndexOf_NonNull() { [EOL] int result = StringUtils.lastIndexOf("test", "st"); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testLastIndexOf_EmptySearchSeq() { [EOL] int result = StringUtils.lastIndexOf("test", ""); [EOL] assertEquals(4, result); [EOL] } [EOL] public void testLastIndexOf_NotFound() { [EOL] int result = StringUtils.lastIndexOf("test", "xyz"); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] }
public void testContainsAny_EmptyInput() { [EOL] assertFalse(StringUtils.containsAny("", 'a', 'b')); [EOL] assertFalse(StringUtils.containsAny(null, 'a', 'b')); [EOL] assertFalse(StringUtils.containsAny("abc", new char[] {})); [EOL] assertFalse(StringUtils.containsAny("abc", (char[]) null)); [EOL] }
public void testContainsAny_SingleCharInput() { [EOL] assertTrue(StringUtils.containsAny("a", 'a')); [EOL] assertFalse(StringUtils.containsAny("a", 'b')); [EOL] }
public void testContainsAny_MultipleCharInput() { [EOL] assertTrue(StringUtils.containsAny("abc", 'a', 'b')); [EOL] assertTrue(StringUtils.containsAny("abc", 'b', 'c')); [EOL] assertFalse(StringUtils.containsAny("abc", 'x', 'y')); [EOL] }
public void testContainsAny_SurrogatePairs() { [EOL] assertTrue(StringUtils.containsAny("a\uD83D\uDE00bc", '\uD83D', '\uDE00')); [EOL] assertFalse(StringUtils.containsAny("a\uD83D\uDE00bc", '\uD83D', '\uDC00')); [EOL] assertTrue(StringUtils.containsAny("a\uD83D\uDE00bc", '\uD83D', '\uDE00', 'a')); [EOL] assertTrue(StringUtils.containsAny("a\uD83D\uDE00bc", 'a', '\uDE00')); [EOL] }
public void testIndexOfAnyBut_EmptySeq() { [EOL] final int result = StringUtils.indexOfAnyBut("", "abc"); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_EmptySearchChars() { [EOL] final int result = StringUtils.indexOfAnyBut("xyz", ""); [EOL] assertEquals(StringUtils.INDEX_NOT_FOUND, result); [EOL] } [EOL] public void testIndexOfAnyBut_NoMatch() { [EOL] final int result = StringUtils.indexOfAnyBut("abc", "xyz"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_MatchAtStart() { [EOL] final int result = StringUtils.indexOfAnyBut("axyz", "abc"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAnyBut_MatchAtEnd() { [EOL] final int result = StringUtils.indexOfAnyBut("xyzc", "abc"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_MatchInMiddle() { [EOL] final int result = StringUtils.indexOfAnyBut("axcyz", "abc"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairAtStart() { [EOL] final int result = StringUtils.indexOfAnyBut("\uD83D\uDE00xyz", "\uD83D\uDE00"); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairInMiddle() { [EOL] final int result = StringUtils.indexOfAnyBut("a\uD83D\uDE00yz", "abc"); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairAtEnd() { [EOL] final int result = StringUtils.indexOfAnyBut("axyz\uD83D\uDE00", "abc"); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testIndexOfAnyBut_SurrogatePairNoMatch() { [EOL] final int result = StringUtils.indexOfAnyBut("axyz\uD83D\uDE00", "\uD83D\uDE00"); [EOL] assertEquals(0, result); [EOL] }
public void testContainsNoneWithNullInputs() { [EOL] assertTrue(StringUtils.containsNone(null, (char[]) null)); [EOL] }
public void testContainsNoneWithEmptyCharSequence() { [EOL] assertTrue(StringUtils.containsNone("", 'a', 'b')); [EOL] }
public void testContainsNoneWithEmptySearchChars() { [EOL] assertTrue(StringUtils.containsNone("abc", new char[] {})); [EOL] }
public void testContainsNoneWithNonMatchingChar() { [EOL] assertTrue(StringUtils.containsNone("abc", 'x', 'y')); [EOL] }
public void testContainsNoneWithMatchingChar() { [EOL] assertFalse(StringUtils.containsNone("abc", 'b', 'x')); [EOL] }
public void testContainsNoneWithSurrogatePairAtEnd() { [EOL] assertFalse(StringUtils.containsNone("a\uD83D\uDE00", '\uD83D', '\uDE00')); [EOL] }
public void testContainsNoneWithHighSurrogateCharWithoutPair() { [EOL] assertTrue(StringUtils.containsNone("a\uD83D", '\uDE00')); [EOL] }
public void testContainsNoneWithHighSurrogateCharWithNonMatchingPair() { [EOL] assertTrue(StringUtils.containsNone("a\uD83D\uDE01", '\uD83D', '\uDE00')); [EOL] }
public void testContainsNoneWithNullInputs() { [EOL] assertTrue(StringUtils.containsNone(null, (String) null)); [EOL] } [EOL] public void testContainsNoneWithValidInputAndNullInvalidChars() { [EOL] assertTrue(StringUtils.containsNone("abc", (String) null)); [EOL] } [EOL] public void testContainsNoneWithNullInputAndValidInvalidChars() { [EOL] assertTrue(StringUtils.containsNone(null, "xyz")); [EOL] } [EOL] public void testContainsNoneWithNonMatchingInvalidChars() { [EOL] assertTrue(StringUtils.containsNone("abc", "xyz")); [EOL] } [EOL] public void testContainsNoneWithMatchingInvalidChars() { [EOL] assertFalse(StringUtils.containsNone("abc", "bc")); [EOL] }

public void testSubstring_NullInput() { [EOL] String result = StringUtils.substring(null, 0); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstring_NegativeStartIndexGreaterThanLength() { [EOL] String result = StringUtils.substring("abc", -4); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstring_NegativeStartIndexLessThanLength() { [EOL] String result = StringUtils.substring("abc", -2); [EOL] assertEquals("bc", result); [EOL] } [EOL] public void testSubstring_StartIndexWithinBounds() { [EOL] String result = StringUtils.substring("abcdef", 2); [EOL] assertEquals("cdef", result); [EOL] } [EOL] public void testSubstring_StartIndexEqualsLength() { [EOL] String result = StringUtils.substring("abc", 3); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstring_StartIndexGreaterThanLength() { [EOL] String result = StringUtils.substring("abc", 4); [EOL] assertEquals("", result); [EOL] }
public void testSubstringBeforeLast_NullString() { [EOL] String result = StringUtils.substringBeforeLast(null, "separator"); [EOL] assertNull(result); [EOL] } [EOL] public void testSubstringBeforeLast_NullSeparator() { [EOL] String result = StringUtils.substringBeforeLast("str", null); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testSubstringBeforeLast_EmptyString() { [EOL] String result = StringUtils.substringBeforeLast("", "separator"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSubstringBeforeLast_EmptySeparator() { [EOL] String result = StringUtils.substringBeforeLast("str", ""); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testSubstringBeforeLast_SeparatorNotFound() { [EOL] String result = StringUtils.substringBeforeLast("str", "notfound"); [EOL] assertEquals("str", result); [EOL] } [EOL] public void testSubstringBeforeLast_SeparatorFound() { [EOL] String result = StringUtils.substringBeforeLast("str-separator-str", "-"); [EOL] assertEquals("str-separator", result); [EOL] } [EOL] public void testSubstringBeforeLast_SeparatorAtEnd() { [EOL] String result = StringUtils.substringBeforeLast("str-separator-", "-"); [EOL] assertEquals("str-separator", result); [EOL] }
public void testSplit_NullString() { [EOL] String[] result = StringUtils.split(null); [EOL] assertNull(result); [EOL] }
public void testSplit_EmptyString() { [EOL] String[] result = StringUtils.split(""); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplit_WhiteSpaceString() { [EOL] String[] result = StringUtils.split(" "); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testSplit_SimpleString() { [EOL] String[] result = StringUtils.split("abc def"); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals("abc", result[0]); [EOL] assertEquals("def", result[1]); [EOL] }
public void testSplitByWholeSeparator_NullString() { [EOL] String[] result = StringUtils.splitByWholeSeparator(null, ","); [EOL] assertNull(result); [EOL] }
public void testSplitByWholeSeparator_NullSeparator() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a,b,c", null); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a,b,c", result[0]); [EOL] }
public void testSplitByWholeSeparator_EmptySeparator() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a,b,c", ""); [EOL] assertEquals(5, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[2]); [EOL] assertEquals("c", result[4]); [EOL] }
public void testSplitByWholeSeparator_SeparatorNotFound() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a,b,c", "x"); [EOL] assertEquals(1, result.length); [EOL] assertEquals("a,b,c", result[0]); [EOL] }
public void testSplitByWholeSeparator_SeparatorFound() { [EOL] String[] result = StringUtils.splitByWholeSeparator("a//b//c", "//"); [EOL] assertEquals(3, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] }
public void testJoin_WithNullElements() { [EOL] String result = StringUtils.join((Object[]) null, null); [EOL] assertNull(result); [EOL] }
public void testJoin_WithEmptyElements() { [EOL] String result = StringUtils.join(new Object[]{}, null); [EOL] assertEquals("", result); [EOL] }
public void testJoin_WithNonNullElementsAndNullSeparator() { [EOL] String result = StringUtils.join(new String[]{"a", "b", "c"}, null); [EOL] assertEquals("abc", result); [EOL] }
public void testJoin_WithNonNullElementsAndNonNullSeparator() { [EOL] String result = StringUtils.join(new String[]{"a", "b", "c"}, ","); [EOL] assertEquals("a,b,c", result); [EOL] }
public void testJoin_LongArrayWithSeparator_NullArray() { [EOL] long[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] }
public void testJoin_LongArrayWithSeparator_EmptyArray() { [EOL] long[] array = new long[0]; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] }
public void testJoin_LongArrayWithSeparator_SingleElement() { [EOL] long[] array = new long[]{1}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1", result); [EOL] }
public void testJoin_LongArrayWithSeparator_MultipleElements() { [EOL] long[] array = new long[]{1, 2, 3}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1,2,3", result); [EOL] }
public void testJoinShortArrayWithSeparatorNullArray() { [EOL] short[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] }
public void testJoinShortArrayWithSeparatorEmptyArray() { [EOL] short[] array = new short[0]; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] }
public void testJoinShortArrayWithSeparatorNonEmptyArray() { [EOL] short[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1,2,3", result); [EOL] }
public void testJoinArrayWithSeparator_NullArray() { [EOL] double[] array = null; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertNull(result); [EOL] } [EOL] public void testJoinArrayWithSeparator_EmptyArray() { [EOL] double[] array = new double[0]; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoinArrayWithSeparator_SingleElement() { [EOL] double[] array = {1.0}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1.0", result); [EOL] } [EOL] public void testJoinArrayWithSeparator_MultipleElements() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] char separator = ','; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1.0,2.0,3.0", result); [EOL] } [EOL] public void testJoinArrayWithSeparator_DifferentSeparator() { [EOL] double[] array = {1.0, 2.0, 3.0}; [EOL] char separator = ';'; [EOL] String result = StringUtils.join(array, separator); [EOL] assertEquals("1.0;2.0;3.0", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_ArrayIsNull() { [EOL] long[] array = null; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 2; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertNull(result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_EmptyArray() { [EOL] long[] array = new long[0]; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 0; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_NegativeStartIndex() { [EOL] long[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] int startIndex = -1; [EOL] int endIndex = 2; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1,2", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_EndIndexExceedsLength() { [EOL] long[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 5; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1,2,3", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_ValidInput() { [EOL] long[] array = {1, 2, 3}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 3; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1,2,3", result); [EOL] }
public void testJoinArrayWithSeparatorStartIndexEndIndex_SingleElement() { [EOL] long[] array = {1}; [EOL] char separator = ','; [EOL] int startIndex = 0; [EOL] int endIndex = 1; [EOL] String result = StringUtils.join(array, separator, startIndex, endIndex); [EOL] assertEquals("1", result); [EOL] }
public void testJoin_NullArray() { [EOL] String result = StringUtils.join((short[]) null, ',', 0, 10); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_EmptyArray() { [EOL] String result = StringUtils.join(new short[0], ',', 0, 0); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_ValidArray() { [EOL] short[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ';', 0, array.length); [EOL] assertEquals("1;2;3", result); [EOL] } [EOL] public void testJoin_PartialArray() { [EOL] short[] array = {1, 2, 3, 4, 5}; [EOL] String result = StringUtils.join(array, ':', 1, 4); [EOL] assertEquals("2:3:4", result); [EOL] } [EOL] public void testJoin_SingleElement() { [EOL] short[] array = {100}; [EOL] String result = StringUtils.join(array, ',', 0, 1); [EOL] assertEquals("100", result); [EOL] } [EOL] public void testJoin_EndIndexExceeds() { [EOL] short[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 0, 5); [EOL] assertEquals("1,2,3", result); [EOL] } [EOL] public void testJoin_NegativeStartIndex() { [EOL] short[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', -1, 2); [EOL] assertEquals("1,2", result); [EOL] } [EOL] public void testJoin_StartIndexGreaterThanEndIndex() { [EOL] short[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 3, 2); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_StartIndexEqualsEndIndex() { [EOL] short[] array = {1, 2, 3}; [EOL] String result = StringUtils.join(array, ',', 2, 2); [EOL] assertEquals("", result); [EOL] }
public void testJoin_NullArray() { [EOL] String result = StringUtils.join((double[]) null, ',', 0, 10); [EOL] assertNull(result); [EOL] } [EOL] public void testJoin_EmptyArray() { [EOL] String result = StringUtils.join(new double[0], ',', 0, 0); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_ValidArray() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] String result = StringUtils.join(array, ';', 1, 3); [EOL] assertEquals("2.2;3.3", result); [EOL] } [EOL] public void testJoin_InvalidStartIndex() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] String result = StringUtils.join(array, ',', 4, 2); [EOL] assertEquals("", result); [EOL] } [EOL] public void testJoin_EndIndexEqualsArrayLength() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] String result = StringUtils.join(array, ',', 0, array.length); [EOL] assertEquals("1.1,2.2,3.3,4.4", result); [EOL] } [EOL] public void testJoin_StartIndexEqualsEndIndex() { [EOL] double[] array = {1.1, 2.2, 3.3, 4.4}; [EOL] String result = StringUtils.join(array, ',', 2, 2); [EOL] assertEquals("", result); [EOL] }

public void testRemoveStart_NullString() { [EOL] String result = StringUtils.removeStart(null, "remove"); [EOL] assertNull(result); [EOL] } [EOL] public void testRemoveStart_NullRemove() { [EOL] String result = StringUtils.removeStart("string", null); [EOL] assertEquals("string", result); [EOL] } [EOL] public void testRemoveStart_EmptyString() { [EOL] String result = StringUtils.removeStart("", "remove"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testRemoveStart_EmptyRemove() { [EOL] String result = StringUtils.removeStart("string", ""); [EOL] assertEquals("string", result); [EOL] } [EOL] public void testRemoveStart_StringDoesNotStartWithRemove() { [EOL] String result = StringUtils.removeStart("string", "start"); [EOL] assertEquals("string", result); [EOL] } [EOL] public void testRemoveStart_StringStartsWithRemove() { [EOL] String result = StringUtils.removeStart("startString", "start"); [EOL] assertEquals("String", result); [EOL] }
public void testRemoveStart_StringEqualsRemove() { [EOL] String result = StringUtils.removeStart("start", "start"); [EOL] assertEquals("", result); [EOL] }
public void testReplaceEachRepeatedly_NullText() { [EOL] String result = StringUtils.replaceEachRepeatedly(null, new String[]{"a"}, new String[]{"b"}); [EOL] assertNull(result); [EOL] }
public void testReplaceEachRepeatedly_EmptyText() { [EOL] String result = StringUtils.replaceEachRepeatedly("", new String[]{"a"}, new String[]{"b"}); [EOL] assertEquals("", result); [EOL] }
public void testReplaceEachRepeatedly_NullSearchList() { [EOL] String result = StringUtils.replaceEachRepeatedly("any", null, new String[]{"b"}); [EOL] assertEquals("any", result); [EOL] }
public void testReplaceEachRepeatedly_NullReplacementList() { [EOL] String result = StringUtils.replaceEachRepeatedly("any", new String[]{"a"}, null); [EOL] assertEquals("any", result); [EOL] }
public void testReplaceEachRepeatedly_EmptySearchAndReplacementList() { [EOL] String result = StringUtils.replaceEachRepeatedly("any", new String[]{}, new String[]{}); [EOL] assertEquals("any", result); [EOL] }
public void testReplaceEachRepeatedly_NonEmptyTextWithReplacements() { [EOL] String result = StringUtils.replaceEachRepeatedly("abc", new String[]{"a", "b"}, new String[]{"A", "B"}); [EOL] assertEquals("ABc", result); [EOL] }
public void testReplaceEachRepeatedly_ReplacementsWithEmptyStrings() { [EOL] String result = StringUtils.replaceEachRepeatedly("abc", new String[]{"a", "b"}, new String[]{"", ""}); [EOL] assertEquals("c", result); [EOL] }
public void testReplaceEachRepeatedly_ReplacementsCausingRecursion() { [EOL] String result = StringUtils.replaceEachRepeatedly("abc", new String[]{"ab", "bc"}, new String[]{"bc", "ab"}); [EOL] assertEquals("bc", result); [EOL] }
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL] if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL] return text; [EOL] } [EOL] if (timeToLive < 0) { [EOL] throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL] } [EOL] final int searchLength = searchList.length; [EOL] final int replacementLength = replacementList.length; [EOL] if (searchLength != replacementLength) { [EOL] throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL] } [EOL] final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL] int textIndex = -1; [EOL] int replaceIndex = -1; [EOL] int tempIndex = -1; [EOL] for (int i = 0; i < searchLength; i++) { [EOL] if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL] continue; [EOL] } [EOL] tempIndex = text.indexOf(searchList[i]); [EOL] if (tempIndex == -1) { [EOL] noMoreMatchesForReplIndex[i] = true; [EOL] } else { [EOL] if (textIndex == -1 || tempIndex < textIndex) { [EOL] textIndex = tempIndex; [EOL] replaceIndex = i; [EOL] } [EOL] } [EOL] } [EOL] if (textIndex == -1) { [EOL] return text; [EOL] } [EOL] int start = 0; [EOL] int increase = 0; [EOL] for (int i = 0; i < searchList.length; i++) { [EOL] if (searchList[i] == null || replacementList[i] == null) { [EOL] continue; [EOL] } [EOL] final int greater = replacementList[i].length() - searchList[i].length(); [EOL] if (greater > 0) { [EOL] increase += 3 * greater; [EOL] } [EOL] } [EOL] increase = Math.min(increase, text.length() / 5); [EOL] final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL] while (textIndex != -1) { [EOL] for (int i = start; i < textIndex; i++) { [EOL] buf.append(text.charAt(i)); [EOL] } [EOL] buf.append(replacementList[replaceIndex]); [EOL] start = textIndex + searchList[replaceIndex].length(); [EOL] textIndex = -1; [EOL] replaceIndex = -1; [EOL] tempIndex = -1; [EOL] for (int i = 0; i < searchLength; i++) { [EOL] if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) { [EOL] continue; [EOL] } [EOL] tempIndex = text.indexOf(searchList[i], start); [EOL] if (tempIndex == -1) { [EOL] noMoreMatchesForReplIndex[i] = true; [EOL] } else { [EOL] if (textIndex == -1 || tempIndex < textIndex) { [EOL] textIndex = tempIndex; [EOL] replaceIndex = i; [EOL] } [EOL] } [EOL] } [EOL] } [EOL] final int textLength = text.length(); [EOL] for (int i = start; i < textLength; i++) { [EOL] buf.append(text.charAt(i)); [EOL] } [EOL] final String result = buf.toString(); [EOL] if (!repeat) { [EOL] return result; [EOL] } [EOL] return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] }
public void testChomp_NullInput() { [EOL] String result = StringUtils.chomp(null); [EOL] assertNull(result); [EOL] } [EOL] public void testChomp_EmptyString() { [EOL] String result = StringUtils.chomp(""); [EOL] assertEquals("", result); [EOL] } [EOL] public void testChomp_StringWithoutCRorLF() { [EOL] String result = StringUtils.chomp("abc"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testChomp_StringEndsWithCR() { [EOL] String result = StringUtils.chomp("abc\r"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testChomp_StringEndsWithLF() { [EOL] String result = StringUtils.chomp("abc\n"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testChomp_StringEndsWithCRLF() { [EOL] String result = StringUtils.chomp("abc\r\n"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testChomp_StringWithOnlyCR() { [EOL] String result = StringUtils.chomp("\r"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testChomp_StringWithOnlyLF() { [EOL] String result = StringUtils.chomp("\n"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testChomp_StringWithOnlyCRLF() { [EOL] String result = StringUtils.chomp("\r\n"); [EOL] assertEquals("", result); [EOL] }
public void testChomp_NullStr() { [EOL] String result = StringUtils.chomp(null, "irrelevant"); [EOL] assertNull(result); [EOL] }
public void testChomp_NullSeparator() { [EOL] String str = "abc"; [EOL] String result = StringUtils.chomp(str, null); [EOL] assertEquals("abc", result); [EOL] }
public void testChomp_EmptySeparator() { [EOL] String str = "abc"; [EOL] String result = StringUtils.chomp(str, ""); [EOL] assertEquals("abc", result); [EOL] }
public void testChomp_StringWithoutSeparator() { [EOL] String str = "abc"; [EOL] String result = StringUtils.chomp(str, "xyz"); [EOL] assertEquals("abc", result); [EOL] }
public void testChomp_StringWithSeparatorAtEnd() { [EOL] String str = "abcxyz"; [EOL] String result = StringUtils.chomp(str, "xyz"); [EOL] assertEquals("abc", result); [EOL] }
public void testChomp_StringWithSeparatorNotAtEnd() { [EOL] String str = "abcxyzdef"; [EOL] String result = StringUtils.chomp(str, "xyz"); [EOL] assertEquals("abcxyzdef", result); [EOL] }
public void testChomp_EmptyString() { [EOL] String result = StringUtils.chomp("", "xyz"); [EOL] assertEquals("", result); [EOL] }
public void testRepeat_NullStrNullSeparator() { [EOL] String repeated = StringUtils.repeat(null, null, 2); [EOL] assertNull(repeated); [EOL] }
public void testRepeat_NullStrNonNullSeparator() { [EOL] String repeated = StringUtils.repeat(null, ",", 2); [EOL] assertNull(repeated); [EOL] }
public void testRepeat_EmptyStrEmptySeparator() { [EOL] String repeated = StringUtils.repeat("", "", 2); [EOL] assertEquals("", repeated); [EOL] }
public void testRepeat_NonEmptyStrEmptySeparator() { [EOL] String repeated = StringUtils.repeat("abc", "", 2); [EOL] assertEquals("abcabc", repeated); [EOL] }
public void testRepeat_EmptyStrNonNullSeparator() { [EOL] String repeated = StringUtils.repeat("", ",", 2); [EOL] assertEquals("", repeated); [EOL] }
public void testRepeat_NonEmptyStrNonNullSeparator() { [EOL] String repeated = StringUtils.repeat("abc", ",", 2); [EOL] assertEquals("abc,abc", repeated); [EOL] }
public void testRepeat_NonEmptyStrNonNullSeparatorZeroTimes() { [EOL] String repeated = StringUtils.repeat("abc", ",", 0); [EOL] assertEquals("", repeated); [EOL] }
public void testRepeat_NonEmptyStrNonNullSeparatorNegativeTimes() { [EOL] String repeated = StringUtils.repeat("abc", ",", -1); [EOL] assertEquals("", repeated); [EOL] }
public void testSwapCaseEmptyString() { [EOL] String input = ""; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("", result); [EOL] } [EOL] public void testSwapCaseNullString() { [EOL] String input = null; [EOL] String result = StringUtils.swapCase(input); [EOL] assertNull(result); [EOL] } [EOL] public void testSwapCaseMixedString() { [EOL] String input = "The Quick BROWN Fox"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("tHE qUICK brown fOX", result); [EOL] } [EOL] public void testSwapCaseUpperCaseString() { [EOL] String input = "UPPERCASE"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("uppercase", result); [EOL] } [EOL] public void testSwapCaseLowerCaseString() { [EOL] String input = "lowercase"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("LOWERCASE", result); [EOL] } [EOL] public void testSwapCaseTitleCaseString() { [EOL] String input = "TitleCase"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("tITLEcASE", result); [EOL] } [EOL] public void testSwapCaseSpecialCharactersString() { [EOL] String input = "12345!@#$%"; [EOL] String result = StringUtils.swapCase(input); [EOL] assertEquals("12345!@#$%", result); [EOL] }
public void testIsAlphaSpace_NullInput() { [EOL] boolean result = StringUtils.isAlphaSpace(null); [EOL] assertFalse(result); [EOL] }
public void testIsAlphaSpace_EmptyString() { [EOL] boolean result = StringUtils.isAlphaSpace(""); [EOL] assertTrue(result); [EOL] }
public void testIsAlphaSpace_AlphaOnly() { [EOL] boolean result = StringUtils.isAlphaSpace("abc"); [EOL] assertTrue(result); [EOL] }
public void testIsAlphaSpace_SpaceOnly() { [EOL] boolean result = StringUtils.isAlphaSpace("   "); [EOL] assertTrue(result); [EOL] }
public void testIsAlphaSpace_AlphaAndSpace() { [EOL] boolean result = StringUtils.isAlphaSpace("abc def"); [EOL] assertTrue(result); [EOL] }
public void testIsAlphaSpace_NonAlpha() { [EOL] boolean result = StringUtils.isAlphaSpace("abc123"); [EOL] assertFalse(result); [EOL] }
public void testIsAlphaSpace_NonSpaceWhitespace() { [EOL] boolean result = StringUtils.isAlphaSpace("abc\n"); [EOL] assertFalse(result); [EOL] }
public void testDefaultIfBlankWithBlankString() { [EOL] String input = " "; [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultIfBlank(input, defaultStr); [EOL] assertEquals("default", result); [EOL] }
public void testDefaultIfBlankWithNonBlankString() { [EOL] String input = "non-blank"; [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultIfBlank(input, defaultStr); [EOL] assertEquals("non-blank", result); [EOL] }
public void testDefaultIfBlankWithNullInput() { [EOL] String input = null; [EOL] String defaultStr = "default"; [EOL] String result = StringUtils.defaultIfBlank(input, defaultStr); [EOL] assertEquals("default", result); [EOL] }
public void testDefaultIfBlankWithNullDefault() { [EOL] String input = " "; [EOL] String defaultStr = null; [EOL] String result = StringUtils.defaultIfBlank(input, defaultStr); [EOL] assertNull(result); [EOL] }
public void testDefaultIfBlankWithBothNull() { [EOL] String input = null; [EOL] String defaultStr = null; [EOL] String result = StringUtils.defaultIfBlank(input, defaultStr); [EOL] assertNull(result); [EOL] }
public void testIndexOfDifference_SameCharSequences() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = "abc"; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfDifference_FirstCharSequenceNull() { [EOL] CharSequence cs1 = null; [EOL] CharSequence cs2 = "abc"; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_SecondCharSequenceNull() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = null; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_CharSequencesDifferentLengths() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = "abcd"; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(3, result); [EOL] }
public void testIndexOfDifference_CharSequencesDifferent() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = "abd"; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(2, result); [EOL] }
public void testIndexOfDifference_EmptyCharSequences() { [EOL] final int INDEX_NOT_FOUND = -1; [EOL] CharSequence cs1 = ""; [EOL] CharSequence cs2 = ""; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(INDEX_NOT_FOUND, result); [EOL] }
public void testIndexOfDifference_FirstEmptyCharSequence() { [EOL] CharSequence cs1 = ""; [EOL] CharSequence cs2 = "abc"; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testIndexOfDifference_SecondEmptyCharSequence() { [EOL] CharSequence cs1 = "abc"; [EOL] CharSequence cs2 = ""; [EOL] int result = indexOfDifference(cs1, cs2); [EOL] assertEquals(0, result); [EOL] }
public void testGetCommonPrefix_NullArray() { [EOL] String result = StringUtils.getCommonPrefix((String[]) null); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetCommonPrefix_EmptyArray() { [EOL] String result = StringUtils.getCommonPrefix(); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetCommonPrefix_ArrayWithNullElement() { [EOL] String result = StringUtils.getCommonPrefix(new String[]{null}); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetCommonPrefix_NoCommonPrefix() { [EOL] String result = StringUtils.getCommonPrefix("abc", "def"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetCommonPrefix_CommonPrefixAtStart() { [EOL] String result = StringUtils.getCommonPrefix("abc", "abcd"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testGetCommonPrefix_AllStringsIdentical() { [EOL] String result = StringUtils.getCommonPrefix("abc", "abc", "abc"); [EOL] assertEquals("abc", result); [EOL] } [EOL] public void testGetCommonPrefix_MixedNullAndNotNull() { [EOL] String result = StringUtils.getCommonPrefix(null, "abc", null, "abc"); [EOL] assertEquals("", result); [EOL] } [EOL] public void testGetCommonPrefix_SingleString() { [EOL] String result = StringUtils.getCommonPrefix("abc"); [EOL] assertEquals("abc", result); [EOL] }
public void testGetLevenshteinDistance_NullArguments() { [EOL] try { [EOL] StringUtils.getLevenshteinDistance(null, "test"); [EOL] fail("Expected IllegalArgumentException for null first parameter"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] try { [EOL] StringUtils.getLevenshteinDistance("test", null); [EOL] fail("Expected IllegalArgumentException for null second parameter"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetLevenshteinDistance_EmptyStrings() { [EOL] assertEquals(0, StringUtils.getLevenshteinDistance("", "")); [EOL] assertEquals(4, StringUtils.getLevenshteinDistance("", "test")); [EOL] assertEquals(4, StringUtils.getLevenshteinDistance("test", "")); [EOL] }
public void testGetLevenshteinDistance_SameLengthStrings() { [EOL] assertEquals(0, StringUtils.getLevenshteinDistance("test", "test")); [EOL] assertEquals(2, StringUtils.getLevenshteinDistance("test", "tost")); [EOL] assertEquals(4, StringUtils.getLevenshteinDistance("test", "abcd")); [EOL] }
public void testGetLevenshteinDistance_DifferentLengthStrings() { [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("tests", "test")); [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("test", "tests")); [EOL] assertEquals(3, StringUtils.getLevenshteinDistance("test", "testing")); [EOL] assertEquals(6, StringUtils.getLevenshteinDistance("back", "background")); [EOL] }
public void testGetLevenshteinDistance_SpecialCharacters() { [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("test!", "test")); [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("test", "test!")); [EOL] assertEquals(3, StringUtils.getLevenshteinDistance("test#", "test!@#")); [EOL] }
public void testGetLevenshteinDistance_CaseSensitivity() { [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("Test", "test")); [EOL] assertEquals(1, StringUtils.getLevenshteinDistance("TEST", "test")); [EOL] }
public void testStartsWithIgnoreCase_NullStrings() { [EOL] boolean result = StringUtils.startsWithIgnoreCase(null, null); [EOL] assertTrue(result); [EOL] }
public void testStartsWithIgnoreCase_NullPrefix() { [EOL] boolean result = StringUtils.startsWithIgnoreCase("abc", null); [EOL] assertFalse(result); [EOL] }
public void testStartsWithIgnoreCase_EmptyStrings() { [EOL] boolean result = StringUtils.startsWithIgnoreCase("", ""); [EOL] assertTrue(result); [EOL] }
public void testStartsWithIgnoreCase_EmptyPrefix() { [EOL] boolean result = StringUtils.startsWithIgnoreCase("abc", ""); [EOL] assertTrue(result); [EOL] }
public void testStartsWithIgnoreCase_CaseInsensitiveMatch() { [EOL] boolean result = StringUtils.startsWithIgnoreCase("abc", "AB"); [EOL] assertTrue(result); [EOL] }
public void testStartsWithIgnoreCase_CaseInsensitiveNoMatch() { [EOL] boolean result = StringUtils.startsWithIgnoreCase("abc", "BC"); [EOL] assertFalse(result); [EOL] }
public void testStartsWithIgnoreCase_CaseSensitiveNoMatch() { [EOL] boolean result = StringUtils.startsWithIgnoreCase("abc", "aBcD"); [EOL] assertFalse(result); [EOL] }
public void testStartsWithBothNull() { [EOL] assertTrue(startsWith(null, null, true)); [EOL] assertTrue(startsWith(null, null, false)); [EOL] } [EOL] public void testStartsWithFirstNull() { [EOL] assertFalse(startsWith(null, "prefix", true)); [EOL] assertFalse(startsWith(null, "prefix", false)); [EOL] } [EOL] public void testStartsWithSecondNull() { [EOL] assertFalse(startsWith("str", null, true)); [EOL] assertFalse(startsWith("str", null, false)); [EOL] } [EOL] public void testStartsWithPrefixLongerThanString() { [EOL] assertFalse(startsWith("str", "longprefix", true)); [EOL] assertFalse(startsWith("str", "longprefix", false)); [EOL] } [EOL] public void testStartsWithIgnoreCase() { [EOL] assertTrue(startsWith("string", "str", true)); [EOL] assertFalse(startsWith("string", "Str", false)); [EOL] } [EOL] public void testStartsWithCaseSensitive() { [EOL] assertTrue(startsWith("string", "str", false)); [EOL] assertFalse(startsWith("string", "STR", false)); [EOL] } [EOL] public void testStartsWithEmptyPrefix() { [EOL] assertTrue(startsWith("string", "", true)); [EOL] assertTrue(startsWith("string", "", false)); [EOL] } [EOL] public void testStartsWithEmptyString() { [EOL] assertFalse(startsWith("", "prefix", true)); [EOL] assertFalse(startsWith("", "prefix", false)); [EOL] } [EOL] public void testStartsWithEmptyBoth() { [EOL] assertTrue(startsWith("", "", true)); [EOL] assertTrue(startsWith("", "", false)); [EOL] }
public void testEndsWith_NullStr() { [EOL] boolean result = StringUtils.endsWith(null, "suffix"); [EOL] assertFalse(result); [EOL] }
public void testEndsWith_NullSuffix() { [EOL] boolean result = StringUtils.endsWith("str", null); [EOL] assertFalse(result); [EOL] }
public void testEndsWith_BothNull() { [EOL] boolean result = StringUtils.endsWith(null, null); [EOL] assertTrue(result); [EOL] }
public void testEndsWith_EmptyStr() { [EOL] boolean result = StringUtils.endsWith("", "suffix"); [EOL] assertFalse(result); [EOL] }
public void testEndsWith_EmptySuffix() { [EOL] boolean result = StringUtils.endsWith("str", ""); [EOL] assertTrue(result); [EOL] }
public void testEndsWith_BothEmpty() { [EOL] boolean result = StringUtils.endsWith("", ""); [EOL] assertTrue(result); [EOL] }
public void testEndsWith_ValidEndsWith() { [EOL] boolean result = StringUtils.endsWith("abcdef", "def"); [EOL] assertTrue(result); [EOL] }
public void testEndsWith_InvalidEndsWith() { [EOL] boolean result = StringUtils.endsWith("abcdef", "xyz"); [EOL] assertFalse(result); [EOL] }
public void testToStringWithNullCharsetName() throws UnsupportedEncodingException { [EOL] byte[] bytes = new byte[] { 65, 66, 67 }; // ABC in ASCII [EOL] String result = StringUtils.toString(bytes, null); [EOL] assertEquals("ABC", result); [EOL] }
public void testToStringWithValidCharsetName() throws UnsupportedEncodingException { [EOL] byte[] bytes = new byte[] { 65, 66, 67 }; // ABC in ASCII [EOL] String charsetName = "UTF-8"; [EOL] String result = StringUtils.toString(bytes, charsetName); [EOL] assertEquals("ABC", result); [EOL] }
public void testIsNaN_WhenValueIsNaN() { [EOL] MutableDouble md = new MutableDouble(Double.NaN); [EOL] assertTrue(md.isNaN()); [EOL] }
public void testIsNaN_WhenValueIsNotNaN() { [EOL] MutableDouble md = new MutableDouble(0.0); [EOL] assertFalse(md.isNaN()); [EOL] }
public void testIsInfinite_PositiveInfinity() { [EOL] MutableDouble md = new MutableDouble(Double.POSITIVE_INFINITY); [EOL] assertTrue(md.isInfinite()); [EOL] }
public void testIsInfinite_NegativeInfinity() { [EOL] MutableDouble md = new MutableDouble(Double.NEGATIVE_INFINITY); [EOL] assertTrue(md.isInfinite()); [EOL] }
public void testIsInfinite_NotInfinite() { [EOL] MutableDouble md = new MutableDouble(0.0); [EOL] assertFalse(md.isInfinite()); [EOL] }
public void testHashCode_PositiveValue() { [EOL] DoubleValue dv = new DoubleValue(123.456); [EOL] final long bits = Double.doubleToLongBits(123.456); [EOL] int expected = (int) (bits ^ (bits >>> 32)); [EOL] assertEquals(expected, dv.hashCode()); [EOL] }
public void testHashCode_NegativeValue() { [EOL] DoubleValue dv = new DoubleValue(-123.456); [EOL] final long bits = Double.doubleToLongBits(-123.456); [EOL] int expected = (int) (bits ^ (bits >>> 32)); [EOL] assertEquals(expected, dv.hashCode()); [EOL] }
public void testHashCode_ZeroValue() { [EOL] DoubleValue dv = new DoubleValue(0.0); [EOL] final long bits = Double.doubleToLongBits(0.0); [EOL] int expected = (int) (bits ^ (bits >>> 32)); [EOL] assertEquals(expected, dv.hashCode()); [EOL] }
public void testHashCode_NaNValue() { [EOL] DoubleValue dv = new DoubleValue(Double.NaN); [EOL] final long bits = Double.doubleToLongBits(Double.NaN); [EOL] int expected = (int) (bits ^ (bits >>> 32)); [EOL] assertEquals(expected, dv.hashCode()); [EOL] }
public void testHashCode_PositiveInfinity() { [EOL] DoubleValue dv = new DoubleValue(Double.POSITIVE_INFINITY); [EOL] final long bits = Double.doubleToLongBits(Double.POSITIVE_INFINITY); [EOL] int expected = (int) (bits ^ (bits >>> 32)); [EOL] assertEquals(expected, dv.hashCode()); [EOL] }
public void testHashCode_NegativeInfinity() { [EOL] DoubleValue dv = new DoubleValue(Double.NEGATIVE_INFINITY); [EOL] final long bits = Double.doubleToLongBits(Double.NEGATIVE_INFINITY); [EOL] int expected = (int) (bits ^ (bits >>> 32)); [EOL] assertEquals(expected, dv.hashCode()); [EOL] }
public void testCompareTo_SameValue() { [EOL] MutableDouble first = new MutableDouble(1.0); [EOL] MutableDouble second = new MutableDouble(1.0); [EOL] int result = first.compareTo(second); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LessThan() { [EOL] MutableDouble first = new MutableDouble(1.0); [EOL] MutableDouble second = new MutableDouble(2.0); [EOL] int result = first.compareTo(second); [EOL] assertTrue(result < 0); [EOL] }
public void testCompareTo_GreaterThan() { [EOL] MutableDouble first = new MutableDouble(2.0); [EOL] MutableDouble second = new MutableDouble(1.0); [EOL] int result = first.compareTo(second); [EOL] assertTrue(result > 0); [EOL] }
protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) { [EOL] if (isRegistered(value) && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) { [EOL] appendCyclicObject(buffer, fieldName, value); [EOL] return; [EOL] } [EOL] register(value); [EOL] try { [EOL] if (value instanceof Collection<?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Collection<?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Collection<?>) value).size()); [EOL] } [EOL] } else if (value instanceof Map<?, ?>) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Map<?, ?>) value); [EOL] } else { [EOL] appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size()); [EOL] } [EOL] } else if (value instanceof long[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (long[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (long[]) value); [EOL] } [EOL] } else if (value instanceof int[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (int[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (int[]) value); [EOL] } [EOL] } else if (value instanceof short[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (short[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (short[]) value); [EOL] } [EOL] } else if (value instanceof byte[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (byte[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (byte[]) value); [EOL] } [EOL] } else if (value instanceof char[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (char[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (char[]) value); [EOL] } [EOL] } else if (value instanceof double[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (double[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (double[]) value); [EOL] } [EOL] } else if (value instanceof float[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (float[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (float[]) value); [EOL] } [EOL] } else if (value instanceof boolean[]) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (boolean[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (boolean[]) value); [EOL] } [EOL] } else if (value.getClass().isArray()) { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, (Object[]) value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, (Object[]) value); [EOL] } [EOL] } else { [EOL] if (detail) { [EOL] appendDetail(buffer, fieldName, value); [EOL] } else { [EOL] appendSummary(buffer, fieldName, value); [EOL] } [EOL] } [EOL] } finally { [EOL] unregister(value); [EOL] } [EOL] }
protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] ObjectUtils.identityToString(buffer, value); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) { [EOL] buffer.append(value); [EOL] }
public void testAppendWithValidValues() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "testField"; [EOL] int value = 123; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] }
public void testAppendWithNullFieldName() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = null; [EOL] int value = 123; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] }
public void testAppendWithEmptyBuffer() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "testField"; [EOL] int value = 123; [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] style.append(buffer, fieldName, value); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) { [EOL] buffer.append(value); [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}"];
protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) { [EOL] buffer.append(value); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendBoolean() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", true); [EOL] assertEquals("fieldName=true", buffer.toString()); [EOL] }
public void testAppendBooleanWithNullFieldName() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, null, true); [EOL] assertEquals("true", buffer.toString()); [EOL] }
public void testAppendBooleanWithEmptyFieldName() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "", true); [EOL] assertEquals("true", buffer.toString()); [EOL] }
public void testAppendBooleanWithNoFieldNameStyle() { [EOL] ToStringStyle style = new NoFieldNameToStringStyle(); [EOL] StringBuffer buffer = new StringBuffer(); [EOL] style.append(buffer, "fieldName", true); [EOL] assertEquals("true", buffer.toString()); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) { [EOL] buffer.append(value); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendWithNullArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] Object[] array = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithFullDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] Object[] array = new Object[] {"element1", "element2"}; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithSummaryDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] Object[] array = new Object[] {"element1", "element2"}; [EOL] Boolean fullDetail = false; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] final Object item = array[i]; [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] if (item == null) { [EOL] appendNullText(buffer, fieldName); [EOL] } else { [EOL] appendInternal(buffer, fieldName, item, arrayContentDetail); [EOL] } [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=-2587890625525655916L; [EOL] ToStringStyle DEFAULT_STYLE=new DefaultToStringStyle(); [EOL] ToStringStyle MULTI_LINE_STYLE=new MultiLineToStringStyle(); [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=new NoFieldNameToStringStyle(); [EOL] ToStringStyle SHORT_PREFIX_STYLE=new ShortPrefixToStringStyle(); [EOL] ToStringStyle SIMPLE_STYLE=new SimpleToStringStyle(); [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=new ThreadLocal<WeakHashMap<Object, Object>>(); [EOL] boolean useFieldNames=true; [EOL] boolean useClassName=true; [EOL] boolean useShortClassName=false; [EOL] boolean useIdentityHashCode=true; [EOL] String contentStart="["; [EOL] String contentEnd="]"; [EOL] String fieldNameValueSeparator="="; [EOL] boolean fieldSeparatorAtStart=false; [EOL] boolean fieldSeparatorAtEnd=false; [EOL] String fieldSeparator=","; [EOL] String arrayStart="{"; [EOL] String arraySeparator=","; [EOL] boolean arrayContentDetail=true; [EOL] String arrayEnd="}";
protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testAppendWithNullArray() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] short[] array = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithFullDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] short[] array = {1, 2, 3}; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void testAppendWithSummaryDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] short[] array = {1, 2, 3}; [EOL] Boolean fullDetail = false; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) { [EOL] buffer.append(arrayStart); [EOL] for (int i = 0; i < array.length; i++) { [EOL] if (i > 0) { [EOL] buffer.append(arraySeparator); [EOL] } [EOL] appendDetail(buffer, fieldName, array[i]); [EOL] } [EOL] buffer.append(arrayEnd); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=-2587890625525655916L; [EOL] ToStringStyle DEFAULT_STYLE=new DefaultToStringStyle(); [EOL] ToStringStyle MULTI_LINE_STYLE=new MultiLineToStringStyle(); [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=new NoFieldNameToStringStyle(); [EOL] ToStringStyle SHORT_PREFIX_STYLE=new ShortPrefixToStringStyle(); [EOL] ToStringStyle SIMPLE_STYLE=new SimpleToStringStyle(); [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=new ThreadLocal<WeakHashMap<Object, Object>>(); [EOL] boolean useFieldNames=true; [EOL] boolean useClassName=true; [EOL] boolean useShortClassName=false; [EOL] boolean useIdentityHashCode=true; [EOL] String contentStart="["; [EOL] String contentEnd="]"; [EOL] String fieldNameValueSeparator="="; [EOL] boolean fieldSeparatorAtStart=false; [EOL] boolean fieldSeparatorAtEnd=false; [EOL] String fieldSeparator=","; [EOL] String arrayStart="{"; [EOL] String arraySeparator=","; [EOL] boolean arrayContentDetail=true; [EOL] String arrayEnd="}";
public void append_withNullArray_shouldAppendNullText() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] boolean[] array = null; [EOL] Boolean fullDetail = true; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void append_withFullDetailTrue_shouldAppendDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] boolean[] array = new boolean[] { true, false }; [EOL] Boolean fullDetail = Boolean.TRUE; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void append_withFullDetailFalse_shouldAppendSummary() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] boolean[] array = new boolean[] { true, false }; [EOL] Boolean fullDetail = Boolean.FALSE; [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void append_withFullDetailNullAndDefaultFullDetailTrue_shouldAppendDetail() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] boolean[] array = new boolean[] { true, false }; [EOL] Boolean fullDetail = null; [EOL] setDefaultFullDetail(true); [EOL] append(buffer, fieldName, array, fullDetail); [EOL] } [EOL] public void append_withFullDetailNullAndDefaultFullDetailFalse_shouldAppendSummary() { [EOL] StringBuffer buffer = new StringBuffer(); [EOL] String fieldName = "field"; [EOL] boolean[] array = new boolean[] { true, false }; [EOL] Boolean fullDetail = null; [EOL] setDefaultFullDetail(false); [EOL] append(buffer, fieldName, array, fullDetail); [EOL] }
protected void appendFieldStart(final StringBuffer buffer, final String fieldName) { [EOL] if (useFieldNames && fieldName != null) { [EOL] buffer.append(fieldName); [EOL] buffer.append(fieldNameValueSeparator); [EOL] } [EOL] } protected ToStringStyle();  DefaultToStringStyle();  NoFieldNameToStringStyle();  ShortPrefixToStringStyle();  SimpleToStringStyle();  MultiLineToStringStyle();  static Map<Object, Object> getRegistry();  static boolean isRegistered(final Object value);  static void register(final Object value);  static void unregister(final Object value); public void appendSuper(final StringBuffer buffer, final String superToString); public void appendToString(final StringBuffer buffer, final String toString); public void appendStart(final StringBuffer buffer, final Object object); public void appendEnd(final StringBuffer buffer, final Object object); protected void removeLastFieldSeparator(final StringBuffer buffer); public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); public void append(final StringBuffer buffer, final String fieldName, final long value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); public void append(final StringBuffer buffer, final String fieldName, final int value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); public void append(final StringBuffer buffer, final String fieldName, final short value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); public void append(final StringBuffer buffer, final String fieldName, final byte value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); public void append(final StringBuffer buffer, final String fieldName, final char value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); public void append(final StringBuffer buffer, final String fieldName, final double value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); public void append(final StringBuffer buffer, final String fieldName, final float value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); public void append(final StringBuffer buffer, final String fieldName, final boolean value); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); protected void appendClassName(final StringBuffer buffer, final Object object); protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); protected void appendContentStart(final StringBuffer buffer); protected void appendContentEnd(final StringBuffer buffer); protected void appendNullText(final StringBuffer buffer, final String fieldName); protected void appendFieldSeparator(final StringBuffer buffer); protected void appendFieldStart(final StringBuffer buffer, final String fieldName); protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); protected boolean isFullDetail(final Boolean fullDetailRequest); protected String getShortClassName(final Class<?> cls); protected boolean isUseClassName(); protected void setUseClassName(final boolean useClassName); protected boolean isUseShortClassName(); protected void setUseShortClassName(final boolean useShortClassName); protected boolean isUseIdentityHashCode(); protected void setUseIdentityHashCode(final boolean useIdentityHashCode); protected boolean isUseFieldNames(); protected void setUseFieldNames(final boolean useFieldNames); protected boolean isDefaultFullDetail(); protected void setDefaultFullDetail(final boolean defaultFullDetail); protected boolean isArrayContentDetail(); protected void setArrayContentDetail(final boolean arrayContentDetail); protected String getArrayStart(); protected void setArrayStart(String arrayStart); protected String getArrayEnd(); protected void setArrayEnd(String arrayEnd); protected String getArraySeparator(); protected void setArraySeparator(String arraySeparator); protected String getContentStart(); protected void setContentStart(String contentStart); protected String getContentEnd(); protected void setContentEnd(String contentEnd); protected String getFieldNameValueSeparator(); protected void setFieldNameValueSeparator(String fieldNameValueSeparator); protected String getFieldSeparator(); protected void setFieldSeparator(String fieldSeparator); protected boolean isFieldSeparatorAtStart(); protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); protected boolean isFieldSeparatorAtEnd(); protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); protected String getNullText(); protected void setNullText(String nullText); protected String getSizeStartText(); protected void setSizeStartText(String sizeStartText); protected String getSizeEndText(); protected void setSizeEndText(String sizeEndText); protected String getSummaryObjectStartText(); protected void setSummaryObjectStartText(String summaryObjectStartText); protected String getSummaryObjectEndText(); protected void setSummaryObjectEndText(String summaryObjectEndText); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); private Object readResolve(); long serialVersionUID=Optional[-2587890625525655916L]; ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; boolean useFieldNames=Optional[true]; boolean useClassName=Optional[true]; boolean useShortClassName=Optional[false]; boolean useIdentityHashCode=Optional[true]; String contentStart=Optional["["]; String contentEnd=Optional["]"]; String fieldNameValueSeparator=Optional["="]; boolean fieldSeparatorAtStart=Optional[false]; boolean fieldSeparatorAtEnd=Optional[false]; String fieldSeparator=Optional[","]; String arrayStart=Optional["{"]; String arraySeparator=Optional[","]; boolean arrayContentDetail=Optional[true]; String arrayEnd=Optional["}"];
protected void setUseFieldNames(final boolean useFieldNames) { [EOL] this.useFieldNames = useFieldNames; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL] this.fieldSeparatorAtStart = fieldSeparatorAtStart; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected String getSizeEndText() { [EOL] return sizeEndText; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
protected void setSizeEndText(String sizeEndText) { [EOL] if (sizeEndText == null) { [EOL] sizeEndText = ""; [EOL] } [EOL] this.sizeEndText = sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL] return summaryObjectStartText; [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testSetSummaryObjectStartText_NullInput() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSummaryObjectStartText(null); [EOL] assertEquals("", style.getSummaryObjectStartText()); [EOL] }
public void testSetSummaryObjectStartText_NonNullInput() { [EOL] ToStringStyle style = new DefaultToStringStyle(); [EOL] style.setSummaryObjectStartText("Start"); [EOL] assertEquals("Start", style.getSummaryObjectStartText()); [EOL] }
DefaultToStringStyle() { [EOL] super(); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
NoFieldNameToStringStyle() { [EOL] super(); [EOL] this.setUseFieldNames(false); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
ShortPrefixToStringStyle() { [EOL] super(); [EOL] this.setUseShortClassName(true); [EOL] this.setUseIdentityHashCode(false); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected void appendClassName(final StringBuffer buffer, final Object object); [EOL] protected void appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected void appendContentStart(final StringBuffer buffer); [EOL] protected void appendContentEnd(final StringBuffer buffer); [EOL] protected void appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldSeparator(final StringBuffer buffer); [EOL] protected void appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected void appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected boolean isFullDetail(final Boolean fullDetailRequest); [EOL] protected String getShortClassName(final Class<?> cls); [EOL] protected boolean isUseClassName(); [EOL] protected void setUseClassName(final boolean useClassName); [EOL] protected boolean isUseShortClassName(); [EOL] protected void setUseShortClassName(final boolean useShortClassName); [EOL] protected boolean isUseIdentityHashCode(); [EOL] protected void setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected boolean isUseFieldNames(); [EOL] protected void setUseFieldNames(final boolean useFieldNames); [EOL] protected boolean isDefaultFullDetail(); [EOL] protected void setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected boolean isArrayContentDetail(); [EOL] protected void setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected String getArrayStart(); [EOL] protected void setArrayStart(String arrayStart); [EOL] protected String getArrayEnd(); [EOL] protected void setArrayEnd(String arrayEnd); [EOL] protected String getArraySeparator(); [EOL] protected void setArraySeparator(String arraySeparator); [EOL] protected String getContentStart(); [EOL] protected void setContentStart(String contentStart); [EOL] protected String getContentEnd(); [EOL] protected void setContentEnd(String contentEnd); [EOL] protected String getFieldNameValueSeparator(); [EOL] protected void setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected String getFieldSeparator(); [EOL] protected void setFieldSeparator(String fieldSeparator); [EOL] protected boolean isFieldSeparatorAtStart(); [EOL] protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected boolean isFieldSeparatorAtEnd(); [EOL] protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected String getNullText(); [EOL] protected void setNullText(String nullText); [EOL] protected String getSizeStartText(); [EOL] protected void setSizeStartText(String sizeStartText); [EOL] protected String getSizeEndText(); [EOL] protected void setSizeEndText(String sizeEndText); [EOL] protected String getSummaryObjectStartText(); [EOL] protected void setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected String getSummaryObjectEndText(); [EOL] protected void setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
SimpleToStringStyle() { [EOL] super(); [EOL] this.setUseClassName(false); [EOL] this.setUseIdentityHashCode(false); [EOL] this.setUseFieldNames(false); [EOL] this.setContentStart(""); [EOL] this.setContentEnd(""); [EOL] } [EOL] protected ToStringStyle(); [EOL] DefaultToStringStyle(); [EOL] NoFieldNameToStringStyle(); [EOL] ShortPrefixToStringStyle(); [EOL] SimpleToStringStyle(); [EOL] MultiLineToStringStyle(); [EOL] static Map<Object, Object> getRegistry(); [EOL] static boolean isRegistered(final Object value); [EOL] static void register(final Object value); [EOL] static void unregister(final Object value); [EOL] public void appendSuper(final StringBuffer buffer, final String superToString); [EOL] public void appendToString(final StringBuffer buffer, final String toString); [EOL] public void appendStart(final StringBuffer buffer, final Object object); [EOL] public void appendEnd(final StringBuffer buffer, final Object object); [EOL] protected void removeLastFieldSeparator(final StringBuffer buffer); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail); [EOL] protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail); [EOL] protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value); [EOL] public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail); [EOL] protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array); [EOL] public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final float[] array); [EOL] public you append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail); [EOL] protected you appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array); [EOL] protected you appendClassName(final StringBuffer buffer, final Object object); [EOL] protected you appendIdentityHashCode(final StringBuffer buffer, final Object object); [EOL] protected you appendContentStart(final StringBuffer buffer); [EOL] protected you appendContentEnd(final StringBuffer buffer); [EOL] protected you appendNullText(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldSeparator(final StringBuffer buffer); [EOL] protected you appendFieldStart(final StringBuffer buffer, final String fieldName); [EOL] protected you appendFieldEnd(final StringBuffer buffer, final String fieldName); [EOL] protected you appendSummarySize(final StringBuffer buffer, final String fieldName, final int size); [EOL] protected you isFullDetail(final Boolean fullDetailRequest); [EOL] protected you getShortClassName(final Class<?> cls); [EOL] protected you isUseClassName(); [EOL] protected you setUseClassName(final boolean useClassName); [EOL] protected you isUseShortClassName(); [EOL] protected you setUseShortClassName(final boolean useShortClassName); [EOL] protected you isUseIdentityHashCode(); [EOL] protected you setUseIdentityHashCode(final boolean useIdentityHashCode); [EOL] protected you isUseFieldNames(); [EOL] protected you setUseFieldNames(final boolean useFieldNames); [EOL] protected you isDefaultFullDetail(); [EOL] protected you setDefaultFullDetail(final boolean defaultFullDetail); [EOL] protected you isArrayContentDetail(); [EOL] protected you setArrayContentDetail(final boolean arrayContentDetail); [EOL] protected you getArrayStart(); [EOL] protected you setArrayStart(String arrayStart); [EOL] protected you getArrayEnd(); [EOL] protected you setArrayEnd(String arrayEnd); [EOL] protected you getArraySeparator(); [EOL] protected you setArraySeparator(String arraySeparator); [EOL] protected you getContentStart(); [EOL] protected you setContentStart(String contentStart); [EOL] protected you getContentEnd(); [EOL] protected you setContentEnd(String contentEnd); [EOL] protected you getFieldNameValueSeparator(); [EOL] protected you setFieldNameValueSeparator(String fieldNameValueSeparator); [EOL] protected you getFieldSeparator(); [EOL] protected you setFieldSeparator(String fieldSeparator); [EOL] protected you isFieldSeparatorAtStart(); [EOL] protected you setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart); [EOL] protected you isFieldSeparatorAtEnd(); [EOL] protected you setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd); [EOL] protected you getNullText(); [EOL] protected you setNullText(String nullText); [EOL] protected you getSizeStartText(); [EOL] protected you setSizeStartText(String sizeStartText); [EOL] protected you getSizeEndText(); [EOL] protected you setSizeEndText(String sizeEndText); [EOL] protected you getSummaryObjectStartText(); [EOL] protected you setSummaryObjectStartText(String summaryObjectStartText); [EOL] protected you getSummaryObjectEndText(); [EOL] protected you setSummaryObjectEndText(String summaryObjectEndText); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] private Object readResolve(); [EOL] long serialVersionUID=Optional[-2587890625525655916L]; [EOL] ToStringStyle DEFAULT_STYLE=Optional[new DefaultToStringStyle()]; [EOL] ToStringStyle MULTI_LINE_STYLE=Optional[new MultiLineToStringStyle()]; [EOL] ToStringStyle NO_FIELD_NAMES_STYLE=Optional[new NoFieldNameToStringStyle()]; [EOL] ToStringStyle SHORT_PREFIX_STYLE=Optional[new ShortPrefixToStringStyle()]; [EOL] ToStringStyle SIMPLE_STYLE=Optional[new SimpleToStringStyle()]; [EOL] ThreadLocal<WeakHashMap<Object, Object>> REGISTRY=Optional[new ThreadLocal<WeakHashMap<Object, Object>>()]; [EOL] boolean useFieldNames=Optional[true]; [EOL] boolean useClassName=Optional[true]; [EOL] boolean useShortClassName=Optional[false]; [EOL] boolean useIdentityHashCode=Optional[true]; [EOL] String contentStart=Optional["["]; [EOL] String contentEnd=Optional["]"]; [EOL] String fieldNameValueSeparator=Optional["="]; [EOL] boolean fieldSeparatorAtStart=Optional[false]; [EOL] boolean fieldSeparatorAtEnd=Optional[false]; [EOL] String fieldSeparator=Optional[","]; [EOL] String arrayStart=Optional["{"]; [EOL] String arraySeparator=Optional[","]; [EOL] boolean arrayContentDetail=Optional[true]; [EOL] String arrayEnd=Optional["}"];
public void testMultiLineToStringStyle() { [EOL] MultiLineToStringStyle style = new MultiLineToStringStyle(); [EOL] assertNotNull(style); [EOL] assertEquals("[", style.getContentStart()); [EOL] assertEquals(SystemUtils.LINE_SEPARATOR + "  ", style.getFieldSeparator()); [EOL] assertTrue(style.isFieldSeparatorAtStart()); [EOL] assertEquals(SystemUtils.LINE_SEPARATOR + "]", style.getContentEnd()); [EOL] }
public void testDefaultToStringStyle() { [EOL] DefaultToStringStyle style = new DefaultToStringStyle(); [EOL] assertNotNull(style); [EOL] }
public void testNoFieldNameToStringStyle() { [EOL] NoFieldNameToStringStyle style = new NoFieldNameToStringStyle(); [EOL] assertNotNull(style); [EOL] assertFalse(style.isUseFieldNames()); [EOL] }
public void testShortPrefixToStringStyle() { [EOL] ShortPrefixToStringStyle style = new ShortPrefixToStringStyle(); [EOL] assertNotNull(style); [EOL] assertTrue(style.isUseShortClassName()); [EOL] }
public void testSimpleToStringStyle() { [EOL] SimpleToStringStyle style = new SimpleToStringStyle(); [EOL] assertNotNull(style); [EOL] }
public void testTranslateWithBetweenTrueAndCodepointOutOfRange() throws IOException { [EOL] final int below = 50; [EOL] final int above = 100; [EOL] final boolean between = true; [EOL] final int codepoint = 101; // codepoint out of range [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithBetweenFalseAndCodepointInRange() throws IOException { [EOL] final int below = 50; [EOL] final int above = 100; [EOL] final boolean between = false; [EOL] final int codepoint = 75; // codepoint in range [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(below, above, between); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertFalse(result); [EOL] assertEquals("", out.toString()); [EOL] }
public void testTranslateWithCodepointAbove0xffff() throws IOException { [EOL] final int codepoint = 0x1ffff; // codepoint above 0xffff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals(escaper.toUtf16Escape(codepoint), out.toString()); [EOL] }
public void testTranslateWithCodepointAbove0xfff() throws IOException { [EOL] final int codepoint = 0x1fff; // codepoint above 0xfff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u" + escaper.hex(codepoint), out.toString()); [EOL] }
public void testTranslateWithCodepointAbove0xff() throws IOException { [EOL] final int codepoint = 0xff; // codepoint above 0xff [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u0" + escaper.hex(codepoint), out.toString()); [EOL] }
public void testTranslateWithCodepointAbove0xf() throws IOException { [EOL] final int codepoint = 0xf; // codepoint above 0xf [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u00" + escaper.hex(codepoint), out.toString()); [EOL] }
public void testTranslateWithCodepointBelow0xf() throws IOException { [EOL] final int codepoint = 0xe; // codepoint below 0xf [EOL] StringWriter out = new StringWriter(); [EOL] UnicodeEscaper escaper = new UnicodeEscaper(0, Integer.MAX_VALUE, true); [EOL] boolean result = escaper.translate(codepoint, out); [EOL] assertTrue(result); [EOL] assertEquals("\\u000" + escaper.hex(codepoint), out.toString()); [EOL] }
public void testHexDigitToInt_ValidHexDigitLowercase() { [EOL] char hexDigit = 'a'; [EOL] int result = ClassName.hexDigitToInt(hexDigit); [EOL] assertEquals(10, result); [EOL] } [EOL] public void testHexDigitToInt_ValidHexDigitUppercase() { [EOL] char hexDigit = 'A'; [EOL] int result = ClassName.hexDigitToInt(hexDigit); [EOL] assertEquals(10, result); [EOL] } [EOL] public void testHexDigitToInt_ValidHexDigitNumeric() { [EOL] char hexDigit = '9'; [EOL] int result = ClassName.hexDigitToInt(hexDigit); [EOL] assertEquals(9, result); [EOL] } [EOL] public void testHexDigitToInt_InvalidHexDigit() { [EOL] char hexDigit = 'g'; [EOL] try { [EOL] ClassName.hexDigitToInt(hexDigit); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryBeMsb0ToHexDigit_NullArray() { [EOL] try { [EOL] Utils.binaryBeMsb0ToHexDigit(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testBinaryBeMsb0ToHexDigit_EmptyArray() { [EOL] boolean[] src = new boolean[0]; [EOL] char result = Utils.binaryBeMsb0ToHexDigit(src); [EOL] assertEquals('0', result); [EOL] }
public void testBinaryBeMsb0ToHexDigit_FalseArray() { [EOL] boolean[] src = new boolean[] {false, false, false, false}; [EOL] char result = Utils.binaryBeMsb0ToHexDigit(src); [EOL] assertEquals('0', result); [EOL] }
public void testBinaryBeMsb0ToHexDigit_TrueArray() { [EOL] boolean[] src = new boolean[] {true, true, true, true}; [EOL] char result = Utils.binaryBeMsb0ToHexDigit(src); [EOL] assertEquals('f', result); [EOL] }
public void testBinaryBeMsb0ToHexDigit_MixedArray() { [EOL] boolean[] src = new boolean[] {true, false, true, false}; [EOL] char result = Utils.binaryBeMsb0ToHexDigit(src); [EOL] assertEquals('a', result); [EOL] }
public void testBinaryBeMsb0ToHexDigitEmptyArray() { [EOL] try { [EOL] boolean[] src = {}; [EOL] int srcPos = 0; [EOL] LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] fail("Expected IllegalArgumentException for empty array"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testBinaryBeMsb0ToHexDigitValue0() { [EOL] boolean[] src = {false, false, false, false}; [EOL] int srcPos = 0; [EOL] char result = LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] assertEquals('0', result); [EOL] } [EOL] public void testBinaryBeMsb0ToHexDigitValueF() { [EOL] boolean[] src = {true, true, true, true}; [EOL] int srcPos = 0; [EOL] char result = LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] assertEquals('f', result); [EOL] } [EOL] public void testBinaryBeMsb0ToHexDigitValue5() { [EOL] boolean[] src = {false, true, false, true}; [EOL] int srcPos = 0; [EOL] char result = LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] assertEquals('5', result); [EOL] } [EOL] public void testBinaryBeMsb0ToHexDigitValueA() { [EOL] boolean[] src = {true, false, true, false}; [EOL] int srcPos = 0; [EOL] char result = LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] assertEquals('a', result); [EOL] } [EOL] public void testBinaryBeMsb0ToHexDigitWithOffset() { [EOL] boolean[] src = {false, true, true, true, true}; [EOL] int srcPos = 1; [EOL] char result = LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] assertEquals('f', result); [EOL] } [EOL] public void testBinaryBeMsb0ToHexDigitWithLessThan4Bits() { [EOL] boolean[] src = {true, true}; [EOL] int srcPos = 0; [EOL] char result = LangUtils.binaryBeMsb0ToHexDigit(src, srcPos); [EOL] assertEquals('3', result); [EOL] }
public void testIntToHexDigit_ValidLowerBound() { [EOL] char result = ClassName.intToHexDigit(0); [EOL] assertEquals('0', result); [EOL] } [EOL] public void testIntToHexDigit_ValidUpperBound() { [EOL] char result = ClassName.intToHexDigit(15); [EOL] assertEquals('f', result); [EOL] } [EOL] public void testIntToHexDigit_InvalidLowerBound() { [EOL] try { [EOL] ClassName.intToHexDigit(-1); [EOL] fail("Expected IllegalArgumentException for input less than 0"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIntToHexDigit_InvalidUpperBound() { [EOL] try { [EOL] ClassName.intToHexDigit(16); [EOL] fail("Expected IllegalArgumentException for input greater than 15"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testByteArrayToShortEmptySourceAndZeroNBytes() { [EOL] final byte[] src = {}; [EOL] final int srcPos = 0; [EOL] final short dstInit = 0; [EOL] final int dstPos = 0; [EOL] final int nBytes = 0; [EOL] short result = ByteArrayUtils.byteArrayToShort(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(dstInit, result); [EOL] }
public void testByteArrayToShortValidInput() { [EOL] final byte[] src = {0x01, 0x02}; [EOL] final int srcPos = 0; [EOL] final short dstInit = 0x0000; [EOL] final int dstPos = 0; [EOL] final int nBytes = 2; [EOL] short result = ByteArrayUtils.byteArrayToShort(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(0x0201, result); [EOL] }
public void testByteArrayToShortInvalidNBytes() { [EOL] final byte[] src = {0x01, 0x02}; [EOL] final int srcPos = 0; [EOL] final short dstInit = 0x0000; [EOL] final int dstPos = 0; [EOL] final int nBytes = 3; // This should cause an IllegalArgumentException [EOL] try { [EOL] ByteArrayUtils.byteArrayToShort(src, srcPos, dstInit, dstPos, nBytes); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nBytes-1)*8+dstPos is greather or equal to than 16", e.getMessage()); [EOL] } [EOL] }
public void testByteArrayToShortWithOffset() { [EOL] final byte[] src = {0x00, 0x01, 0x02, 0x03}; [EOL] final int srcPos = 1; [EOL] final short dstInit = 0x0000; [EOL] final int dstPos = 0; [EOL] final int nBytes = 2; [EOL] short result = ByteArrayUtils.byteArrayToShort(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(0x0302, result); [EOL] }
public void testByteArrayToShortWithDstPos() { [EOL] final byte[] src = {0x01, 0x02}; [EOL] final int srcPos = 0; [EOL] final short dstInit = 0x0000; [EOL] final int dstPos = 8; [EOL] final int nBytes = 1; [EOL] short result = ByteArrayUtils.byteArrayToShort(src, srcPos, dstInit, dstPos, nBytes); [EOL] assertEquals(0x0100, result); [EOL] }
public void testHexToByte_ZeroLength() { [EOL] byte result = SomeClass.hexToByte("00", 0, (byte)0x00, 0, 0); [EOL] assertEquals((byte)0x00, result); [EOL] } [EOL] public void testHexToByte_IllegalArgumentException() { [EOL] try { [EOL] SomeClass.hexToByte("00", 0, (byte)0x00, 0, 2); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("(nHexs-1)*4+dstPos is greather or equal to than 8", e.getMessage()); [EOL] } [EOL] }
public void testHexToByte_ValidInput() { [EOL] byte result = SomeClass.hexToByte("1A", 0, (byte)0x00, 0, 1); [EOL] assertEquals((byte)0x10, result); [EOL] }
public void testHexToByte_ValidInputWithOffset() { [EOL] byte result = SomeClass.hexToByte("01AB", 2, (byte)0x00, 0, 1); [EOL] assertEquals((byte)0xB0, result); [EOL] }
public void testHexToByte_ValidInputWithDstInit() { [EOL] byte result = SomeClass.hexToByte("1A", 0, (byte)0x0F, 0, 1); [EOL] assertEquals((byte)0x1F, result); [EOL] }
public void testHexToByte_ValidInputWithDstPos() { [EOL] byte result = SomeClass.hexToByte("1A", 0, (byte)0x00, 2, 1); [EOL] assertEquals((byte)0x40, result); [EOL] }
public void testBinaryToLongEmptySourceAndZeroPosition() { [EOL] boolean[] src = new boolean[0]; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nBools = 0; [EOL] long result = ArrayUtils.binaryToLong(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(dstInit, result); [EOL] }
public void testBinaryToLongNoBools() { [EOL] boolean[] src = {true, false, true}; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nBools = 0; [EOL] long result = ArrayUtils.binaryToLong(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(dstInit, result); [EOL] }
public void testBinaryToLongIllegalArgumentException() { [EOL] boolean[] src = {true, false, true}; [EOL] int srcPos = 0; [EOL] long dstInit = 0L; [EOL] int dstPos = 0; [EOL] int nBools = 65; [EOL] try { [EOL] ArrayUtils.binaryToLong(src, srcPos, dstInit, dstPos, nBools); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToLongValidConversion() { [EOL] boolean[] src = {true, false, true, true}; [EOL] int srcPos = 1; [EOL] long dstInit = 0L; [EOL] int dstPos = 1; [EOL] int nBools = 3; [EOL] long expected = 0b1010; // binary representation of the expected result [EOL] long result = ArrayUtils.binaryToLong(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals(expected, result); [EOL] }
public void testBinaryToIntWithEmptySourceAndZeroPosition() { [EOL] boolean[] src = new boolean[0]; [EOL] int srcPos = 0; [EOL] int dstInit = 0; [EOL] int dstPos = 0; [EOL] int nBools = 0; [EOL] int result = Lang3.binaryToInt(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals("Result should be equal to dstInit when source is empty and nBools is 0", dstInit, result); [EOL] }
public void testBinaryToIntWithIllegalArgumentException() { [EOL] boolean[] src = new boolean[] {true, false, true}; [EOL] int srcPos = 0; [EOL] int dstInit = 0; [EOL] int dstPos = 0; [EOL] int nBools = 33; // nBools - 1 + dstPos will be >= 32 [EOL] try { [EOL] Lang3.binaryToInt(src, srcPos, dstInit, dstPos, nBools); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBinaryToIntWithValidInput() { [EOL] boolean[] src = new boolean[] {true, false, true, true}; [EOL] int srcPos = 1; [EOL] int dstInit = 0; [EOL] int dstPos = 2; [EOL] int nBools = 3; [EOL] int expected = (0 << 2) | (1 << 3) | (1 << 4); // Expected binary representation: 11000 [EOL] int result = Lang3.binaryToInt(src, srcPos, dstInit, dstPos, nBools); [EOL] assertEquals("Result should match expected binary representation", expected, result); [EOL] }
public void testIntToHexWithZeroLength() { [EOL] String initialString = "0000"; [EOL] String result = intToHex(0xABCD, 0, initialString, 0, 0); [EOL] assertEquals("Expecting the initial string to be returned", initialString, result); [EOL] } [EOL] public void testIntToHexWithIllegalArgumentException() { [EOL] try { [EOL] intToHex(0xABCD, 0, "0000", 0, 9); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testIntToHexWithAppending() { [EOL] String result = intToHex(0xABCD, 0, "0000", 4, 4); [EOL] assertEquals("Expecting hex digits to be appended", "0000ABCD", result); [EOL] } [EOL] public void testIntToHexWithReplacing() { [EOL] String result = intToHex(0xABCD, 0, "00000000", 0, 4); [EOL] assertEquals("Expecting hex digits to replace existing ones", "ABCD0000", result); [EOL] } [EOL] public void testIntToHexWithMixedAppendAndReplace() { [EOL] String result = intToHex(0xABCD, 0, "00000", 2, 4); [EOL] assertEquals("Expecting some hex digits to be replaced and some appended", "00ABCD0", result); [EOL] }

public void testLongToBinary_ZeroBools() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] result = ClassName.longToBinary(0L, 0, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testLongToBinary_IllegalArgumentException() { [EOL] boolean[] dst = new boolean[10]; [EOL] try { [EOL] ClassName.longToBinary(0L, 0, dst, 0, 65); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("nBools-1+srcPos is greather or equal to than 64", e.getMessage()); [EOL] } [EOL] } [EOL] public void testLongToBinary_ValidInput() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = new boolean[10]; [EOL] expected[5] = true; [EOL] boolean[] result = ClassName.longToBinary(32L, 5, dst, 5, 1); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testLongToBinary_FullLength() { [EOL] boolean[] dst = new boolean[64]; [EOL] boolean[] expected = new boolean[64]; [EOL] for (int i = 0; i < 64; i++) { [EOL] expected[i] = ((0x1 & (1L << i)) != 0); [EOL] } [EOL] boolean[] result = ClassName.longToBinary(-1L, 0, dst, 0, 64); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testByteToBinaryNoBools() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] result = YourClass.byteToBinary((byte) 0b10101010, 0, dst, 0, 0); [EOL] assertArrayEquals(dst, result); [EOL] } [EOL] public void testByteToBinaryIllegalArgumentException() { [EOL] boolean[] dst = new boolean[10]; [EOL] try { [EOL] YourClass.byteToBinary((byte) 0b10101010, 0, dst, 0, 9); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("nBools-1+srcPos is greather or equal to than 8", e.getMessage()); [EOL] } [EOL] }
public void testByteToBinaryFullByte() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = {true, false, true, false, true, false, true, false}; [EOL] boolean[] result = YourClass.byteToBinary((byte) 0b10101010, 0, dst, 0, 8); [EOL] for (int i = 0; i < 8; i++) { [EOL] assertEquals(expected[i], result[i]); [EOL] } [EOL] }
public void testByteToBinaryPartialByte() { [EOL] boolean[] dst = new boolean[10]; [EOL] boolean[] expected = {false, true, false}; [EOL] boolean[] result = YourClass.byteToBinary((byte) 0b10101010, 1, dst, 0, 3); [EOL] for (int i = 0; i < 3; i++) { [EOL] assertEquals(expected[i], result[i]); [EOL] } [EOL] }
public static final String escapeJson(final String input) { [EOL] return ESCAPE_JSON.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=Optional[new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_JSON=Optional[new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f))]; [EOL] CharSequenceTranslator ESCAPE_XML=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_HTML3=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_HTML4=Optional[new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE()))]; [EOL] CharSequenceTranslator ESCAPE_CSV=Optional[new CsvEscaper()]; [EOL] CharSequenceTranslator UNESCAPE_JAVA=Optional[new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } })];
public static final String unescapeHtml3(final String input) { [EOL] return UNESCAPE_HTML3.translate(input); [EOL] } [EOL] public StringEscapeUtils(); [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException; [EOL] public static final String escapeJava(final String input); [EOL] public static final String escapeEcmaScript(final String input); [EOL] public static final String escapeJson(final String input); [EOL] public static final String unescapeJava(final String input); [EOL] public static final String unescapeEcmaScript(final String input); [EOL] public static final String unescapeJson(final String input); [EOL] public static final String escapeHtml4(final String input); [EOL] public static final String escapeHtml3(final String input); [EOL] public static final String unescapeHtml4(final String input); [EOL] public static final String unescapeHtml3(final String input); [EOL] public static final String escapeXml(final String input); [EOL] public static final String unescapeXml(final String input); [EOL] public static final String escapeCsv(final String input); [EOL] public static final String unescapeCsv(final String input); [EOL] CharSequenceTranslator ESCAPE_JAVA=new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" } }).with(new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())).with(JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_ECMASCRIPT=new AggregateTranslator(new LookupTranslator(new String[][] { { "'", "\\'" }, { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_JSON=new AggregateTranslator(new LookupTranslator(new String[][] { { "\"", "\\\"" }, { "\\", "\\\\" }, { "/", "\\/" } }), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()), JavaUnicodeEscaper.outsideOf(32, 0x7f)); [EOL] CharSequenceTranslator ESCAPE_XML=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.APOS_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML3=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_HTML4=new AggregateTranslator(new LookupTranslator(EntityArrays.BASIC_ESCAPE()), new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()), new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())); [EOL] CharSequenceTranslator ESCAPE_CSV=new CsvEscaper(); [EOL] CharSequenceTranslator UNESCAPE_JAVA=new AggregateTranslator(new OctalUnescaper(), new UnicodeUnescaper(), new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()), new LookupTranslator(new String[][] { { "\\\\", "\\" }, { "\\\"", "\"" }, { "\\'", "'" }, { "\\", "" } }));
